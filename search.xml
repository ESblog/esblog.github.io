<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前后端渲染之争</title>
    <url>/pub/5a71ae7b/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前端渲染是在客户端完成字符串替换，后端渲染当然在服务器完成</p>
<p>-「后端渲染」指传统的 ASP、Java 或 PHP 的渲染机制；以及最初的CGI<br>-「前端渲染」指使用 JS 来渲染页面大部分内容，代表是现在流行的 SPA 单页面应用；</p>
<h1 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h1><p>前端渲染的优势</p>
<ul>
<li>局部刷新。无需每次都进行完整页面请求</li>
<li>懒加载。如在页面初始时只加载可视区域内的数据，滚动后rp加载其它数据，可以通过 react-lazyload 实现</li>
<li>富交互。使用 JS 实现各种酷炫效果</li>
<li>节约服务器成本。省电省钱，JS 支持 CDN 部署，且部署极其简单，只需要服务器支持静态文件即可</li>
<li>天生的关注分离设计。服务器来访问数据库提供接口，JS 只关注数据获取和展现</li>
<li>JS 一次学习，到处使用。可以用来开发 Web、Serve、Mobile、Desktop 类型的应用</li>
</ul>
<p>坏处：</p>
<ul>
<li>占用（一部分、少部分）客户端运算资源（解析模板）。前端代码多点，毕竟包含模板代码了么。脚本是不是首次下就慢点了（看你在意不在意这个毕竟能304和CDN啥的）。可能造成前后两份模板的情况，总归要后端吐出个首屏啥的先让用户看见吧。那这部分页面模板不就是后端拼好了吐出来的么</li>
</ul>
<ul>
<li>mathjax.js</li>
<li>angualr</li>
<li>vue</li>
<li>bootstrap也是吧</li>
</ul>
<!--
jquery呢？jquery是前端js库，跟渲染无关
注意区分前端渲染与第三方后端渲染
第三方后端服务: busuanzi, disqus,
busuanzi不算前端渲染，是通过ajax的。
-->


<h1 id="后端渲染"><a href="#后端渲染" class="headerlink" title="后端渲染"></a>后端渲染</h1><p>后端渲染的优势</p>
<ul>
<li>服务端渲染不需要先下载一堆 js 和 css 后才能看到页面（首屏性能）</li>
<li>SEO</li>
<li>服务端渲染不用关心浏览器兼容性问题（随着浏览器发展，这个优点逐渐消失）</li>
<li>对于电量不给力的手机或平板，减少在客户端的电量消耗很重要</li>
</ul>
<ul>
<li>python flask，django</li>
<li>java jsp</li>
<li></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[精读前后端渲染之争 | 知乎]<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjM2NjEyOA==">https://zhuanlan.zhihu.com/p/26366128<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uZnJlZWNvZGVjYW1wLm9yZy9oZXJlcy13aHktY2xpZW50LXNpZGUtcmVuZGVyaW5nLXdvbi00NmEzNDlmYWRiNTI=">Here’s Why Client-side Rendering Won | freecodecamp<i class="fa fa-external-link-alt"></i></span> | <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjI1MjE0Nw==">中文翻译<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2R0LWZlL3dlZWtseS9pc3N1ZXMvNQ==">前后端渲染之争<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NhbXNvbmcvYmxvZy9pc3N1ZXMvOA==">精读前后端渲染之争<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI4NzI1OTc3">后端渲染html、前端模板渲染html，jquery的html，各有什么区别？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title>数学体系架构</title>
    <url>/pub/4e753448/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><script src="//cdn.jsdelivr.net/npm/echarts@5.1.1/dist/echarts.min.js"></script>
<div id="mathchart" style="height:600px;"></div>
<script type="text/javascript">var myChart = echarts.init(document.getElementById('mathchart')); myChart.showLoading(); var data1 = { "name": "数学", "children": [ { "name": "代数", "children": [ {"name": "表示论", "value": 1616}, {"name": "调换代数", "value": 1027}, {"name": "同调代数", "value": 3891}, {"name": "李代数", "value": 891}, {"name": "代数数论", "value": 2893}, { "name": "其他", "children": [ {"name": "add", "value": 593}, {"name": "and", "value": 330} ] } ] }, { "name": "几何", "children": [ {"name": "代数几何", "value": 2105}, {"name": "微分几何", "value": 1316}, {"name": "黎曼几何", "value": 3151}, {"name": "代数拓扑", "value": 3770} ] }, { "name": "分析", "children": [ {"name": "泛函分析", "value": 2105}, {"name": "调和分析", "value": 1316}, {"name": "数学物理", "value": 3151}, {"name": "动力系统", "value": 3770}, {"name": "偏微分方程", "value": 3151}, {"name": "变分", "value": 3151} ] } ] }; myChart.hideLoading(); myChart.setOption(option = { tooltip: { trigger: 'item', triggerOn: 'mousemove' }, legend: { top: '2%', left: '3%', orient: 'vertical', data: [{ name: 'tree1', icon: 'rectangle' } , { name: 'tree2', icon: 'rectangle' }], borderColor: '#c23531' }, series:[ { type: 'tree', name: 'tree1', data: [data1], top: '5%', left: '7%', bottom: '2%', right: '60%', symbolSize: 7, label: { normal: { position: 'left', verticalAlign: 'middle', align: 'right' } }, leaves: { label: { normal: { position: 'right', verticalAlign: 'middle', align: 'left' } } }, expandAndCollapse: true, animationDuration: 550, animationDurationUpdate: 750 } ] });</script>

<!-- edit in  https://jsfiddle.net/xusong/z2qnLvcd/1/ -->
<div id="mathchart2" style="height:600px;"></div>
 <script type="text/javascript"> var myChart = echarts.init(document.getElementById('mathchart2')); myChart.showLoading(); var data = { "name": "数学", "children": [{ "name": "数论", "children": [{ "name": "初等数论" }, { "name": "解析数论" }, { "name": "代数数论" }, { "name": "超越数论" }, { "name": "概率数论" }, { "name": "计算数论" }, { "name": "其他" } ] }, { "name": "代数学", "children": [{ "name": "线性代数" }, { "name": "群论" }, { "name": "域论", "value": 1041 }, { "name": "李群", "value": 5176 }, { "name": "李代数", "value": 449 }, { "name": "Kac-Moody代数", "value": 5593 }, { "name": "环论", "value": 5534 }, { "name": "同调代数", "value": 9201 }, { "name": "微分代数", "value": 19975 }, { "name": "其他", "value": 1116 } ] }, { "name": "几何学", "children": [{ "name": "几何学基础" }, { "name": "欧式几何", "value": 1759 }, { "name": "非欧几何", "value": 2165 }, { "name": "球面几何", "value": 586 }, { "name": "向量和张量分析", "value": 3331 }, { "name": "仿射几何", "value": 772 }, { "name": "射影几何", "value": 3322 }, { "name": "微分几何", "value": 3322 }, { "name": "计算几何", "value": 3322 }, { "name": "分数维几何", "value": 3322 }, { "name": "其他", "value": 3322 } ] }, { "name": "拓扑学", "children": [{ "name": "点集拓扑学", "value": 1103110 }, { "name": "代数拓扑学", "value": 1732 }, { "name": "几何拓扑学", "value": 3623 }, { "name": "奇点理论", "value": 10066 }, { "name": "微分拓扑学", "value": 10066 } ] }, { "name": "数学分析", "children": [{ "name": "微分学", "value": 4116 }, { "name": "积分学", "value": 4116 }, { "name": "级数论", "value": 4116 }, { "name": "泛函分析", "children": [{ "name": "线性算子理论", "value": 1082 }, { "name": "变分法", "value": 1336 }, { "name": "拓扑线性空间", "value": 319 }, { "name": "希尔伯特空间", "value": 10498 }, { "name": "函数空间", "value": 2822 }, { "name": "算子代数", "value": 9983 }, { "name": "广义函数论", "value": 2213 }, { "name": "非线性泛函分析", "value": 1681 } ] } ] }, { "name": "计算数学", "children": [{ "name": "常微分方程数值解", "value": 1082 }, { "name": "偏微分方程数值解", "value": 1336 }, { "name": "积分变换与积分方程数值方法", "value": 319 }, { "name": "数值计算", "value": 10498 }, { "name": "优化计算方法", "value": 2822 }, { "name": "数值逼近与计算几何", "value": 9983 }, { "name": "小波分析与傅立叶分析的数值方法", "value": 2213 } ] }, { "name": "概率论", "children": [{ "name": "几何概率", "value": 1616 }, { "name": "概率分布", "value": 1027 }, { "name": "极限理论", "value": 3891 }, { "name": "随机过程", "value": 891 }, { "name": "马尔科夫过程", "value": 2893 }, { "name": "随机分析", "value": 5103 }, { "name": "鞅论", "value": 3677 }, { "name": "应用概率论", "value": 781 } ] }, { "name": "数理统计学", "children": [{ "name": "抽样理论", "value": 2105 }, { "name": "假设检验", "value": 1316 }, { "name": "非参数统计", "value": 3151 }, { "name": "方差分析", "value": 3770 }, { "name": "相关回归分析", "value": 2435 }, { "name": "统计推断", "value": 4839 }, { "name": "贝叶斯统计", "value": 1756 }, { "name": "试验设计", "value": 4268 }, { "name": "多元分析", "value": 1821 }, { "name": "时间序列分析", "value": 5833 } ] } ] }; myChart.hideLoading(); echarts.util.each(data.children, function(datum, index) { index % 2 === 0 && (datum.collapsed = true); }); myChart.setOption(option = { tooltip: { trigger: 'item', triggerOn: 'mousemove' }, series: [{ type: 'tree', data: [data], top: '1%', left: '7%', bottom: '1%', right: '20%', symbolSize: 7, label: { normal: { position: 'left', verticalAlign: 'middle', align: 'right', fontSize: 9 } }, leaves: { label: { normal: { position: 'right', verticalAlign: 'middle', align: 'left' } } }, expandAndCollapse: true, animationDuration: 550, animationDurationUpdate: 750 }] }); </script>
维基百科这样分

<ul>
<li>代数（初等 线性 多重线性 抽象）</li>
<li>分析/微积分学</li>
<li>几何 (离散 代数 解析 微分 有限)</li>
</ul>
<h1 id="概念-amp-分支"><a href="#概念-amp-分支" class="headerlink" title="概念 &amp; 分支"></a>概念 &amp; 分支</h1><p>现代数学大致分5大方向。粗糙来讲，可以分代数(数论)、几何(拓扑)、分析(微积分)，三大方向</p>
<ul>
<li>代数 algebra: 代数是数学的一个分支，是研究数、数量、关系、结构与代数方程（组）的通用解法及其性质的数学分支。代数的研究对象不仅是数字，而是各种抽象化的结构。常见的代数结构类型有群、环、域、模、线性空间等。<ul>
<li>线性代数是代数学的一个分支，主要处理线性关系问题。线性关系意即数学对象之间的关系是以一次形式来表达的。例如，在解析几何里，平面上直线的方程是二元一次方程；空间平面的方程是三元一次方程，而空间直线视为两个平面相交，由两个三元一次方程所组成的方程组来表示。含有n个未知量的一次方程称为线性方程。</li>
</ul>
</li>
<li>几何:</li>
<li>分析(mathematical analysis)：数学分析区别于其他非数学类学生的高等数学内容，是分析学中最古老、最基本的分支，一般指以微积分学、无穷级数和解析函数等的一般理论为主要内容，并包括它们的理论基础（实数、函数、测度和极限的基本理论）的一个较为完整的数学学科。</li>
</ul>
<p>集值分析集值函数的分析及应用。<br>凸分析是有关凸集合及凸函数的研究。</p>
<p>代数几何，</p>
<h1 id="根基"><a href="#根基" class="headerlink" title="根基"></a>根基</h1><p>欧几里得用公里推</p>
<p>几何，欧氏几何公理 等</p>
<p>代数，根基公理就是运算定律(交换律、结合律、分配律)</p>
<h1 id="分类-分支"><a href="#分类-分支" class="headerlink" title="分类-分支"></a>分类-分支</h1><h2 id="数学分析与高数的区别？"><a href="#数学分析与高数的区别？" class="headerlink" title="数学分析与高数的区别？"></a>数学分析与高数的区别？</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NzQ1MTY3">https://www.zhihu.com/question/19745167<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>相同点：两门课基本都是研究微积分学</li>
<li>区别高数重计算、应用，数分重证明</li>
</ul>
<h1 id="reading-list"><a href="#reading-list" class="headerlink" title="reading list"></a>reading list</h1><p>普林斯顿微积分读本</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%AD%A6%E7%A7%91%E5%88%86%E7%B1%BB%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86/110"><i class="fa fa-external-link"> 学科分类<i></a></li>
<li><a href="https://baike.baidu.com/item/%E8%B6%85%E8%B6%8A%E6%95%B0%E8%AE%BA/5919647"><i class="fa fa-external-link"><i>数学包含的学科 | 百度百科</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aC51aC5lZHUvfnRvbWZvcmRlL0ltYWdlcy9BYnN0cmFjdGlvbi5qcGc=">数学体系 | 休斯顿大学<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/pub/0/</url>
    <content><![CDATA[<h1 id="Demo-No-Title"><a href="#Demo-No-Title" class="headerlink" title="Demo: No-Title"></a>Demo: No-Title</h1><p>This is a post, which has no title.</p>
<p>Typically, we can locate this file by URL with default hexo settings.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure>

<p>e.g. URL is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.eson.org/2000/01/01/demo/hexo/no-title/</span><br></pre></td></tr></table></figure>
<p>It shows the full path of this post <code>_post/demo/hexo/no-title.md</code>.</p>
<h1 id="Trouble-in-hexo-abbrlink"><a href="#Trouble-in-hexo-abbrlink" class="headerlink" title="Trouble in hexo-abbrlink"></a>Trouble in hexo-abbrlink</h1><p><code>hexo-abbrlink</code> is a great plugin for hexo users. I setup <code>hexo-abbrlink</code> in my post.</p>
<p>In this case, url becomes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.eson.org/pub/0/</span><br></pre></td></tr></table></figure>

<p>God, I want to locate this post and add a title. But, how can I locate my error-post?</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="with-hexo-abbrlink-log"><a href="#with-hexo-abbrlink-log" class="headerlink" title="with hexo-abbrlink log"></a>with hexo-abbrlink log</h2><p>It would be better if <code>hexo-abbrlink</code> log the post with no title. Give me a warning.</p>
<h2 id="with-hexo-auto-category"><a href="#with-hexo-auto-category" class="headerlink" title="with hexo-auto-category"></a>with hexo-auto-category</h2><p>In this post, you may notice that the category is <code>demo</code>, <code>hexo</code>.<br>Actually, the full path of this post is <code>_post/demo/hexo/no-title.md</code>. It really helps.</p>
<p><code>hexo-auto-category</code> binds folder structure to category. It is also a good way to locate your post.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><code>hexo-abbrlink</code> and <code>hexo-auto-category</code></p>
]]></content>
      <categories>
        <category>demo</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>plugin</tag>
        <tag>hexo-abbrlink</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo插件系列】日志的自动分类插件 hexo-auto-category</title>
    <url>/pub/e2f6e239/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><!--
## pain point
-->

<p>Hexo写日志，通常我们都需要维护一个front-matter信息，包括<code>title</code>、<code>date</code>。博客多了，为了方便日志分类，一般还需要设置<code>categories</code>。<br>比如下面的例子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo简介</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2008-08-08</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">web开发</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">博客框架</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>久而久之，就会发现很多问题：</p>
<ul>
<li><strong>工作繁琐</strong>：大量的category是重复性工作</li>
<li><strong>容易出错</strong>：大小写和中英文目录有可能混杂。比如有个<code>web</code>目录，偶尔我们写成了<code>Web</code>，造成了目录树中冗余的节点。</li>
<li><strong>可维护性差</strong>：如果要更改<code>目录树</code>中的节点，就要手动更改每个日志的<code>categories</code>变量。</li>
</ul>
<p>本文介绍一种<strong>自动生成categories</strong>的插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvaGV4by1hdXRvLWNhdGVnb3J5">hexo-auto-category官方地址<i class="fa fa-external-link-alt"></i></span>。</p>
<h1 id="自动生成-categories"><a href="#自动生成-categories" class="headerlink" title="自动生成 categories"></a>自动生成 <code>categories</code></h1><p>最常用的文件管理策略，就是利用文件系统目录结构(树形结构 directory-tree)。<br>同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。<code>hexo-auto-category</code>根据日志文件(Markdown)所在文件目录自动分类，即自动生成<code>markdown</code>的front-matter中的<code>categories</code>变量。</p>
<p><strong>示例</strong></p>
<p>对于博客  <code>source/_post/web/framework/hexo.md</code>，该插件会自动生成以下<code>categories</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">web</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">framework</span></span><br></pre></td></tr></table></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-auto-category --save</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在站点根目录下的<code>_config.yml</code>添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate categories from directory-tree</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/xu-song/hexo-auto-category</span></span><br><span class="line"><span class="comment"># depth: the depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line"><span class="attr">auto_category:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">depth:</span></span><br></pre></td></tr></table></figure>

<h1 id="编译-amp-部署"><a href="#编译-amp-部署" class="headerlink" title="编译 &amp; 部署"></a>编译 &amp; 部署</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><p>如果只想生成第一级目录分类，可以设置<code>depth</code>属性，比如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_category:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">depth:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如有任何疑问，可在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvaGV4by1hdXRvLWNhdGVnb3J5L2lzc3Vlcw==">Github Issue<i class="fa fa-external-link-alt"></i></span>提出</p>
<!--
# 可行性分析
- 结构通用：`categories`变量是树形结构，文件系统的目录也是树形结构。关于树形结构竟然也有[争议](https://github.com/hexojs/hexo/issues/848)

# 疑问
这是theme-level的，还是site-level的？

# 疑似相关插件
hexo-generator-category  这个插件是生成tag文件的，不是用来自动生成category的。
-->
]]></content>
      <categories>
        <category>demo</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>plugin</tag>
        <tag>category</tag>
        <tag>hexo-auto-category</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo插件系列】流程图、时序图、</title>
    <url>/pub/488fc27f/</url>
    <content><![CDATA[<p>有些markdown支持流程图、时序图，比如<span class="exturl" data-url="aHR0cHM6Ly9tYXhpYW5nLmlvLw==">马克飞象<i class="fa fa-external-link-alt"></i></span>。</p>
<p>实际上，这部分的渲染并非markdown引擎(后端渲染)做的，而是采用的第三方<code>前端渲染引擎</code>。其原理类似公式渲染引擎<code>mathjax</code>。</p>
<p>因此，这种流程图和时序图很容易嵌入到hexo博客中，而且已经有了相关的插件。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><div id="flowchart-0" class="flow-chart"></div>

<ul>
<li>渲染引擎：flowchart.js</li>
<li>相关的hexo插件: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1Ymtvby9oZXhvLWZpbHRlci1mbG93Y2hhcnQ=">hexo-filter-flowchart<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUI2JUU1JUJBJThGJUU1JTlCJUJF">序列图<i class="fa fa-external-link-alt"></i></span>（Sequence Diagram），<br>亦称为循序图、时序图，是一种UML行为图。描述物件在时间序列中的交叉作用。<br>序列图会描绘在此情境下有关的物件，以及此物件和其他物件交换讯息的顺序。<br>序列图一般和待开发系统逻辑视图上，用例的实现有关。序列图有时也称为事件图或事件情境。</p>
<p>序列图中会绘出许多同时存在的不同物件（以垂直线表示，线的开始及结束为生命线，表示物件的产生及结束），<br>而物件之间横向的箭头，表示物件之间交换的讯息，会以发生的先后顺序来排列。因此可以用图形的方式，<br>简单说明用例在执行时的情形。</p>
<div id="sequence-0"></div>

<ul>
<li>渲染引擎: js-sequence-diagrams</li>
<li>相关的hexo插件: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1Ymtvby9oZXhvLWZpbHRlci1zZXF1ZW5jZQ==">hexo-filter-sequence<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<div id="sequence-1"></div>

<blockquote>
<p><strong>提示：</strong> 想了解更多，请查看 <strong>流程图</strong> <span class="exturl" data-url="aHR0cDovL2FkcmFpLmdpdGh1Yi5pby9mbG93Y2hhcnQuanMv">语法<i class="fa fa-external-link-alt"></i></span>以及<strong>时序图</strong><span class="exturl" data-url="aHR0cHM6Ly9icmFtcC5naXRodWIuaW8vanMtc2VxdWVuY2UtZGlhZ3JhbXMv">语法<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUIxJUJCJUU1JTlCJUJF">类图<i class="fa fa-external-link-alt"></i></span>（class diagram）是软件工程的一种UML静态结构图，<br>该图描述了系统的类集合，类的属性和类之间的关系。</p>
<p>类图是面向对象式的建模。他们一般都被用于概念建模（conceptual modelling）的系统分类的应用程序，并可将模型建模转译成代码。</p>
<blockquote>
<p><strong>提示：</strong> 了解更多 <span class="exturl" data-url="aHR0cHM6Ly9nb2pzLm5ldC9sYXRlc3Qvc2FtcGxlcy9pbmRleC5odG1s">https://gojs.net/latest/samples/index.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>planttext.com  可以导出SVG</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2pzLm5ldC9sYXRlc3Qvc2FtcGxlcy91bWxDbGFzcy5odG1s">gojs.net<i class="fa fa-external-link-alt"></i></span>  用的canvas<script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">浏览器->Cloudflare: 加密数据
Cloudflare-->web服务器: 明文</textarea><textarea id="sequence-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
e=>end
op=>operation: My Operation
cond=>condition: Yes or No?

st->op->cond
cond(yes)->e
cond(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ul>
]]></content>
      <categories>
        <category>demo</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>plugin</tag>
        <tag>流程图</tag>
        <tag>时序图</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo插件系列】 常用tag</title>
    <url>/pub/fc959554/</url>
    <content><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css" />
<h2 id="buttion标签"><a href="#buttion标签" class="headerlink" title="buttion标签"></a>buttion标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn #, Text %&#125;</span><br></pre></td></tr></table></figure>

<a class="btn" href="#">
            <i class="fa fa-"></i>Text
          </a>
<a class="btn" href="#">
            <i class="fa fa-"></i>Text
          </a>
<a class="btn" href="#" title="Title">
            <i class="fa fa-"></i>Text & Title
          </a>
<a class="btn" href="#">
            <i class="fa fa-home fa-fw"></i>Text & Icon (fixed width)
          </a>


<ul>
<li>为什么要采用 <code>#</code>, <code>,</code>, <code>&amp;</code> 作为分隔符?</li>
<li>title的作用是什么？hover text吗？貌似没这功能</li>
<li>相关issue &amp; 更多用法: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L3B1bGwvMTMyOA==">https://github.com/iissnan/hexo-theme-next/pull/1328<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h2><p><code>note</code>标签在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L3B1bGwvMTY5Nw==">theme-next中集成<i class="fa fa-external-link-alt"></i></span>，它是<code>blockquote</code>的强化版，额外增加了一些样式</p>
<ul>
<li><strong>主题</strong>: simple, modern, flat</li>
<li><strong>色系&amp;图标</strong>: default(灰色), primary(紫色), info(蓝色), success(绿色), warning(黄色), danger(红色)</li>
</ul>
<p>用法 &amp; 示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125;</span><br><span class="line">success **欢迎**[note](.)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note success no-icon">
            <p>success <strong>粗体</strong> <a href=".">链接</a> 无图标</p>
          </div>
<div class="note success">
            <p>success <strong>粗体</strong> <a href=".">链接</a> 文本</p>
          </div>
<div class="note info">
            <p>info <strong>粗体</strong> <a href=".">链接</a> 文本</p>
          </div>
<div class="note warning">
            <p>warning <strong>粗体</strong> <a href=".">链接</a> 文本</p>
          </div>
<div class="note danger">
            <p>danger <strong>粗体</strong> <a href=".">链接</a> 文本</p>
          </div>



<p><strong>建议</strong>: 采用更优雅的方式，比如<code>&gt;warning</code>的方式，继承markdown的<code>blockquote</code></p>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lorem &#123;% label default@ipsum %&#125; &#123;% label primary@dolor sit %&#125;.</span><br></pre></td></tr></table></figure>
<p>Lorem <span class="label default">ipsum</span> <span class="label primary">dolor sit</span>.</p>
<ul>
<li>theme-next中集成</li>
<li>相关issue &amp; usage: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L3B1bGwvMTY5Nw==">https://github.com/iissnan/hexo-theme-next/pull/1697<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p><strong>色系</strong>: 与note相同</p>
</blockquote>
<p>只是添加了颜色而已吧，搞这么复杂。</p>
<h2 id="tab标签"><a href="#tab标签" class="headerlink" title="tab标签"></a>tab标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1"><i class="fa fa-text-width"></i>code 1</a></li><li class="tab"><a href="#first-unique-name-2"><i class="fa fa-amazon"></i>solution 2</a></li><li class="tab"><a href="#first-unique-name-3">First unique name 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong><br>b = 1<br>c = 2<br>b + c</p></div><div class="tab-pane" id="first-unique-name-2"><p>b + c = 3</p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div>

<ul>
<li>theme-next中集成</li>
<li>能不能采用更简洁的用法？为什么要采用html注释的方式？</li>
<li>tab内貌似不能放code block</li>
<li>相关issue: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L3B1bGwvMTY5Nw==">https://github.com/iissnan/hexo-theme-next/pull/1697<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="extrul标签"><a href="#extrul标签" class="headerlink" title="extrul标签"></a>extrul标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% exturl Hexo Theme Next https://github.com/iissnan/hexo-theme-next/ %&#125;</span><br></pre></td></tr></table></figure>


<p><strong>评价</strong>: 不如直接写html，比如下面的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-external-link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">[<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-external-link&quot;</span>&gt;</span>link to <span class="tag">&lt;/<span class="name">i</span>&gt;</span>](ss)</span><br></pre></td></tr></table></figure>

<p>update: 貌似已经废弃</p>
<h2 id="类似的bootstrap标签"><a href="#类似的bootstrap标签" class="headerlink" title="类似的bootstrap标签"></a>类似的bootstrap标签</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5oYWhhY2suY29tL2hleG8tdGhlbWUtd2l4by9Eb2NzL3RhZy1wbHVnaW5zLWNuLw==">http://www.hahack.com/hexo-theme-wixo/Docs/tag-plugins-cn/<i class="fa fa-external-link-alt"></i></span>  挺赞</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d6cGFuL2hleG8tdGFnLWJvb3RzdHJhcA==">https://github.com/wzpan/hexo-tag-bootstrap<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="chat标签"><a href="#chat标签" class="headerlink" title="chat标签"></a>chat标签</h2><p>hexo-tag-chat，under construction.</p>
<div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>文字狱是清朝哪位皇帝兴起的;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>康熙</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>拼音中四声起于;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>元<iclass=fa fa-external-link></i></pre> </div> </div> </div>  </div> </div>  </div></div>

<p><strong>TODO</strong>:</p>
<ul>
<li>用icon还是用头像？icon可以用foneawesome，头像限制比较多 <br></li>
<li>丰富头像库</li>
</ul>
<p><i class="fa fa-question"></i><br><i class="fa fa-user-circle"></i><br><i class="fa fa-user"></i><br><i class="fa fa-users"></i><br><i class="fa fa-user-graduate"></i><br><i class="fa fa-user-graduate"></i></p>
<h2 id="instagram标签"><a href="#instagram标签" class="headerlink" title="instagram标签"></a>instagram标签</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlYTMvaGV4by10YWctaW5zdGFncmFt">hexo-tag-instagram<i class="fa fa-external-link-alt"></i></span> 将 Instagram元素嵌入Hexo博客</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 默认配置 width:100%, captioned:true</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">instagram</span> <span class="string">url:https://www.instagram.com/p/Bg71nq4HuAU/</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">instagram</span> <span class="string">Bg71nq4HuAU</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="comment"># 2. 无标题 + 调整尺寸</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">instagram</span> <span class="literal">false</span> <span class="string">Bg71nq4HuAU</span> <span class="number">60</span><span class="string">%</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">instagram</span> <span class="string">captioned:false</span> <span class="string">id:Bg71nq4HuAU</span> <span class="string">width:60%</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
<div class="instagram-wrapper"><blockquote class="instagram-media" data-instgrm-version="7" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(60%- 2px); width:calc(60% - 2px);"><div style="padding:8px;"> <div style=" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;"> <div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div></div><p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/p/Bg71nq4HuAU/" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;" target="_blank"></a></p></div></blockquote></div><script async defer src="//platform.instagram.com/en_US/embeds.js"></script>
]]></content>
      <categories>
        <category>demo</category>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo中如何支持公式 mathjax</title>
    <url>/pub/6aa77778/</url>
    <content><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css" />
<p><strong>UPDATE: 2018-08-08</strong>: github markdown已经支持公式，</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aGpheC5vcmcv">MathJax<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9raGFuLmdpdGh1Yi5pby9LYVRlWC8=">Katex<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="mathjax"><a href="#mathjax" class="headerlink" title="mathjax"></a>mathjax</h1><blockquote>
<p>Beautiful math in all browsers<br><br>A <strong>JavaScript display engine</strong> for mathematics that works in all browsers.<br><br> —— 来自<span class="exturl" data-url="aHR0cDovL3d3dy5tYXRoamF4Lm9yZy8=">www.mathjax.org<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。 MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者。</p>
<ul>
<li>无损缩放，支持多种方式的公式渲染(math-render)。(不采用图片、Flash)<ul>
<li><strong>CSS引擎</strong>：采用CSS生成数学公式</li>
<li><strong>SVG引擎</strong>：采用SVG生成数学公式</li>
<li><strong>MathML引擎</strong>：</li>
</ul>
</li>
<li>源码拷贝。可以拷贝LaTeX、wiki等；</li>
<li>输入形式可以是MathML、TeX或者ASCIImath</li>
</ul>
<h1 id="html中使用mathjax"><a href="#html中使用mathjax" class="headerlink" title="html中使用mathjax"></a>html中使用mathjax</h1><p>mathjax就是个<strong>前端渲染引擎</strong>。</p>
<!--
angular，等
-->

<script async src="//jsfiddle.net/xusong/npc3gu8v/embed/html,result/"></script>

<p>也可以借鉴 <span class="exturl" data-url="aHR0cHM6Ly9rZXh1ZS5mbS9sYXRleC5odG1s">https://kexue.fm/latex.html<i class="fa fa-external-link-alt"></i></span></p>
<p>或者拷贝以上代码，保存为<code>math.html</code>，双击打开就能看到渲染好的公式。</p>
<h1 id="hexo中使用mathjax"><a href="#hexo中使用mathjax" class="headerlink" title="hexo中使用mathjax"></a>hexo中使用mathjax</h1><p>同样很简单，仅需两步。</p>
<ol>
<li>加载mathjax的cdn</li>
<li>博客中按照<code>tex</code>语法写公式即可</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>markdown中书写：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>x = &#123;-b <span class="keyword">\pm</span> <span class="keyword">\sqrt</span>&#123;b<span class="built_in">^</span>2-4ac&#125; <span class="keyword">\over</span> 2a&#125;.<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>首先会被markdown-render渲染到html，成为以下的脚本 (这一步不是必须的，mathjax能直接解析<code>$$</code>符号，而无需该步的转换)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;math/tex; mode=display&quot;</span>&gt;x = &#123;-b \pm \sqrt&#123;b^<span class="number">2</span>-4ac&#125; \over 2a&#125;.&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器加载html页面后，根据script引用加载<code>mathjax.js</code>，然后在浏览器端渲染成以下公式：</p>
<p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他方式：</span></span><br><span class="line">\[x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.\]</span><br><span class="line"><span class="comment"># 如果存在转义问题，可以采用以下方式</span></span><br><span class="line">\\[x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.\\]</span><br></pre></td></tr></table></figure>

<h1 id="hexo中支持公式的markdown插件"><a href="#hexo中支持公式的markdown插件" class="headerlink" title="hexo中支持公式的markdown插件"></a>hexo中支持公式的markdown插件</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXJlbmRlcmVyLW1hcmtlZA==">hexo-renderer-marked<i class="fa fa-external-link-alt"></i></span><br>这是hexo默认的markdown渲染插件，其调用的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2Vk">marked.js渲染引擎<i class="fa fa-external-link-alt"></i></span>。<em>这个插件支持公式渲染吗？</em></li>
<li>hexo-math插件<ul>
<li>支持<code>math</code>标签</li>
<li>早期版本支持<code>$$</code>和<code>$</code>符号，新版不再支持</li>
<li>如果喜欢，推荐使用 (hexo-filter-mathjax)[<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLW1hdGgvaXNzdWVzLzUxI2lzc3VlY29tbWVudC02Nzc5ODI5OTNd">https://github.com/hexojs/hexo-math/issues/51#issuecomment-677982993]<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>hexo-filter-mathjax</li>
<li>主题自带的公式<ul>
<li>theme-next 自带mathjax支持 （我用的这个）</li>
</ul>
</li>
</ul>
<h1 id="markdown渲染引擎"><a href="#markdown渲染引擎" class="headerlink" title="markdown渲染引擎"></a>markdown渲染引擎</h1><ul>
<li><code>marked</code> <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZWQuanMub3JnL2RlbW8v">demo<i class="fa fa-external-link-alt"></i></span><ul>
<li>轻量级，更新活跃</li>
<li>jupyter、google-colab、hexo默认采用的<code>marked.js</code>作为渲染引擎</li>
<li>hexo模块: hexo-renderer-marked</li>
<li>该模块并不会渲染公式，但是mathjax也能识别，因为mathjax可直接解析<code>$$</code></li>
</ul>
</li>
<li><code>pandoc</code> 重量级 <span class="exturl" data-url="aHR0cDovL3BhbmRvYy5vcmcvdHJ5Lw==">demo<i class="fa fa-external-link-alt"></i></span><ul>
<li>pandoc -f markdown+tex_math_single_backslash –mathjax test.md -o test.html</li>
<li>以上参数的命令可以解决问题</li>
<li>hexo模块: hexo-renderer-pandoc</li>
</ul>
</li>
<li><code>kramdown</code><span class="exturl" data-url="aHR0cDovL2tyYW1kb3duLXNhbmRib3guaGVyb2t1YXBwLmNvbS8=">demo<i class="fa fa-external-link-alt"></i></span><ul>
<li>派生自<code>marked</code>，但是很久没有更新过了</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NzMjMxbi9jczIzMW4uZ2l0aHViLmlvL2Jsb2IvbWFzdGVyL19jb25maWcueW1sI0wxMQ==">cs231n<i class="fa fa-external-link-alt"></i></span> 采用的kramdown</li>
<li>hexo模块: hexo-renderer-kramed</li>
</ul>
</li>
</ul>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="公式的转义问题"><a href="#公式的转义问题" class="headerlink" title="公式的转义问题"></a>公式的转义问题</h2><p>有时会遇到公式渲染失败，有时也会遇到很多不同的公式写法，比如：</p>
<ul>
<li><code>$</code>、<code>$$</code>  </li>
<li><code>\(</code>和<code>\)</code>、<code>\[</code>和<code>\]</code></li>
<li><code>\\(</code>和<code>\\)</code>、<code>\\[</code>和<code>\\]</code>，示例<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvY29tbXVuaXR5L2RvY3VtZW50YXRpb24jbWF0aF9pbl9tYXJrZG93bg==">tensorflow<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NzMjMxbi9jczIzMW4uZ2l0aHViLmlvL21hc3Rlci9uZXVyYWwtbmV0d29ya3MtMS5tZA==">cs231n<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>公式渲染失败，一般是由于不同的markdown引擎的渲染方式不同引起的，以上的<code>\\(</code>这种写法也是为了和markdown渲染引擎作斗争，以致于写个公式变得这么复杂。</p>
<p><strong>举个例子</strong></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">\[ x=1 \]</span><br></pre></td></tr></table></figure>

<p>经过<code>marked</code>引擎解析成以下html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>[ x=1 ]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 这里的反斜线<code>\[</code>经过<code>marked</code>引擎后转义丢失，只剩下<code>[</code>。因此mathjax无法识别，以致于公式无法正常显示。</p>
<p>怎么办？既然反斜线丢失，那就多加个反斜线，写成<code>\\[ x=1 \\]</code>。这样就渲染成功了</p>
<h2 id="常见的markdown渲染引擎"><a href="#常见的markdown渲染引擎" class="headerlink" title="常见的markdown渲染引擎"></a>常见的markdown渲染引擎</h2><ul>
<li><code>marked</code> 轻量级 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZWQuanMub3JnL2RlbW8vP3RleHQ9JTIzJTIwZ29vZCUwQSQkeCsxJTVDb3ZlciU1Q3NxcnQlN0IxLXglNUUyJTdEJCQlMEElMEElMjMlMjBiYWQlMEElNUMlNUJ4KzElNUNvdmVyJTVDc3FydCU3QjEteCU1RTIlN0QlNUMlNUQlMEElNUMoeCsxJTVDb3ZlciU1Q3NxcnQlN0IxLXglNUUyJTdEJTVDKQ==">demo<i class="fa fa-external-link-alt"></i></span></li>
<li><code>pandoc</code> 重量级 也存在同样的问题，<span class="exturl" data-url="aHR0cDovL3BhbmRvYy5vcmcvdHJ5Lz90ZXh0PSUyMytnb29kJTBBJCR4KzElNUNvdmVyJTVDc3FydCU3QjEteCU1RTIlN0QkJCUwQSUwQSUyMytiYWQlMEElNUMlNUJ4KzElNUNvdmVyJTVDc3FydCU3QjEteCU1RTIlN0QlNUMlNUQlMEElNUMoeCsxJTVDb3ZlciU1Q3NxcnQlN0IxLXglNUUyJTdEJTVDKSZmcm9tPW1hcmtkb3duJnRvPQ==">demo<i class="fa fa-external-link-alt"></i></span><ul>
<li>pandoc -f markdown+tex_math_single_backslash –mathjax test.md -o test.html</li>
<li>以上参数的命令可以解决问题</li>
</ul>
</li>
<li><code>kramdown</code>也存在同样的问题，<span class="exturl" data-url="aHR0cDovL2tyYW1kb3duLXNhbmRib3guaGVyb2t1YXBwLmNvbS8=">demo<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<ol>
<li>多加个反斜线，比如<code>\[</code>要写成<code>\\[</code>   <strong>麻烦</strong></li>
<li>修改marked源码，取消了对<code>\\</code>,<code>\&#123;</code>,<code>\&#125;</code>的转义(escape)   <strong>麻烦</strong></li>
<li>采用其他markdown引擎，比如kramdown (比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NzMjMxbi9jczIzMW4uZ2l0aHViLmlvL2Jsb2IvbWFzdGVyL19jb25maWcueW1sI0wxMQ==">cs231n<i class="fa fa-external-link-alt"></i></span>就采用的kramdown)   <strong>发现也不work</strong></li>
<li>把所有<code>\[</code>替换成<code>$$</code>  <strong>我目前是这样做的</strong></li>
</ol>
<p><strong>建议</strong>:</p>
<p>不要采用 <code>\[</code> 或 <code>\(</code>的格式书写公式，尽量用<code>$$</code> 或 <code>$</code></p>
<ol>
<li>很多引擎不支持<code>\[</code>或 <code>\(</code> (比如github)</li>
<li><code>\[</code>中的反斜线经常会被解释成转义符号，造成符号丢失</li>
</ol>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>`theme-next`为什么要限定markdown引擎？不应该和markdown引擎无关吗？</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>...</pre> </div> </div> </div>  </div> </div>  </div></div>




<h1 id="公式里的-被渲染成斜体"><a href="#公式里的-被渲染成斜体" class="headerlink" title="公式里的 _ 被渲染成斜体"></a>公式里的 <code>_ </code>被渲染成斜体</h1><p>由于 Markdown 在 MathJax 之前起作用，有时下标记号会被 Markdown 吃掉，变成 HTML 标记 <code>&lt;i&gt;</code> 或 <code>&lt;em&gt;</code> 而失去 LaTeX 的下标效果，造成数学公式显示不正常。</p>
<p>有时会被渲染成斜体。$c _  {t-1} $ 和 $ h _  {t-1}$</p>
<p><strong>解决策略</strong>：带空格的 <code>_</code> 不会被渲染成斜体。</p>
<p>$c_{t-1} $ 和 $ h_{t-1}$</p>
<p>$ c_{t-1} $ 和 $ h_{t-1} $</p>
<p>$ c_{t-1} $ 和 $ h_{t-1} $</p>
<p>$ c_{t-1} $ 和 $ h_{t-1} $</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2RvY3MvTUFUSC5tZA==">theme-next中使用mathjax | next官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3Nob215LnRvcC8yMDE2LzEwLzIyL2hleG8tbWFya2Rvd24tbWF0aGpheC8=">Hexo下mathjax的转义问题<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VtcHR5c2V0MTEwL2FydGljbGUvZGV0YWlscy81MDEyMzIzMQ==">使Marked.js与MathJax共存<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNS8wOS8wOS9maXgtY29uZmxpY3QtYmV0d2Vlbi1tYXRoamF4LWFuZC1tYXJrZG93bi8="> MathJax 与 Markdown 的冲突<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>demo</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端渲染</tag>
        <tag>mathjax</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的注意力机制 原理 及 代码</title>
    <url>/pub/c47c5082/</url>
    <content><![CDATA[<p>seq2seq缺陷：无论之前的context有多长，包含多少信息量，最终都要被压缩成一个几百维的vector。这意味着context越大，最终的state vector会丢失越多的信息。</p>
<p>Attention based model的核心思想: 一个模型完全可以在decode的过程中利用<strong>context的全部信息</strong>，而不仅仅是最后一个state。</p>
<ol>
<li>ss<ul>
<li>global attention</li>
<li>local attention</li>
</ul>
</li>
<li>ewrw<ul>
<li>soft</li>
<li>hard</li>
</ul>
</li>
</ol>
<h1 id="各种各样的attention"><a href="#各种各样的attention" class="headerlink" title="各种各样的attention"></a>各种各样的attention</h1><ul>
<li>2014年google mind团队的这篇论文《Recurrent Models of Visual Attention》，他们在RNN模型上使用了attention机制来进行图像分类。</li>
<li>Bahdanau等人在论文《Neural Machine Translation by Jointly Learning to Align and Translate》中，使用类似attention的机制在机器翻译任务上将翻译和对齐同时进行，他们的工作算是第一个将attention机制应用到NLP领域中。</li>
<li>接着attention机制被广泛应用在基于RNN/CNN等神经网络模型的各种NLP任务中。</li>
<li>2017年，google机器翻译团队发表的《Attention is all you need》中大量使用了自注意力（self-attention）机制来学习文本表示。</li>
</ul>
<h2 id="什么是attention，attention的起源"><a href="#什么是attention，attention的起源" class="headerlink" title="什么是attention，attention的起源"></a>什么是attention，attention的起源</h2><h2 id="广义的attention"><a href="#广义的attention" class="headerlink" title="广义的attention"></a>广义的attention</h2><p>见google得transformer。</p>
<p>Attention函数的本质可以被描述为一个查询（query）到一系列（键key-值value）对的映射，</p>
<h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self attention"></a>self attention</h2><p>什么是self-attention，下面这个图就是self-attention。</p>
<p><img src="/images/raw/NN - transformer - self attention - visualization.png"></img></p>
<p>可以理解为没有target的attention，也可以理解为自己把自己当做target进行attention。</p>
<h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><h2 id="Structured-Self-attention"><a href="#Structured-Self-attention" class="headerlink" title="Structured Self-attention"></a>Structured Self-attention</h2><p>参考 A Structured Self-attentive Sentence Embedding</p>
<h2 id="Self-Attention-with-Relative-Position-Representations-google-brain-2018"><a href="#Self-Attention-with-Relative-Position-Representations-google-brain-2018" class="headerlink" title="Self-Attention with Relative Position Representations - google brain 2018"></a>Self-Attention with Relative Position Representations - google brain 2018</h2><p>Self-Attention with Relative Position Representations（基于相对位置表示的子注意力模型）</p>
<h2 id="Reinforced-Self-Attention"><a href="#Reinforced-Self-Attention" class="headerlink" title="Reinforced Self-Attention"></a>Reinforced Self-Attention</h2><p>Reinforced Self-Attention Network: a Hybrid of Hard and Soft Attention for Sequence Modeling（增强的自注意力网络:一种对序列建模的硬和软注意力的混合）</p>
<h2 id="Distance-based-Self-Attention-Network"><a href="#Distance-based-Self-Attention-Network" class="headerlink" title="Distance-based Self-Attention Network"></a>Distance-based Self-Attention Network</h2><p>Distance-based Self-Attention Network for Natural Language Inference（基于距离的自注意力网络的自然语言推理）</p>
<h2 id="sparse-attention"><a href="#sparse-attention" class="headerlink" title="sparse attention"></a>sparse attention</h2><h2 id="hierarchical-attentioin"><a href="#hierarchical-attentioin" class="headerlink" title="hierarchical attentioin"></a>hierarchical attentioin</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jcy5jbXUuZWR1L34uL2hvdnkvcGFwZXJzLzE2SExULWhpZXJhcmNoaWNhbC1hdHRlbnRpb24tbmV0d29ya3MucGRm">Hierarchical Attention Networks for Document Classification<i class="fa fa-external-link-alt"></i></span></p>
<img alt="Hierarchical Attention Network" src="/images/raw/NN - attentioin - hierarchical attention.jpg" title="Hierarchical Attention Network">

<p>采用了word-level和sentent-level的attention。</p>
<ol>
<li>a word sequence encoder<ul>
<li>采用的GRU。<span class="exturl" data-url="aHR0cDovL3d3dy5hY2x3ZWIub3JnL2FudGhvbG9neS9EMTUtMTE2Nw==">Document Modeling with Gated Recurrent Neural Network…<i class="fa fa-external-link-alt"></i></span> 这篇文章提到，在文本分类领域 GRU比LSTM效果好。</li>
<li>也可以采用CNN</li>
</ul>
</li>
<li>a word-level attention layer</li>
<li>a sentence encoder</li>
<li>a sentence-level attention layer</li>
</ol>
<p>可视化分析</p>
<img alt="Hierarchical Attention Network" src="/images/raw/NN - attentioin - hierarchical attention - result.jpg" title="Hierarchical Attention Network">






<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kaXN0aWxsLnB1Yi8yMDE2L2F1Z21lbnRlZC1ybm5zLw==">Attention and Augmented Recurrent Neural Networks | Distill<i class="fa fa-external-link-alt"></i></span></li>
<li></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mvc3dMd2xhNzVSSVFmeUREQ1BZeW5hdw==">深度学习中的注意力机制 | 张俊林 2017<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9yb2JlcnQtZGx1dC9wLzg2MzgyODMuaHRtbA==">自然语言处理中的自注意力机制（Self-attention）| cnblogs<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM2NTkxMzk0">知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wbG1zbWlsZS5naXRodWIuaW8vMjAxNy8xMC8xMi9BdHRlbnRpb24tYmFzZWQtTk1ULw==">注意力机制和PyTorch实现机器翻译<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDg2NTc1">【论文推荐】最新七篇自注意力机制(Self-attention)相关论文<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXh1ZS5mbS9hcmNoaXZlcy80NzY1">《Attention is All You Need》浅读（简介+代码）| kexue.fm<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
      </categories>
  </entry>
  <entry>
    <title>2018 - 中美贸易战</title>
    <url>/pub/40e93d5d/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>据中方统计，最近10年间美国对中国出口年均增长11%，几乎是同期中国对美国出口年均增速的两倍。美国62%的大豆、14%的棉花、25%的波音飞机、17%的汽车、15%的集成电路都出口到中国。</p>
<p>而据美国官方数据，2016年中国是美国农产品第二大出口市场；每个美国农民平均向中国出口农产品约1.2万美元。</p>
<h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul>
<li>宣战</li>
<li>回应</li>
<li>2018-03-29: 休战, 中国妥协 <a href="https://mp.weixin.qq.com/s?__biz=MzA5NjU0NTEzMg==&mid=2652226604&idx=3&sn=e2d780e544bf3c15abed8cb5afbf42c3&chksm=8b4f142fbc389d391ed69778b2da6b475b661dce4dd90ad1e0e58a2df5fc804af2f47e9f9aff&mpshare=1&scene=23&srcid=0329JgvZuHRQownNW7ZwipsM#rd">中国提出把部分从韩国和台湾采购的<strong>半导体</strong>转而向美国购买，以减少中国对美国的贸易顺差</a></li>
<li>2018-04-16: 中兴制裁<span class="exturl" data-url="aHR0cDovL25ldy5xcS5jb20vb21uLzIwMTgwNDE5LzIwMTgwNDE5QTFSODZPLmh0bWw/cGd2X3JlZj1haW8yMDE1JnB0bGFuZz0yMDUy">美国商务部下令禁止美国公司向中兴出售元器件等产品，为期7年<i class="fa fa-external-link-alt"></i></span><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3MzU2MjYwOQ==">如何评价 2018 年 4 月中兴通讯同时遭英美两国制裁？| 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li>华为年底退出美国市场</li>
</ul>
</li>
<li>2018.04.25: 调查华为</li>
<li>2018.06.15 美发布加征关税商品清单<ul>
<li>将对从中国进口的约500亿美元商品加征25%的关税</li>
</ul>
</li>
<li>2018.06.19 美考虑对额外2000亿美元的中国商品加征10%的关税</li>
<li>2018.06.19 中国A股暴跌，千股跌停。黑色星期二。暴跌的主要原因就是今早7点半，特朗普的白宫声明</li>
<li>2018.06.19 商务部发表声明：如果美方失去理性，中方将不得不采取数量型和质量型相结合的综合措施，做出强有力的反制。因为美国对华出口额仅1300亿，因此提出来质量型</li>
<li>2018.7.6 经国务院批准，对原产于美国的659项约500亿美元进口商品加征25%的关税。主要包括 牛猪鸡鸭鱼虾蟹、植物、越野车小汽车、化学医疗等。美方发表声明称，<strong>如果中国采取报复性措施，美国将继续追加额外关税</strong>。</li>
<li>2018-12.01: 休战</li>
</ul>
<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><ul>
<li>中美贸易逆差，根本原因是劳动力成本差距太大导致的产业转移</li>
<li>美国一边对高科技禁止出口，一边又在低科技领域毫无成本优势，自由贸易解决不了逆差问题</li>
<li>与中国打“贸易战”主要的目的是转移国内矛盾、为了赢得选民的选票。看来特郎普的压力也够大的。</li>
</ul>
<h2 id="中美贸易领域"><a href="#中美贸易领域" class="headerlink" title="中美贸易领域"></a>中美贸易领域</h2><p>贸易战这个东西我觉得要考虑双方的进出口情况：美国：进口的主要是日常消费品，比如服装、玩具等，数量规模大，和老百姓生活相关度高，打贸易战会造成美国人民日常消费成本大幅度增加，会造成美国人民反对该政策；          </p>
<p>出口的主要是粮食作物和芯片等技术类产品，会造成部分高科技公司的收入减少，部分农业受到冲击，鉴于美国农业的大规模种植水平，受到影响的人不会太多。中国：进口粮食（主要是大豆），食用油价格预期会上涨，芯片类科技产品推进国产化，这点题主已经提到了，台湾很可能会跟着美国走，所以电子产品预计会价格上涨；</p>
<p>出口的日常消费品受影响这方面才是危险的，因为失掉美国市场后，过剩产能如果不能及时消化，会造成上述行业大量的滞销、停产以及人员失业，这个影响的人会很多，国民收入减少会导致内需萎缩，对国内经济冲击会比较大。</p>
<h3 id="依赖性分析"><a href="#依赖性分析" class="headerlink" title="依赖性分析"></a>依赖性分析</h3><ul>
<li>中国是美国飞机和大豆的第一大出口市场，也是汽车和棉花的第二大出口市场</li>
</ul>
<h2 id="中美贸易逆差"><a href="#中美贸易逆差" class="headerlink" title="中美贸易逆差"></a>中美贸易逆差</h2><img title="中国与世界主要国家和地区的贸易平衡" alt="中国与世界主要国家和地区的贸易平衡" src="/images/raw/Economy - 中国与世界主要国家和地区的贸易平衡 - 人民日报.jpg">

<p>以往，中国的集成电路主要从韩国、日本和中国台湾进口，也正因此，在中国与多国的双边贸易中，韩国、日本与中国台湾是难得的几个与中国大陆保持顺差纪录的地区。</p>
<h2 id="宣战"><a href="#宣战" class="headerlink" title="宣战"></a>宣战</h2><p>美国总统特朗普当地时间22日中午在白宫签署针对中国的总统备忘录，宣布基于“301调查”结果，将对约600亿美元进口自中国的商品加征关税，并对中资投资美国设限等。</p>
<p>中国随即作出回应。中国驻美大使馆发表声明说，中方不希望打贸易战，但绝不惧怕贸易战，有信心、有能力应对任何挑战。如果美方执意要打，我们将奉陪到底，并采取所有必要措施坚决捍卫自身合法权益。</p>
<p>几个小时后，中国商务部公布针对美国进口钢铁和铝产品232措施的中止减让产品清单，拟对约30亿美元自美进口商品加征关税。</p>
<p>针对美国特朗普总统指责中国，“窃取美国知识产权和技术”等，崔大使回应：美国应该意识到，现在世界变化了。很多国家都在发展创新。如果美国觉得技术都是自己一家的，这种态度就是“歧视他国”，是无知的表现。</p>
<h1 id="美国想干什么"><a href="#美国想干什么" class="headerlink" title="美国想干什么"></a>美国想干什么</h1><p>川普究竟是谈判策略还是真要打一场贸易战？贸易战是个杀敌一千自损八百的手段。</p>
<ul>
<li>想捞点钱</li>
<li></li>
</ul>
<p>这次贸易战开打，结果必是中国忍痛让美国剪点羊毛</p>
<h1 id="中国底气如何"><a href="#中国底气如何" class="headerlink" title="中国底气如何"></a>中国底气如何</h1><ul>
<li>底气之一，在于中国有巨大的市场</li>
<li>底气之二，在于中国承受损失的能力更强。<ul>
<li>屠新泉称，贸易战关键的不是损失，而是承受损失的能力。“中国承受损失的能力强于美国。”</li>
</ul>
</li>
</ul>
<h1 id="中国能打什么牌"><a href="#中国能打什么牌" class="headerlink" title="中国能打什么牌"></a>中国能打什么牌</h1><h2 id="第一张牌，是限制进口美国商品。"><a href="#第一张牌，是限制进口美国商品。" class="headerlink" title="第一张牌，是限制进口美国商品。"></a>第一张牌，是限制进口美国商品。</h2><ul>
<li>限制进口美国农产品和高端制成品将是中国的一大“王牌”。</li>
</ul>
<img alt="中美贸易战-涉及领域" src="/images/raw/Economy - 中美贸易战 - 涉及领域 - 人民日报.jpg">

<p><span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1Nak01TWpBeE5ETTRNQT09Jm1pZD0yNjY2MTkxMzAzJmlkeD0xJnNuPTFkMTRkMmY2YTUxOGI2MGYzMmMwNjc2ZGQwYWMyZTQwJmNoa3NtPWJkYjJiMDg0OGFjNTM5OTJkNDRkNGRjYzY4ODNiZTc2MDA5NDFmODZmZDc0OWJlOWU5MjM5YTg4NmM2ZGRjZWUyZmM3OWZlOGVkMzAmbXBzaGFyZT0xJnNjZW5lPTIzJnNyY2lkPTAzMjVOZmdrRVNmc1VZMzJUT05aTXNQViNyZA==">完整清单 - 中国拟对这些美国进口产品加征关税<i class="fa fa-external-link-alt"></i></span></p>
<p>囧，中国并未对美国高端产品加税吧。。。</p>
<p>中国目前对美国的反击，从比例上看，是选择了一个比较不痛不痒的点，谈不上是正儿八经的回击，更像是一种姿态。</p>
<h2 id="第二张牌，是削减对美国出口。"><a href="#第二张牌，是削减对美国出口。" class="headerlink" title="第二张牌，是削减对美国出口。"></a>第二张牌，是削减对美国出口。</h2><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>美国当地时间3月22日，在特朗普宣布对华贸易限制措施之后，资本市场出现恐慌，美国股市暴跌。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>美国之前制裁中兴，理由是中兴向伊朗出售美国技术，双方后来达成和解，但中兴需要支付约 8.9 亿美元的刑事和民事罚金。此次，美方封杀中兴的理由是其没有严格履行和解协议，只解雇了四名高级雇员，未处罚或减少35名员工奖金，这就是所谓的“实锤”。</p>
<h1 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h1><p>川普贸易战醉翁之意不在酒<br>德媒指出，美国总统特朗普的关税举措首要打击目标并非中国。<br>特朗普需要对中国做出威胁姿态，以不失去自己选民的支持。特朗普迄今宣布的对铝和钢的惩罚性措施的首要打击目标并非中国，而是巴西或日本。</p>
<h2 id="看不懂系列"><a href="#看不懂系列" class="headerlink" title="看不懂系列"></a>看不懂系列</h2><ul>
<li>xon：对推动中国进一步开放是有利的，但被某些利益集团绑架的话，会使中国重走日本80年代末的老路……</li>
<li>xon：此次贸易战的起因是中国不遵循WTO承诺，可以对比一下，如果真正实现WTO承诺，对普通老百姓是不是有利的。未兑现的WTO承诺所保护的车企、银行、石化、医药、通讯、旅游、教育、出版物等等。都是大型国有企业盘踞的、普通老百姓怨声载道的方面。<ul>
<li>不错，嗟，来食</li>
<li>说出这种话的人，不是权贵就是奴才…  </li>
</ul>
</li>
<li>xon：如果当年谈判不是授权外让步，就会小概率出现如今的被动；如果当年可以不中断“十五年”的渐进式开放就不会出现如今所担忧的开闸式冲击。<br>换句话说造成如今的局面完全是被某些金字塔顶端的人耽搁了…<ul>
<li>有些现在才开始开放的领域（需要被保护），其实可以早一些开放？</li>
<li>xon：1. 有些行业可以不开放，当年入世谈判时并未被授权，当年某位谈判领导会上临时决定的。2、许诺开放的行业里在“十五年”内是在采取渐进式开放的，譬如铁道部转铁路总公司、土地“以租代征”合法化等等都是这一过程的重要节点。但是某大的换届换思路后就嘎然而止了…… 如今的被动不是外界强加给我们的，完全可以说是自己折腾的…</li>
</ul>
</li>
</ul>
<!--
中国不遵循WTO承诺，是不是中国指某些领域不开放？
-->

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU0MDQ1Nzk4">| 知乎<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2OTUzOTE4OA==">如何看待 2018 年中美贸易战打响？ | 知乎<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>others</category>
        <category>economy</category>
      </categories>
  </entry>
  <entry>
    <title>spiking neural network 脉冲神经网络</title>
    <url>/pub/fee0b5e6/</url>
    <content><![CDATA[<h1 id="生物学背景"><a href="#生物学背景" class="headerlink" title="生物学背景"></a>生物学背景</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlFJUU3JUJCJThGJUU3JUE3JTkxJUU1JUFEJUE2">神经科学<i class="fa fa-external-link-alt"></i></span>（英语：neuroscience），又称神经生物学，是专门研究神经系统的结构、功能、发育、演化、遗传学、生物化学、生理学、药理学及病理学的一门科学。对行为及学习的研究都是神经科学的分支。</p>
<p>对人脑研究是个跨领域的范畴，当中涉及分子层面、细胞层面、神经小组、大型神经系统，如视觉神经系统、脑干、脑皮层。</p>
<p>最高层次的研究就是结合<code>认知科学</code>成为认知神经科学，其专家被称为认知心理学家。一些研究人员相信认知神经科学提供对思维及知觉的全面了解，甚至可以代替心理学。</p>
<h2 id="神经元结构"><a href="#神经元结构" class="headerlink" title="神经元结构"></a>神经元结构</h2><table class="toccolours" style="width:410px; margin:0 0 5px 10px; "><tbody><tr style="text-align: center;"></tr><tr style="text-align: center;"><th style="background:white"><div style="position: relative;"><a href="/wiki/File:Neuron_Hand-tuned.svg" class="image"><img alt="Neuron Hand-tuned.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/400px-Neuron_Hand-tuned.svg.png" width="400" height="215" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/600px-Neuron_Hand-tuned.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/800px-Neuron_Hand-tuned.svg.png 2x" data-file-width="1179" data-file-height="634"></a><div style="position: absolute; left:50px; top: 2px; color:"><a class="mw-selflink selflink">树突</a></div><div style="position: absolute; left:135px; top: 60px; color:"><a href="/wiki/%E7%BB%86%E8%83%9E" title="细胞">细胞体</a></div><div style="position: absolute; left:189px; top: 116px; color:"><a href="/wiki/%E8%BB%B8%E7%AA%81" class="mw-redirect" title="轴突">轴突</a></div><div style="position: absolute; left:13px; top: 197px; color:"><a href="/wiki/%E7%B4%B0%E8%83%9E%E6%A0%B8" class="mw-redirect" title="细胞核">细胞核</a></div><div style="position: absolute; left:226px; top: 38px; color:"><a href="/wiki/%E8%98%AD%E6%B0%8F%E7%B5%90" title="兰氏结">兰氏结</a></div><div style="position: absolute; left:319px; top: 0px; color:"><a href="/wiki/%E7%AA%81%E8%A7%B8" class="mw-redirect" title="突触">突触</a></div><div style="position: absolute; left:306px; top: 161px; color:"><a href="/wiki/%E6%96%BD%E6%97%BA%E7%B4%B0%E8%83%9E" title="施旺细胞">施旺细胞</a></div><div style="position: absolute; left:220px; top: 187px; color:"><a href="/wiki/%E9%AB%93%E9%9E%98" class="mw-redirect" title="髓鞘">髓鞘</a></div></div></th></tr><tr><th style="text-align: left; line-height: 1;"><center>典型神经元的结构(来自wikipedia)</center></th></tr></tbody></table>


<ul>
<li><p>树突为神经元的输入通道，其功能是将自其他神经元所接收的动作电位（电信号）传送至细胞本体。其他神经元的动作电位借由位于树突分支上的多个突触传送至树突上。与长度可达约1米的轴突相比，树突通常较短。</p>
</li>
<li><p>轴突（Axon）由神经元组成，即神经细胞之细胞本体长出突起，功能为传递细胞本体之动作电位至突触。</p>
</li>
</ul>
<h2 id="生物学功能"><a href="#生物学功能" class="headerlink" title="生物学功能"></a>生物学功能</h2><ul>
<li><p>陈述性记忆：对事件、人物等有意识回忆，相对容易记住和忘记</p>
</li>
<li><p>非陈述性记忆：对抽象、感知、动作和习惯等无意识操作</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjY1NzMxMw==">突触可塑性<i class="fa fa-external-link-alt"></i></span>（Synaptic plasticity）指神经细胞间的连接，即突触，其连接强度可调节的特性。突触可塑性的产生有多种原因，例如：突触中释放的神经递质数量的变化，细胞对神经递质的反应效率。突触可塑性被认为是构成记忆和学习的重要神经化学基础。</p>
</li>
</ul>
<h2 id="脉冲"><a href="#脉冲" class="headerlink" title="脉冲"></a>脉冲</h2><blockquote>
<p>Biological neurons use <code>short and sudden increases</code> in voltage to send information.<br>action potentials, spikes or pulses.</p>
</blockquote>
<h1 id="SNN-脉冲神经网络"><a href="#SNN-脉冲神经网络" class="headerlink" title="SNN 脉冲神经网络"></a>SNN 脉冲神经网络</h1><image width="50%" title="integrate-and-fire neuron" src="/images/raw/NN - spiking - integrate and fire.jpg" >


<h1 id="信息承载"><a href="#信息承载" class="headerlink" title="信息承载"></a>信息承载</h1><p>SNN的信息承载，仅仅是靠脉冲频率吗？等价于二值的普通编码吗？</p>
<blockquote>
<p>neurons encode information in the timing of single spikes, and not only just in their average<br>firing frequency.</p>
</blockquote>
<h1 id="独特之处"><a href="#独特之处" class="headerlink" title="独特之处"></a>独特之处</h1><blockquote>
<p>they can encode temporal information in their signals, but therefore do also need different and biologically more plausible rules for synaptic plasticity.</p>
</blockquote>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>SNN的图像分类等常见任务上效果怎样？</p>
<p>SNN的优势是什么，独特之处是什么？</p>
<p>一个image怎样转化成脉冲作为网络输入？</p>
<p>firing rate表示信号强弱，单个脉冲有什么意义？</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
      </categories>
      <tags>
        <tag>SNN</tag>
        <tag>spiking neural network</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN网络结构可视化</title>
    <url>/pub/4d880ede/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="可视化方法"><a href="#可视化方法" class="headerlink" title="可视化方法"></a>可视化方法</h1><ul>
<li>传统CNN可视化<ul>
<li>对kernel可视化</li>
<li>对中间feature map可视化</li>
<li>对全连接weight可视化</li>
</ul>
</li>
<li>反卷积网络 可视化</li>
</ul>
<h1 id="传统CNN可视化"><a href="#传统CNN可视化" class="headerlink" title="传统CNN可视化"></a>传统CNN可视化</h1><h2 id="单层sparse-autoencoder在的可视化"><a href="#单层sparse-autoencoder在的可视化" class="headerlink" title="单层sparse autoencoder在的可视化"></a>单层sparse autoencoder在的可视化</h2><p>对autoencoder的参数W进行可视化。(训练数据STL-10)</p>
<img src="http://ufldl.stanford.edu/wiki/images/0/0f/Gabor.jpg" title="sparse autoencoder学习到的参数W" max-width="10px">

<p>通过可视化可以看到，autoencoder学习到的参数类似边缘检测器(a set of edge detectors)<br>不同的隐藏单元学会了在图像的不同位置和方向进行边缘检测。</p>
<p>以上来自<span class="exturl" data-url="aHR0cDovL3VmbGRsLnN0YW5mb3JkLmVkdS93aWtpL2luZGV4LnBocC9FeGVyY2lzZTpTcGFyc2VfQXV0b2VuY29kZXIjUmVzdWx0cw==">ufldl<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>这里sparse autoencoder是在图片8<em>8的patch上学习得到的，学到**参数W类似CNN中的8</em>8的卷积核**。因此UFLDL的教程中直接把w当做cnn的卷积核，效果也不错。</p>
</blockquote>
<h2 id="cnn的可视化"><a href="#cnn的可视化" class="headerlink" title="cnn的可视化"></a>cnn的可视化</h2><ul>
<li>传统CNN可视化的缺陷：<ul>
<li>传统CNN可视化的一个缺陷是，不能够还原图片，只能单向可视化。例如，给定一个hidden feature。</li>
</ul>
</li>
</ul>
<h1 id="反卷积网络-可视化"><a href="#反卷积网络-可视化" class="headerlink" title="反卷积网络 可视化"></a>反卷积网络 可视化</h1><p>反卷积网络与传统CNN网络采用同样的结构，只不过训练方法不同。反卷积网络采用非监督学习，类似autoencoder的思想。</p>
<p>这样</p>
<h2 id="deep-dream-详解"><a href="#deep-dream-详解" class="headerlink" title="deep dream 详解"></a>deep dream 详解</h2><p>见参考中的deep dream源码</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li>可视化梯度消失、梯度爆炸</li>
<li>可视化ReLU对梯度消失的影响</li>
<li>可视化LSTM对梯度消失的影响</li>
</ul>
<p>借鉴deep-dream，可视化lstm</p>
<ul>
<li>lstm可视化 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2FzYXAtcmVwb3J0L3Zpc3VhbGl6aW5nLWxzdG0tbmV0d29ya3MtcGFydC1pLWYxZDNmYTZhYWNlNw==">https://medium.com/asap-report/visualizing-lstm-networks-part-i-f1d3fa6aace7<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>paper</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzEzMTEuMjkwMQ==">Visualizing and Understanding Convolutional Networks | 2014 Zeiler ECCV<i class="fa fa-external-link-alt"></i></span>  CNN领域可视化理解的开山之作</li>
<li></li>
</ul>
<p>博客</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDgzMzU3NA==">Deep Visualization:可视化并理解CNN | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kaXN0aWxsLnB1Yi8yMDE3L2ZlYXR1cmUtdmlzdWFsaXphdGlvbi8=">feature-visualization | distill<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>code</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy90cmVlL21hc3Rlci90ZW5zb3JmbG93L2V4YW1wbGVzL3R1dG9yaWFscy9kZWVwZHJlYW0=">deep-dream | tensorflow官方<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>可视化</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习中的梯度爆炸  梯度消失</title>
    <url>/pub/87a0acfd/</url>
    <content><![CDATA[<h1 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h1><p>随着网络深度的加深，梯度消失问题会愈加明显。无论cnn，rnn</p>
<p>什么形式会爆炸</p>
<p>f_{t+1}</p>
<p>累加的形式不消失<br>$f_{t+1} = w * f_{t} + w f_{t-1} + …$</p>
<h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>。设输入数据为 $x$ ，对 $x$ 的卷积操作就可以看做是 $Wx+b$</p>
<p>我们设第一层卷积的参数为$W_1, b_1$ ，第二层卷积的参数是$W_2, b_2$，依次类推。又设激活函数为$f$ ，每一层卷积在经过激活函数前的值为$a_i$，经过激活函数后的值为$f_i$。</p>
<p>按照上面的表示，在CNN中，输入$x$ ，第一层的输出就是$f_1=f[W_1x+b_1]$，第二层的输出就是$f_2= f[W_2f[W_1x+b_1]+b_2]$ ，第三层的输出就是$f_3= f[W_3f[W_2f[W_1x+b_1]+b_2]+b_3]$。设最终损失为$L$ ，我们来尝试从第三层开始，用BP算法推导一下损失对参数$W_1$的偏导数，看看会发生什么。</p>
<p>为了简洁起见，略过求导过程，最后的结果为<br>$\frac{\partial{L}}{\partial{W_1}}=\frac{\partial{L}}{\partial{f_3}}\frac{\partial{f_3}}{\partial{a_3}}W_3\frac{\partial{f_2}}{\partial{a_2}}W_2\frac{\partial{f_1}}{\partial{a_1}}\frac{\partial{a_1}}{\partial{W_1}}$。<br><strong>我们常常说原始神经网络的梯度消失问题，这里的</strong>$\frac{\partial{f_3}}{\partial{a_3}}$、$\frac{\partial{f_2}}{\partial{a_2}}$<br> <strong>就是梯度消失的“罪魁祸首”</strong>。<br> 例如sigmoid的函数，它的导数的取值范围是(0, 0.25]，也就是说对于导数中的每一个元素，我们都有$0&lt;\frac{\partial{f_3}}{\partial{a_3}}\le0.25$，$0&lt;\frac{\partial{f_2}}{\partial{a_2}}\le0.25$，小于1的数乘在一起，必然是越乘越小的。这才仅仅是3层，如果10层的话， 根据$0.25^{10}\approx0.000000954$，第10层的误差相对第一层卷积的参数 $W_1$的梯度将是一个非常小的值，这就是所谓的“梯度消失”。</p>
<p>ReLU函数的改进就是它使得 $\frac{\partial{f_3}}{\partial{a_3}}\in{0,1}$ ， $\frac{\partial{f_2}}{\partial{a_2}}\in{0,1}$ ， $\frac{\partial{f_1}}{\partial{a_1}}\in{0,1}$ ，这样的话只要一条路径上的导数都是1，无论神经网络是多少层，这一部分的乘积都始终为1，因此深层的梯度也可以传递到浅层中。</p>
<p>那为什么同样的方法在RNN中不奏效呢？其实这一点Hinton在它的IRNN论文里面（arxiv：[1504.00941] A Simple Way to Initialize Recurrent Networks of Rectified Linear Units）是很明确的提到的：</p>
<p>也就是说在RNN中直接把激活函数换成ReLU会导致非常大的输出值。为了讲清楚这一点，我们先用同上面相似的符号把原始的RNN表示出来：</p>
<p>$$a_i=Wf_{i-1}+Ux_{i}+b_i$$，<br>$$f_i=f[a_i]$$</p>
<p>在这个表示中，RNN每个阶段的输入是 $x_i$，和CNN每一层使用独立的参数$W_i$不同，原始的<br>RNN在每个阶段都共享一个参数 $W$。如果我们假设从某一层开始输入 $x_i$ 和偏置 $b_i$ 都为0，<br>那么最后得到的输出就是 $f[W…[Wf[Wf[Wf_i]]]]$ ，这在某种程度上相当于对参数矩阵 $W$ 作连乘，<br>很显然，只要 $W$ 有一个大于1的特征值，在经过若干次连乘后都会导致结果是一个数值非常庞大的矩阵。</p>
<p>另外一方面，将激活函数换成ReLU也不能解决梯度在长程上传递的问题。同样考虑 $f_3$ 对 $W$ 的导数。在CNN中，每一层的参数 $W_1,W_2,W_3……$ 是互相独立的，然而RNN中 W 参与了每个时间段的运算，因此 $f_3$ 对 $W$ 导数更复杂，写出来是</p>
<p>$\frac{\partial{f_3}}{\partial{W_1}}=\frac{\partial{f_3}}{\partial{a_3}}f_2+\frac{\partial{f_3}}{\partial{a_3}}W\frac{\partial{f_2}}{\partial{a_2}}f_1+\frac{\partial{f_3}}{\partial{a_3}}W\frac{\partial{f_2}}{\partial{a_2}}W\frac{\partial{f_1}}{\partial{a_1}}\frac{\partial{a_1}}{\partial{W_1}}$ 。我们可以看下最后 $\frac{\partial{f_3}}{\partial{a_3}}W\frac{\partial{f_2}}{\partial{a_2}}W\frac{\partial{f_1}}{\partial{a_1}}\frac{\partial{a_1}}{\partial{W_1}}$<br>这部分，使用ReLU后，当梯度可以传递时，有<br>$\frac{\partial{f_3}}{\partial{a_3}}=\frac{\partial{f_2}}{\partial{a_2}}=\frac{\partial{f_3}}{\partial{a_1}}=1$ ，但这个式子中还是会有两个 $W$ 的连乘。在更长程上，就会有更多 $W$ 的连乘。对于CNN来说，这个部分是 $W_1,W_2,W_3…..$ 进行连乘，一方面它们都是稀疏矩阵，另一方面 $W_1,W_2,W_3….$ 互不相同，很大程度上都能抵消掉梯度爆炸的影响。</p>
<p>最后，IRNN在RNN上使用了ReLU，取得了比较好的结果，其中的原因在于，它对 $W$ 和 $b_i$ 取了比较特殊的初值： $W=I$ , $b_i=0$ 。<br>这样在梯度的式子 $\frac{\partial{f_3}}{\partial{a_3}}W\frac{\partial{f_2}}{\partial{a_2}}W\frac{\partial{f_1}}{\partial{a_1}}\frac{\partial{a_1}}{\partial{W_1}}$ 中W尽管会连乘，但是会类似于单位矩阵 $I$ 的连乘，不会引起太明显的梯度数值变化。另外一方面，也不会引起非常大的输出值</p>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h1 id="梯度爆炸-策略"><a href="#梯度爆炸-策略" class="headerlink" title="梯度爆炸 策略"></a>梯度爆炸 策略</h1><p>梯度爆炸问题其实不是什么麻烦。</p>
<p>因为现在大家都会做某种形式的Gradient clipping（也就是限定一下梯度绝对值的上限，超过就截断）来避免梯度爆炸。<br>觉得Gradient clipping很糙？其实一点都不糙，因为用SGD训练深度模型数学上本身就已经糙的不能再糙了。觉得LSTM不需要这种东西？No。如果查查主流工具包，或者看看比较实际的LSTM应用论文，应该都至少这么做了。</p>
<p>SGD为什么糙？只有GD才不糙？一切近似算法都糙？</p>
<blockquote>
<p>saizheng: relu确实容易explode，除非加大很tricky的clipping，因为clipping多了，优化就做不好了<br>为什么？？</p>
</blockquote>
<blockquote>
<p>saizheng: 普通rnn做超长memory一般就用quoc le的那个trick，identity init，我猜你看过那个paper，但是那个东西的tradeoff就是损失了短时间段内fit复杂nonlinearty的能力</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYxMjY1MDc2">RNN中为什么要采用tanh而不是ReLu作为激活函数？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>存在的问题</category>
      </categories>
  </entry>
  <entry>
    <title>softmax的困扰、改进</title>
    <url>/pub/e85b0673/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="数学上的softmax"><a href="#数学上的softmax" class="headerlink" title="数学上的softmax"></a>数学上的softmax</h2><p>在数学，尤其是概率论和相关领域中，Softmax函数，或称归一化指数函数，是逻辑函数的一种推广。它能将一个含任意实数的K维向量  ${\displaystyle \mathbf {z} }$“压缩”到另一个K维实向量  ${\displaystyle \sigma (\mathbf {z} )}$ 中，使得每一个元素的范围都在 ${\displaystyle (0,1)}$ 之间，并且所有元素的和为1。该函数的形式通常按下面的式子给出：</p>
<p>$${\displaystyle \sigma (\mathbf {z} ) _ {j}={\frac {e^{z_ {j}}}{\sum _ {k=1}^{K}e^{z_ {k}}}}}   \quad j = 1, …, K.$$</p>
<h2 id="softmax的应用"><a href="#softmax的应用" class="headerlink" title="softmax的应用"></a>softmax的应用</h2><p>Softmax函数实际上是有限项离散概率分布的梯度对数归一化。因此，Softmax函数在包括 多项逻辑回归，多项线性判别分析，朴素贝叶斯分类器和人工神经网络等的多种基于概率的多分类问题方法中都有着广泛应用。特别地，在多项逻辑回归和线性判别分析中，函数的输入是从K个不同的线性函数得到的结果，而样本向量 x 属于第 j 个分类的概率为：</p>
<p>$$<br>P(y=j\mid \mathbf {x} )=\frac {e^{\mathbf {x} ^{\mathsf {T}}\mathbf {w}_ {j}}}{\sum_{k=1}^{K}e^{\mathbf {x} ^{\mathsf {T}}\mathbf {w}_ {k}}}<br>$$</p>
<p>这可以被视作K个线性函数<br>$ \mathbf {x} \mapsto \mathbf {x} ^{\mathsf {T}}\mathbf {w}_ {1},\ldots ,\mathbf {x} \mapsto \mathbf {x} ^{\mathsf {T}}\mathbf {w}_{K}$<br>Softmax函数的复合（ $\mathbf {x} ^{\mathsf {T}}\mathbf {w}  \mathbf {x} \mathbf {w}$ ）。</p>
<h2 id="loss-function"><a href="#loss-function" class="headerlink" title="loss function"></a>loss function</h2><p>softmax loss是我们最熟悉的loss之一了，分类任务中使用它，分割任务中依然使用它。softmax loss实际上是由softmax和cross-entropy loss组合而成，两者放一起数值计算更加稳定。这里我们将其数学推导一起回顾一遍。</p>
<p>令z是softmax层的输入，f(z)是softmax的输出，则</p>
<h2 id="softmax的瓶颈"><a href="#softmax的瓶颈" class="headerlink" title="softmax的瓶颈"></a>softmax的瓶颈</h2><p>softmax需要计算<strong>每个类别的score</strong>，并且归一化为概率p。<br>当类别特别多（比如大词表）的情况下，计算量超大。</p>
<ul>
<li>参数量=计算量=$n \times V$</li>
<li>复杂度$O(n^2)$</li>
</ul>
<!--
requires computing scores for every word in
the vocabulary and to normalize them to form a probability
distribution.
-->

<p>对于大词表V</p>
<p>softmax的瓶颈常见于语言模型的巨量词汇、</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><h3 id="对损失函数的近似方法"><a href="#对损失函数的近似方法" class="headerlink" title="对损失函数的近似方法"></a>对损失函数的近似方法</h3><!--
Loss function approximation.
-->

<ul>
<li><strong>HSM: Hierarchical Softmax</strong>: 用两层的树((Goodman, 2001a; Mikolov<br>et al., 2011c)，或者更深层的结构（）<ul>
<li>word2vec, faxtText,</li>
</ul>
</li>
<li><strong>NCE</strong>:</li>
<li><strong>重要性采样</strong></li>
<li><strong>class-based softmax</strong>:</li>
<li><strong>adaptive softmax</strong>: 对class-based softmax的改进，针对GPU的加速</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>Large-Margin Softmax Loss</li>
<li>weighted softmax loss</li>
<li>soft softmax loss</li>
<li>angular softmax loss</li>
<li>L2-constrained softmax loss</li>
<li>additive margin softmax loss</li>
</ul>
<h3 id="基于采样的近似方法"><a href="#基于采样的近似方法" class="headerlink" title="基于采样的近似方法"></a>基于采样的近似方法</h3><!--
Sampling based approximation
-->


<h3 id="基于"><a href="#基于" class="headerlink" title="基于"></a>基于</h3><!--
Self-normalized approaches.
-->


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>简单的trick</li>
</ol>
<p>[batch_size, seq_length, hidden_size] * [hidden_size, vocab_size] 这样的操作，可以reshape成</p>
<p>[batch_size * seq_length, hidden_size] * [hidden_size, vocab_size] 的操作。即真个sequence一起算softmax。</p>
<p>但是有些decode中，上一时刻的output作为下一时刻的输入，就没办法这样算了。</p>
<h2 id="对loss-function的优化-近似（Loss-function-approximation）"><a href="#对loss-function的优化-近似（Loss-function-approximation）" class="headerlink" title="对loss-function的优化/近似（Loss function approximation）"></a>对loss-function的优化/近似（Loss function approximation）</h2><ul>
<li>HSM: hierarchical softmax</li>
</ul>
<p>树结构是一般基于frequency binning或者word similarities</p>
<p>hierarchical softmax是很多层二分类，在GPU上效率并不高。<br>假如，浅层的多分类，每层没必要是两个类。单层矩阵运算更容易用GPU加速<br>层数少了，在GPU上速度提升了，(当然如果是cpu，速度会更慢)</p>
<h2 id="基于采样的优化-近似-Sampling-based-approximation"><a href="#基于采样的优化-近似-Sampling-based-approximation" class="headerlink" title="基于采样的优化/近似 (Sampling based approximation)"></a>基于采样的优化/近似 (Sampling based approximation)</h2><p>importance sampling</p>
<p>不同的采样策略：</p>
<ul>
<li>unigram</li>
<li>bigram</li>
<li>power-raised distribution of the unigram</li>
</ul>
<h2 id="Self-normalized-approaches"><a href="#Self-normalized-approaches" class="headerlink" title="Self-normalized approaches"></a>Self-normalized approaches</h2><h2 id="class-based-softmax"><a href="#class-based-softmax" class="headerlink" title="class based softmax"></a>class based softmax</h2><p>Classes for fast maximum entropy training. Joshua Goodman, 2001</p>
<p>We  assign  each  word  in  the<br>vocabulary to a unique class. 比如，猫、狗属于动物类，周二、周三属于工作日。</p>
<p><strong>FAQ</strong></p>
<ul>
<li>类之间有没有word overlap？没有，这样能减小计算量。(HS的二叉树也)</li>
<li>有没有大类小类？多层类？没有</li>
<li>class与word的对应关系是怎样得到的？ 由用户自定义，自定义的方法有：<ul>
<li>按语义分类：猫、狗属于动物类，周二、周三属于工作日。</li>
<li>按词频分类：首先词频排序，然后分块作为class</li>
</ul>
</li>
</ul>
<h2 id="adaptive-softmax"><a href="#adaptive-softmax" class="headerlink" title="adaptive softmax"></a>adaptive softmax</h2><p>Facebook 人工智能研究（FAIR）设计出一种新式的 softmax 函数逼近，专用于 GPUs，帮助其在语言模型的基础上通过巨量词汇来有效训练神经网络。</p>
<p>这种方法叫做自适应 softmax（adaptive softmax），<strong>利用不平衡词分布形成簇（cluster），这种簇能明确地减少对计算复杂度的期望</strong>，从而<strong>规避对词汇量的线性依赖</strong>。这种方法通过利用流行架构的特殊性和矩阵-矩阵向量运算（matrix-matrix vector operations）进一步减少了训练和测试时的计算成本。这使得它特别适合于 GPU，而以往的方法，如分层 softmax，NCE 和重要性采样，都是为标准的 CPU 设计的。</p>
<p>有点类似HS和重要性采样吧？词频高的</p>
<p><strong>FAQ</strong></p>
<ul>
<li>adaptive softmax为什么能加速？</li>
<li>为什么要这样分cluster？</li>
</ul>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><h2 id="NCE"><a href="#NCE" class="headerlink" title="NCE"></a>NCE</h2><p>negative sampling。这种只针对training吧？inference怎样sampling呢？</p>
<p>(CPU上会更低效)</p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a>关于名称</h2><ul>
<li>softmax直接来看是一个归一化方法，loss的形式和是不是概率是不是softmax形式是没有必然联系的。当然它们现在的形式都是可以从entropy延伸出来，但是换一个新的loss，softmax也可以照用，或者不用softmax归一化，这个loss也一样可以继续用于优化。我觉得还是叫entropy loss比较好。</li>
<li>全称是softmax cross entropy loss，但这个实在是太长了</li>
<li>没什么全称的吧，好多地方都叫得不一样，就叫entropy loss最好了，既简洁又准确，这个loss就是entropy的形式</li>
<li>这个损失函数的核心是softmax函数，用softmax得到概率才能用cross entropy，得到概率的方式也有很多，比如sigmoid后l1归一化。</li>
<li>caffe里除了softmax cross entropy，还有sigmoid cross entropy。</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>tensor2tensor:</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>维基百科写的很好，很多篇幅摘自维基百科</li>
<li><a href="">efficient softmax approximation for GPUs</a>  综述归纳的很好</li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDA0NDYzNA==">一文道尽softmax loss及其变种<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1bm5pZV95aS9hcnRpY2xlL2RldGFpbHMvODAxMjgwMjQ=">漫谈词向量之基于Softmax与Sampling的方法 | 待看<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>trick</category>
      </categories>
  </entry>
  <entry>
    <title>google云主机---GCE</title>
    <url>/pub/3329d7fc/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2ZyZWUvP2hsPXpoLWNu">GCP 免费方案<i class="fa fa-external-link-alt"></i></span><br>送您 $300 赠金和 12 个月免费试用期，帮助您顺利上手。更有“始终免费”*产品助您一路前行。<br>*随时可能更改<br><img src="https://user-images.githubusercontent.com/13825126/35475026-57ca6be4-03d2-11e8-9551-9af4410e254b.PNG" alt="default"></p>
<p>只要绑定信用卡就送300刀，能免费用一年<br><image src="https://user-images.githubusercontent.com/13825126/35471148-9fda0c4c-0390-11e8-8167-6484aac58ab5.PNG" /></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLmdvb2dsZS5jb20vP2hsPXpoLWNu">GCP控制台<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="开通"><a href="#开通" class="headerlink" title="开通"></a>开通</h3><p>google云只支持以下几种信用卡。不支持中国银联<br>2: masterCard<br>3: 美国运通或JCB<br>4:: visa<br>5:mastercard</p>
<p>开通后，消费1美元，是什么意思？ (先消费1美元，再撤销1美元)</p>
<h3 id="价格-amp-配置"><a href="#价格-amp-配置" class="headerlink" title="价格&amp; 配置"></a>价格&amp; 配置</h3><p><strong>综述</strong>：GCE是主机部分按时间计费的，网络部分是按流量计费的，跟AWZ一样<br>（与cpu和内存使用率无关，那就可劲用吧）<br>(时间是使用时间，还是申请时间？关机算时间吗？关机不收费，那可以多开几个vm)<br>(流量是怎么算？下载conda，软件包也算流量？)</p>
<p>GCE 的价格比较亲民，最低配 1 共享核-0.6 GB 内存-10GB HDD 每月只需要不到 5 美元，而且由于 CPU、内存大小和磁盘大小都是可调的，所以可以根据自己的需要去购买最适合的，能省去不必要的开销。</p>
<table>
<thead>
<tr>
<th>GCE服务内容</th>
<th>估算费用</th>
<th>折扣</th>
<th>总计</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1 个共享 vCPU + 0.6 GB 内存</td>
<td>$5.55/月</td>
<td>- $1.66/月</td>
<td>$4.28/月</td>
<td>内存小了点</td>
</tr>
<tr>
<td>1 个共享 vCPU + 1.7 GB 内存</td>
<td>$19.71/月</td>
<td>- $5.91/月</td>
<td>$14.20/月</td>
<td></td>
</tr>
<tr>
<td>1 个 vCPU + 3.75 GB 内存</td>
<td>$34.67/月</td>
<td>- $10.40/月</td>
<td>$24.67/月</td>
<td></td>
</tr>
<tr>
<td>2 个 vCPU + 7.5 GB 内存</td>
<td>$69.35/月</td>
<td>- $20.81/月</td>
<td>$48.95/月</td>
<td></td>
</tr>
<tr>
<td>..</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10 GB 标准永久性磁盘</td>
<td>$0.40/月</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1 个 GPU NVIDIA Tesla K80</td>
<td>$328.50/月</td>
<td>- $108.95/月</td>
<td>$254.62/月</td>
<td>1. 共享 vCPU 不支持 GPU</td>
</tr>
<tr>
<td>1 个 GPU NVIDIA Tesla P100</td>
<td>$1,065.80/月</td>
<td>- $330.14/月</td>
<td>$770.73/月</td>
<td>2. 简直敲诈，不如自己买。另外仅特定区域才有GPU支持</td>
</tr>
</tbody></table>
<p>不同地区价格有差异，<strong>美国服务器价格最便宜</strong>，亚洲欧洲比美国本土贵点。</p>
<p><strong>可用性策略</strong></p>
<ul>
<li>抢占：该模式能够获得更低廉的价格，但是不能用做需要长期保持在线的服务（比如 Web 服务），它最长的使用期限是 24 小时，然而在我的使用中，它有时候不到 1 小时就会被终止使用。它只适合短时间去计算一些东西，计算完后中止它，平常的一般使用不要开启此功能。</li>
<li>自动重启：推荐开启，以获得在云端的好处，以及更好的 Uptime</li>
<li>主机维护期间：推荐选择 “迁移”，原因同上</li>
<li>IP 转发：建议关闭，几乎不会用得着此功能，关闭有助于提高安全性</li>
<li>SSH：这可能不同于其他一些 VPS，它默认不自动生成用户密码，所以为了远程登录必须配置好公钥私钥。而且所填写的公钥末尾的用户名是有作用的，所填写的用户名就是所需要登录的用户名，默认不支持 root 登陆，除非你将用户名设置成了 root。</li>
</ul>
<p><strong>流量</strong><br>流量的话对于所有的可用区，连中国大陆 $0.23/Gbyte、美欧地区 $0.12/Gbyte，流量的价格有些小贵，但是如果是连接 Google 自己的服务的话（包括但不限于 Gmail、YouTube），流量不计费（但是流量是双向的，所以是本地通过 GCE 上传完全免费，下载还是原价）。<br>流量另算钱，起步50g，因此最低配只要不超流量就可以用上一年。</p>
<p>GCE 还有一点比较特殊的是它是按分钟计费的，当服务处于终止状态（相当于关机，磁盘数据保留）时，不收取费用（除了少量的磁盘使用费用）。每次计算 Uptime 时，如果不到 10 分钟则一律按十分钟算，超过 10 分钟后才是真正的按分钟计费，不过还是很划算了</p>
<h2 id="ssh-登录"><a href="#ssh-登录" class="headerlink" title="ssh 登录"></a>ssh 登录</h2><p><strong>首先在浏览器窗口中打开ssh</strong></p>
<p><img src="https://user-images.githubusercontent.com/13825126/35474073-05e92d82-03c4-11e8-8db5-3fe45a631a50.PNG" alt="default"></p>
<ol>
<li>创建实例后设置当前用户的新密码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo passwd $&#123;whoami&#125; // 下面以 user 代替 $&#123;whoami&#125;</span><br><span class="line"># 输入新密码</span><br></pre></td></tr></table></figure>

<p>设置下 root 的新密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo passwd root</span><br><span class="line"># 输入新密码</span><br></pre></td></tr></table></figure>
<p><strong>在本地生成私钥和公钥</strong></p>
<p><strong>复制公钥</strong></p>
<p><strong>导入公钥到google VM</strong><br>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入谷歌云平台页面 -&gt; 计算引擎 -&gt; 元数据 -&gt; SSH 密钥，粘贴保存</span><br><span class="line"> 谷歌就会把上面这段 public key 写入到 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>cat ~/.ssh/authorized_keys文件，检查是否已经存在了刚刚的公钥</p>
<p>如果不work。就手动生成这个文件，然后拷贝public key</p>
<p><strong>本地通过 SSH 密码验证登录</strong></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>VPS</strong></p>
<p><strong>代理</strong></p>
<p><strong>web应用主机</strong></p>
<h3 id="GCE-云主机"><a href="#GCE-云主机" class="headerlink" title="GCE 云主机"></a>GCE 云主机</h3><p>google computer engine</p>
<p>Compute Engine 可让您使用在 Google 基础架构上运行的虚拟机。从微型 VM 到运行 Debian、Windows 或其他标准映像的大型虚拟机一应俱全。创建您的第一个 VM 实例并通过 CloudEndure 迁移服务导入该实例，或通过快速入门指南构建示例应用。</p>
<p>据说GCE 在国内经常不稳定</p>
<p>GCE 的后台配置页面虽不能在中国访问，但是其 GCE 实例是可以在中国访问的。(什么意思？)</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>速度超快，下载tensorflow 116MB/s</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ndW96ZXl1LmNvbS8yMDE2LzEwL2FzaWEtZ29vZ2xlLWNvbXB1dGUtZW5naW5lLw==">https://guozeyu.com/2016/10/asia-google-compute-engine/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81N2U4NWNmM2U1MGI=">SSH 连接配置<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="app-engine-云应用"><a href="#app-engine-云应用" class="headerlink" title="app engine 云应用"></a>app engine 云应用</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLmdvb2dsZS5jb20vaG9tZS9kYXNoYm9hcmQ=">谷歌云平台<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>cloud</category>
        <category>google</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>google</tag>
        <tag>GPU</tag>
        <tag>computer engine</tag>
      </tags>
  </entry>
  <entry>
    <title>【反爬虫系列】代理IP</title>
    <url>/pub/64cff6f7/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>市面上的免费代理IP种类繁多，很多品牌被吹嘘得天花乱坠，让用户在挑选时不知道该如何下手。<br>其实对于大部分用户来说，选择一款服务器稳定的代理IP资源是十分明智的，而对于免费代理IP来说，稳定性恰恰是它们的通用诟病，<br>你需要花费大量的时间精力来筛选可用IP资源，</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="免费IP"><a href="#免费IP" class="headerlink" title="免费IP"></a>免费IP</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2poYW8xMDQvcHJveHlfcG9vbA==">https://github.com/jhao104/proxy_pool<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="收费IP"><a href="#收费IP" class="headerlink" title="收费IP"></a>收费IP</h2><table>
<thead>
<tr>
<th>供应商</th>
<th>节点来源</th>
<th>协议支持</th>
<th>线路类型</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5kYWlsaXl1bi5jb20v">代理云<i class="fa fa-external-link-alt"></i></span></td>
<td>宽带拨号</td>
<td>Http/Https/Socks4 5</td>
<td>电信、联通、移动</td>
<td>最低5000IP/日（起售），最高可满足10万IP/日</td>
</tr>
<tr>
<td>[太阳HTTP]</td>
<td></td>
<td>Http/Https/Socks5</td>
<td></td>
<td>每日免费领20个IP。公司给买的每天300个IP，估计是最低套餐</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><ul>
<li>HTTP代理IP从成本上区分有免费版和付费版两种，免费IP获取方便，在百度搜索关键词就可以得到大量资源，<br>缺点是免费IP服务器存在不安全因素，用户的访问信息有可能会被记录，<br>造成个人隐私泄漏，无法保障使用者的安全性。由于代理IP传输的特殊性，甚至还可能掉进一些伪造的钓鱼网站，带来不必要的麻烦。</li>
</ul>
<p>分布式高质量代理IP变成了爬虫业的刚需，通过接入代理云平台，直接进行多线程操作</p>
<p>代理云为爬虫提供分布式代理IP解决方案</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>代理IP速度慢的原因有很多，<br>原因一，代理IP服务器所处网络速度不佳；<br>原因二，代理IP服务器性能差；<br>原因三，代理IP服务器传输距离远；<br>原因四，目标站点速度不稳定；<br>原因五，用户电脑配置差；原因六，用户网速慢。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>网络分层</title>
    <url>/pub/5e6131fb/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table border="1" cellpadding="1" cellspacing="1" ><thead><tr><th scope="row">&nbsp;</th><th scope="col">数据单元/格式</th><th scope="col">TCP/IP层</th><th scope="col">OSI层</th><th scope="col">功能</th><th scope="col">TCP/IP协议族</th><th scope="col">典型设备</th></tr></thead><tbody><tr><th colspan="1" rowspan="4" scope="row">主机层</th><td colspan="1" rowspan="3">Dagta(数据)</td><td colspan="1" rowspan="3">应用层</td><td>7. 应用层</td><td>网络进程到应用程序。针对特定应用规定各层协议、时序、表示等，进行封装。在端系统中用软件来实现，如HTTP等</td><td>DHCP、Telnet、FTP、HTTP、SNMP、DNS</td><td>网关</td></tr><tr><td>6. 表示层</td><td>数据表示形式，加密和解密，把机器相关的数据转换成独立于机器的数据。规定数据的格式化表示，数据格式的转换等</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>5. 会话层</td><td>主机间通讯，管理应用程序之间的会话。规定通信时序；数据交换的定界、同步，创建检查点等</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Segments(数据段)</td><td>传输层</td><td>4. 传输层</td><td>在网络的各个节点之间可靠的分发数据包。所有传输遗留问题；复用；流量控制；可靠</td><td>TCP UDP TLS/SSL</td><td>&nbsp;</td></tr><tr><th colspan="1" rowspan="3" scope="row">媒介层</th><td>&nbsp;</td><td>网络层 Internet</td><td>3. 网络层</td><td>负责IP地址。在网络的各个节点之间进行地址分配、路由和(不一定可靠的)分发报文。路由(IP寻址)；拥塞控制分割和重新组合数据包</td><td>IP ICMP BGP RIP</td><td>路由器</td></tr><tr><td>Bit/Frame数据帧</td><td colspan="1" rowspan="2">链路层</td><td>2. 数据链路层</td><td>负责MAC地址。一个可靠的点对点数据直链。检错与纠错(CRC码)；多路访问；寻址</td><td>WiFi ARP</td><td>交换机、网桥、网卡</td></tr><tr><td>Bit 比特流</td><td>1.物理层</td><td>一个(不一定可靠的)点对点数据直链。定义机械特性；电气特性；功能特性；过程特性</td><td>&nbsp;</td><td>调制解调器、中继器、集线器、同轴电缆、双绞线</td></tr></tbody></table>






<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuZXRfcHJvdG9jb2xfc3VpdGU=">https://en.wikipedia.org/wiki/Internet_protocol_suite<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm92ZWxsLmNvbS9kb2N1bWVudGF0aW9uL253NjUvbnR3a19pcHY0X253L2RhdGEvaGJudXVidHQuaHRtbA==">Overview of TCP/IP Protocol<i class="fa fa-external-link-alt"></i></span><br><image src="/images/raw/TCP%20IP%20-%204LayerModel%20-%20novell.com.gif"></p>
<h2 id="Architectural-Overview-of-the-TCP-IP-Protocol-Suite"><a href="#Architectural-Overview-of-the-TCP-IP-Protocol-Suite" class="headerlink" title="Architectural Overview of the TCP/IP Protocol Suite"></a><span class="exturl" data-url="aHR0cHM6Ly90ZWNobmV0Lm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9iYjcyNjk5My5hc3B4">Architectural Overview of the TCP/IP Protocol Suite<i class="fa fa-external-link-alt"></i></span></h2><p><image src="/images/raw/TCP%20IP%20-%20architecture%20-%20Microsoft.gif
"></p>
<h2 id="Overview-of-TCP-IP-protocols-摘自《Unix网络编程-chapter2》"><a href="#Overview-of-TCP-IP-protocols-摘自《Unix网络编程-chapter2》" class="headerlink" title="Overview of TCP/IP protocols,摘自《Unix网络编程 chapter2》"></a>Overview of TCP/IP protocols,摘自《Unix网络编程 chapter2》</h2><image src="/images/raw/TCP%20IP%20-%20overview%20-%20unix%20network%20programing.gif">

<h2 id="七层-应用层"><a href="#七层-应用层" class="headerlink" title="七层 应用层"></a>七层 应用层</h2><p>应用层（Application Layer）提供为应用软件而设的界面，以设置与另一应用软件之间的通信。<br>针对某个特定的用户应用程序（FTP、Telnet等）<br>比如</p>
<ul>
<li>HTTP Client与HTTP Server通信。</li>
<li>DNS client与DNS Server通信。</li>
</ul>
<h2 id="六层-表示层"><a href="#六层-表示层" class="headerlink" title="六层 表示层"></a>六层 表示层</h2><p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<h2 id="五层-会话层"><a href="#五层-会话层" class="headerlink" title="五层 会话层"></a>五层 会话层</h2><p>会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p>
<h2 id="四层-传输层"><a href="#四层-传输层" class="headerlink" title="四层 传输层"></a>四层 传输层</h2><p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>
<p>TCP使用不可靠的IP服务，但是它提供一种可靠的运输层服务；UDP为应用程序接收和发送数据报。但是UDP是不可靠的，它不保证数据报能安全无误的到达目的地。</p>
<h2 id="三层-网络层"><a href="#三层-网络层" class="headerlink" title="三层 网络层"></a>三层 网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将解封数据链路层收到的帧，提取数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。</p>
<p>IP是网际层的主要协议，同时被TCP和UDP使用；ICMP是IP的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要的信息；IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p>
<p>数据的路径选择(分组的<code>选路</code>)、转发，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>路由器<code>根据IP地址进行寻址</code>，通过路由表路由协议产生</p>
<p>对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信。</p>
<h3 id="路由-转发"><a href="#路由-转发" class="headerlink" title="路由/转发"></a>路由/转发</h3><p>在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</p>
<p>数据包的转发，<code>不在同一个局域网</code>，他们彼此之间是不认识的，那么就不得不通过其他媒介，寻找到适当的方式才可以传输数据。</p>
<h2 id="二层-链路层"><a href="#二层-链路层" class="headerlink" title="二层 链路层"></a>二层 链路层</h2><p>二层<code>交换</code>，只能解决<code>同一个局域网</code>(彼此认识，mac地址)内的数据交换。</p>
<p><code>物理地址寻址</code>、数据的成帧、流量控制、数据的检错、重发等</p>
<p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p>
<p>设备驱动程序及接口卡</p>
<p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p>
<p>交换机<code>根据MAC地址寻址</code>，通过站表选择路由，站表的建立和维护由交换机自动进行</p>
<h2 id="一层-物理层"><a href="#一层-物理层" class="headerlink" title="一层 物理层"></a>一层 物理层</h2><p>物理层（Physical Layer）在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p><strong>为什么要平行层通信？</strong><br>因为其它层看不懂该协议。(其他协议看不懂)</p>
<p>我觉得，也可以理解成相邻层之间的协议。比如</p>
<p>web中的后台与前台协定的数据格式，是不同层之间的协议。因为后台数据是给前台用的，前台http。</p>
<p>网络协议中，相邻层之间的</p>
<p><strong>VPN算在哪个层？算网路协议吗？</strong><br>按道理应该算协议，客户端和服务端都要遵守的约定。应该算在应用层吧。–by xs</p>
<p>vpn在IP层工作，而ss在TCP层工作</p>
<p><strong>proxy</strong>算在哪个层？<br>应用层吧，至少socket之上</p>
<p><strong>html5提出的websocket协议</strong><br>属于应用层</p>
<h2 id="待看-其他参考"><a href="#待看-其他参考" class="headerlink" title="待看/其他参考"></a>待看/其他参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT1NJJUU2JUE4JUExJUU1JTlFJThC">OSI-7层模型-wiki<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJEJTkxJUU3JUJCJTlDJUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">网络传输协议-四层模型-wiki<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM4NTE3MDQw">所有的网络请求底层协议是不是都是TCP/IP？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91cGxvYWRmaWxlcy5ub3djb2Rlci5uZXQvaW1hZ2VzLzIwMTcwODEwLzE3Njc3MjdfMTUwMjM2MjgzNjQ4MV8xQ0ZFQzAwNkIyOUNCQUVBNkFGRUQyNkFCNDNEMTZBNw==">ss<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>python c java 的变量、堆、栈</title>
    <url>/pub/ab933edd/</url>
    <content><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul>
<li><strong>栈</strong>: 是向<code>低地址扩展</code>的数据结构，是一块<code>连续的内存区域</code>。 栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M （也有的说是 1M ，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow 。因此，能从栈获得的空间较小。<ul>
<li>由系统自动分配，速度较快。但程序员是无法控制的</li>
</ul>
</li>
<li><strong>堆</strong>：是向<code>高地址扩展</code>的数据结构，是<code>不连续的内存区域</code>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<ul>
<li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片 , 不过用起来最方便 。</li>
</ul>
</li>
<li>变量</li>
<li>二进制存储，数值在内存中的表示</li>
<li></li>
</ul>
<h1 id="many-languages-have-“variables”"><a href="#many-languages-have-“variables”" class="headerlink" title="many languages have “variables”"></a>many languages have “variables”</h1><p>计算机内存就像是很多盒子的集合体，每个盒子都有地址。<br>在很多语言中，给变量赋值可以理解成把value放入盒子，比如：</p>
<table width="auto !important" border="1"><colgroup><col width="120"><col width="120"></colgroup><tbody><tr><td><code>int a = 1;</code></td><td><img src="/images/raw/Language - Python - a1box.png"></td></tr></tbody></table>




<table width="auto !important" border="1"><colgroup><col width="120"><col width="120"></colgroup><tbody><tr><td><code>a = 2;</code></td><td><img src="/images/raw/Language - Python - a2box.png"></td></tr></tbody></table>

<p>只是替换了盒子里的内容。</p>
<table width="auto !important" border="1"><colgroup><col width="120"><col width="120"><col width="120"></colgroup><tbody><tr><td><code>int b = a;</code></td><td><img src="/images/raw/Language - Python - b2box.png"></td><td><img src="/images/raw/Language - Python - a2box.png"></td></tr></tbody></table>

<h1 id="C-面向过程"><a href="#C-面向过程" class="headerlink" title="C - 面向过程"></a>C - 面向过程</h1><iframe width="800" height="350" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=int%20main%28%29%20%7B%0A%20%20int%20a%20%3D%201%3B%0A%20%20a%20%3D%202%3B%0A%20%20int%20balance%5B%5D%20%3D%20%7B1,%202,%203%7D%3B%0A%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=3&origin=opt-frontend.js&py=cpp&rawInputLstJSON=%5B%5D"> </iframe>


<!-- 1. 编译器， 从静态存储区域分配内存，包括全局变量， static 变量等 -->
<ol>
<li>运行时，首先系统为整个<code>函数栈</code>预分配空间(一块连续的内存区域)，栈上存储该函数的<code>局部变量</code>。即变量<code>a</code>对应固定的盒子(地址)。</li>
<li>执行 <code>int a = 1</code> 即把数值<code>1</code>放入<code>a</code>对应的盒子</li>
<li>执行 <code>a = 2</code> 替换了<code>a</code>盒子里的内容</li>
</ol>
<h1 id="C-半面向对象"><a href="#C-半面向对象" class="headerlink" title="C++ - 半面向对象"></a>C++ - 半面向对象</h1><h1 id="Java-不完全-面向对象"><a href="#Java-不完全-面向对象" class="headerlink" title="Java  不完全 面向对象"></a>Java  不完全 面向对象</h1><iframe width="800" height="700" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=public%20class%20Variables%20%7B%0A%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%20%20%20%20%20%20%0A%20%20%20%20%20%20//%20%E5%8F%98%E9%87%8F%20-%20%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%0A%20%20%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20%20%20int%20y%20%3D%2010%3B%0A%20%20%20%20%20%20int%20t%20%3D%20x%3B%0A%20%20%20%20%20%20x%20%3D%20y%3B%0A%20%20%20%20%20%20y%20%3D%20t%3B%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20//%20%E5%8F%98%E9%87%8F%20-%20%E5%AF%B9%E8%B1%A1%0A%20%20%20%20%20%20Integer%20p%20%3D%205%3B%0A%20%20%20%20%20%20Integer%20q%20%3D%201000%3B%0A%20%20%20%20%20%20Integer%20r%20%3D%20p%3B%0A%20%20%20%20%20%20p%20%3D%20q%3B%0A%20%20%20%20%20%20q%20%3D%20r%3B%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20//%20%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%0A%20%20%20%20%20%20Integer%20p2%20%3D%205%3B%0A%20%20%20%20%20%20Integer%20q2%20%3D%201000%3B%20//%20%E8%B6%85%E5%87%BA%E5%B8%B8%E9%87%8F%E6%B1%A0%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20String%20me%20%3D%20%22me%22%3B%0A%20%20%20%20%20%20String%20you%20%3D%20%22you%22%3B%0A%20%20%20%20%20%20String%20me2%20%3D%20%22me%22%3B%20//%20String%20%E5%B8%B8%E9%87%8F%0A%20%20%20%20%20%20%0A%20%20%20%7D%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=17&heapPrimitives=true&origin=opt-frontend.js&py=java&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>


<ol>
<li>Java中的原始类型 primitive type，与C语言类似，变量对应盒子</li>
<li>运行 <code>int a = 1</code>，存储在栈中</li>
<li>运行 <code>a = 2</code>，</li>
<li>class，与python类似，变量</li>
<li>运行 <code>Integer b = 1</code>，存储在栈中还是堆中？貌似有个Integer池，预分配好的。</li>
<li>运行 <code>Integer c = 1000</code>，会new 一个Integer Object，并存储在堆中</li>
</ol>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li>java不预分配函数栈空间吗？</li>
<li>java中为什么是frames和objects？为什么不是stack heap？</li>
<li>java中的原始类型，与class类型</li>
</ul>
<h1 id="python-面向对象"><a href="#python-面向对象" class="headerlink" title="python - 面向对象"></a>python - 面向对象</h1><div class="note info">
            <p>Other languages have “variables”, python has “names”.   — David Goodger</p>
          </div>

<iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=a%20%3D%201%0Aa%20%3D%202%0AmyList%20%3D%20%5B1,2,3%5D%0A&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=3&heapPrimitives=true&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>


<ol>
<li>python中一切皆对象，<code>a=1</code>，<code>a</code>是<code>PyIntObject</code>的对象，存储在堆中</li>
<li>python has “names”，指的是python的变量都是代号(盒子中存的是地址，而不是value)。</li>
<li><code>a=2</code>，是把<code>a</code>指向了对象<code>2</code></li>
<li></li>
</ol>
<h2 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li>python中是frame的概念，不是stack。why？</li>
</ul>
<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kYXZpZC5nb29kZ2VyLm9yZy9wcm9qZWN0cy9weWNvbi8yMDA3L2lkaW9tYXRpYy9oYW5kb3V0Lmh0bWw=">Code Like a Pythonista: Idiomatic Python | David Goodger<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3B5dGhvbnR1dG9yLmNvbS8=">http://pythontutor.com<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYmZzLndvcmRwcmVzcy5jb20vMjAxMS8wNi8xNC9weXRob24tcmVmZXJlbmNlcy12cy1jLWFuZC1jLw==">Python References vs C and C++<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
      </categories>
  </entry>
  <entry>
    <title>关于Monkey Patch猴子补丁</title>
    <url>/pub/7b5bc9fe/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以下是维基百科对猴子补丁的定义</p>
<blockquote>
<p>The term monkey patch refers to dynamic modifications of a class or module at runtime, motivated by the intent to patch existing third-party code as a workaround to a bug or feature which does not act as desired.</p>
</blockquote>
<!-- 在动态语言中， -->
<p>所谓的猴子补丁，是指在运行时修改类或模块，而不去改变源码，达到hot patch的目的。</p>
<p>猴补丁（英语：Monkey patch）是一种很脏的编程技巧，用拼凑代码的方法修改程序逻辑。</p>
<p>Monkey patching 只能在动态语言中实现。比如Python类的方法其实也只是一个属性，方便运行时修改，所以用Python做猴子补丁非常方便。</p>
<p>Changing a method at runtime instead of updating the object definition is one example。</p>
<h2 id="名字来源"><a href="#名字来源" class="headerlink" title="名字来源"></a>名字来源</h2><ol>
<li>这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。</li>
<li>还有一种解释是说由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。</li>
</ol>
<!-- Applications -->
<h1 id="示例-应用场景"><a href="#示例-应用场景" class="headerlink" title="示例/应用场景"></a>示例/应用场景</h1><p>维基百科总结了4种应用场景</p>
<ul>
<li>Replace methods / attributes / functions at runtime, e.g. to stub out a function during testing;</li>
<li>Modify/extend behaviour of a third-party product without maintaining a private copy of the source code;</li>
<li>Apply a patch at runtime to the objects in memory, instead of the source code on disk;</li>
<li>Distribute security or behavioural fixes that live alongside the original source code (an example of this would be distributing the fix as a plugin for the Ruby on Rails platform).</li>
</ul>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="对属性-打补丁"><a href="#对属性-打补丁" class="headerlink" title="对属性 打补丁"></a>对属性 打补丁</h3><p>以下来自wikpedia示例。<br>利用猴子补丁，动态修改math标准库中Pi的默认值。(这里仅修改了attributes，也可以对某些method进行重写)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi = <span class="number">3</span>  <span class="comment"># 给标准库打补丁，即运行时修改math的pi属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>================================ RESTART ================================</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>

<h3 id="对方法-打补丁"><a href="#对方法-打补丁" class="headerlink" title="对方法 打补丁"></a>对方法 打补丁</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Foo.bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self</span>):</span>  <span class="comment"># 这是补丁</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Modified bar&#x27;</span></span><br><span class="line"></span><br><span class="line">Foo().bar()</span><br><span class="line">Foo.bar = bar  <span class="comment"># 给Foo的bar方法打补丁，即运行时修改类的方法</span></span><br><span class="line">Foo().bar()</span><br></pre></td></tr></table></figure>
<p>由于Python中的名字空间是开放，通过dict来实现，所以很容易就可以达到patch的目的。</p>
<h2 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h2><h3 id="socket的热补丁"><a href="#socket的热补丁" class="headerlink" title="socket的热补丁"></a>socket的热补丁</h3><p>用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();把标准库中的thread/socket等给替换掉.这样我们在后面使用socket的时候可以跟平常一样使用,无需修改任何代码,但是它变成非阻塞的了.</p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>网页和数据库</p>
<h3 id="Zope、Plone中的安全补丁"><a href="#Zope、Plone中的安全补丁" class="headerlink" title="Zope、Plone中的安全补丁"></a>Zope、Plone中的安全补丁</h3><blockquote>
<p>In Zope and Plone, security patches are often delivered using dynamic class modification, but they are called hot fixes.<br>– wikipedia</p>
</blockquote>
<p>很多安全补丁也是一种猴子补丁，只不过叫法不同而已。</p>
<h3 id="Eventlet-Patcher"><a href="#Eventlet-Patcher" class="headerlink" title="Eventlet Patcher"></a>Eventlet Patcher</h3><p>现在我们先来看一下eventlet中的Patcher的调用代码吧，这段代码对标准的ftplib做monkey patch，将eventlet的GreenSocket替换标准的socket。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> eventlet <span class="keyword">import</span> patcher  </span><br><span class="line"><span class="comment"># *<span class="doctag">NOTE:</span> there might be some funny business with the &quot;SOCKS&quot; module  </span></span><br><span class="line"><span class="comment"># if it even still exists  </span></span><br><span class="line"><span class="keyword">from</span> eventlet.green <span class="keyword">import</span> socket  </span><br><span class="line">patcher.inject(<span class="string">&#x27;ftplib&#x27;</span>, <span class="built_in">globals</span>(), (<span class="string">&#x27;socket&#x27;</span>, socket))  </span><br><span class="line"><span class="keyword">del</span> patcher  </span><br></pre></td></tr></table></figure>

<p>Eventlet中大量使用了该技巧，以替换标准库中的组件，比如socket。</p>
<p>未完待续，参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlaXplZi9hcnRpY2xlL2RldGFpbHMvNTczMjY1Nw==">https://blog.csdn.net/seizef/article/details/5732657<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="从Gevent学习猴子补丁的设计"><a href="#从Gevent学习猴子补丁的设计" class="headerlink" title="从Gevent学习猴子补丁的设计"></a>从Gevent学习猴子补丁的设计</h3><p>异步协程工具Gevent是python上面最有名也支持面最广通用性最好的协程工具,它底层基于greenlet,而且可以通过使用猴子补丁将标准库中的同步模块自动的转换成异步.同时他也提供了方便的并发模型和常用的web服务器工具.</p>
<p>gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> socket</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(socket.socket)     <span class="comment"># monkey patch前</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">socket</span>.<span class="title">_socketobject</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">gevent</span> <span class="title">import</span> <span class="title">monkey</span> # <span class="title">monkey</span> <span class="title">patch</span>后</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_socket</span>()</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">socket.socket</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">gevent</span>.<span class="title">_socket2</span>.<span class="title">socket</span>&#x27;&gt;  # 改变了标准<span class="title">socket</span>库</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">select</span>        # <span class="title">monkey</span> <span class="title">patch</span>前</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">select.select</span>)  #  <span class="title">select</span>()轮询的阻塞调用</span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">function</span> <span class="title">select</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_select</span>() # <span class="title">monkey</span> <span class="title">patch</span>后</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">select.select</span>) # <span class="title">select</span>()轮询的异步调用</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">select</span> <span class="title">at</span> 0<span class="title">x7fb8a7239d70</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如，Redis的python绑定一般使用常规的tcp socket来与redis-server实例通信。 通过简单地调用gevent.monkey.patch_all()，可以使得redis的绑定协作式的调度 请求，与gevent栈的其它部分一起工作。</p>
<p>这让我们可以将一般不能与gevent共同工作的库结合起来，而不用写哪怕一行代码。 虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。</p>
<h3 id="patch-all"><a href="#patch-all" class="headerlink" title="patch_all"></a>patch_all</h3><p>除了socket外,gevent还可以为其他的模块打补丁,一起打补丁可以使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">patch_all(socket=<span class="literal">True</span>, dns=<span class="literal">True</span>, time=<span class="literal">True</span>, select=<span class="literal">True</span>, thread=<span class="literal">True</span>, os=<span class="literal">True</span>, ssl=<span class="literal">True</span>, httplib=<span class="literal">False</span>,subprocess=<span class="literal">True</span>, sys=<span class="literal">False</span>, aggressive=<span class="literal">True</span>, Event=<span class="literal">False</span>, builtins=<span class="literal">True</span>, signal=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>函数。</p>
<p>我们可以看到像<code>socket</code>,<code>dns</code>,<code>time</code>,<code>selectthread</code>,<code>os</code>, <code>ssl</code>, <code>httplib</code>,<code>subprocess</code>, <code>sys</code>, <code>aggressive</code>, <code>Event</code>, <code>builtins</code>, <code>signal</code>模块都可以打上补丁,打上以后,他们就是非阻塞的了.</p>
<h3 id="核心协程模块greenlet"><a href="#核心协程模块greenlet" class="headerlink" title="核心协程模块greenlet"></a>核心协程模块greenlet</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in foo&#x27;</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment"># 这行的作用是什么？</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Explicit context switch to foo again&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Explicit context to bar&#x27;</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment">#</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Implicit context switch back to bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Running <span class="keyword">in</span> foo</span><br><span class="line">Explicit context to bar</span><br><span class="line">Explicit context switch to foo again</span><br><span class="line">Implicit context switch back to bar</span><br><span class="line">[&lt;Greenlet at <span class="number">0x7fb8a72c3eb0</span>&gt;, &lt;Greenlet at <span class="number">0x7fb8a72c3a50</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>上述例子能看到，执行顺序是  <code>foo--&gt;bar--foo--bar</code>，来回切换。即gevent.sleep()并不会真正的阻塞整个线程，而是将cpu的控制权显式的交给未被gevent.sleep()阻塞的协程使用。</p>
<p>协程是单线程程序（从上述例子来讲），如果我们使用time.sleep()，那么整个线程都会被阻塞。</p>
<h3 id="gevent-sleep与time-sleep的区别"><a href="#gevent-sleep与time-sleep的区别" class="headerlink" title="gevent.sleep与time.sleep的区别"></a><code>gevent.sleep</code>与<code>time.sleep</code>的区别</h3><ul>
<li><p>gevent is a cooperative analog to the threading module. When using gevent.sleep it you would never use time.sleep.  So no example is needed.</p>
</li>
<li><p>time.sleep would suspend the entire process, blocking all greenlet threads. <span class="exturl" data-url="aHR0cHM6Ly9tYWlsLnB5dGhvbi5vcmcvcGlwZXJtYWlsL3B5dGhvbi1saXN0LzIwMTQtSnVseS82NzU3MjYuaHRtbA==">来源<i class="fa fa-external-link-alt"></i></span>。 以上说法针对的是协程(单线程程序)。而对于多线程，time.sleep仅仅阻塞当前线程，不阻塞其他线程，<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTI5MjgvdGltZS1zbGVlcC1zbGVlcHMtdGhyZWFkLW9yLXByb2Nlc3M=">来源<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldmVudC9nZXZlbnQvYmxvYi85NTdjNDdmODg5MGFlNGViNGYxZmQ4MzQ2NGM4ZTFkMTczYjdmN2RhL3NyYy9nZXZlbnQvbW9ua2V5LnB5I0w0OTE=">源码-patch_time<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldmVudC9nZXZlbnQvYmxvYi85NTdjNDdmODg5MGFlNGViNGYxZmQ4MzQ2NGM4ZTFkMTczYjdmN2RhL3NyYy9nZXZlbnQvbW9ua2V5LnB5I0wxMDc4">gevent/monkey.py<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="猴子补丁-与-SocketIO"><a href="#猴子补丁-与-SocketIO" class="headerlink" title="猴子补丁 与 SocketIO"></a>猴子补丁 与 SocketIO</h3><p>用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();把标准库中的thread/socket等给替换掉.这样我们在后面使用socket的时候可以跟平常一样使用,无需修改任何代码,但是它变成非阻塞的了.</p>
<p>我看到猴子补丁，是从Gevent中看到的。SocketIO服务器发送数据，浏览器端并非实时接收，而是批量接收 (跟过马路有点像，凑够一波发送一次)。</p>
<p>这里涉及到buffer和flush。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbGdyaW5iZXJnL0ZsYXNrLVNvY2tldElPL2lzc3Vlcy8xMDY=">https://github.com/miguelgrinberg/Flask-SocketIO/issues/106<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbGdyaW5iZXJnL0ZsYXNrLVNvY2tldElPL2lzc3Vlcy8xNDE=">https://github.com/miguelgrinberg/Flask-SocketIO/issues/141<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>没看懂的部分，后面再看。</p>
<blockquote>
<p> That is really the only way to make this work when you use gevent, threading is cooperative so you have to release the CPU so that other tasks associated with the server get a chance to run and flush the messages. Any chance you haven’t monkey patched the standard library?<br>— Flask-SocketIO的作者miguelgrinberg link</p>
</blockquote>
<p>这里说的意思是，<code>socketio.emit(message)</code> 默认会加缓存(buffer)。需要主动flush才能立即发送。而<code>gevent.sleep(</code>是flush的一种方式，因为它会  将cpu的控制权显式的交给未被gevent.sleep()阻塞的协程使用，切换之前会先flush一下。</p>
<p>socketio.emit默认会有个buffer（为了高效），为什么gevent.sleep会flush这个buffer？让我们重新梳理一下思路：</p>
<ol>
<li><code>gevent.sleep</code>会<code>释放cpu控制权</code>，即<code>切换协程</code>，从而不阻塞其他协程运行。 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldmVudC9nZXZlbnQvc2VhcmNoP3V0Zjg9JUUyJTlDJTkzJnE9c3dpdGNoJnR5cGU9">gevent切换协程的源码<i class="fa fa-external-link-alt"></i></span></li>
<li>gevent进行<code>协程切换</code>前，需要<code>flush当前协程</code>。 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldmVudC9nZXZlbnQvc2VhcmNoP3V0Zjg9JUUyJTlDJTkzJnE9Zmx1c2gmdHlwZT0=">gevent进行flush的源码<i class="fa fa-external-link-alt"></i></span></li>
<li><code>flush当前协程</code>导致socket.emit中的缓存立即发送</li>
</ol>
<h3 id="猴子补丁与-import-json"><a href="#猴子补丁与-import-json" class="headerlink" title="猴子补丁与 import json,"></a>猴子补丁与 import json,</h3><p>之前做的一个游戏服务器,很多地方用的import json,后来发现ujson比自带json快了N倍,于是问题来了,难道几十个文件要一个个把import json改成import ujson as json吗?<br>其实只需要在进程startup的地方monkey patch就行了.是影响整个进程空间的.<br>同一进程空间中一个module只会被运行一次.</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="猴子补丁是动态语言的专利么？"><a href="#猴子补丁是动态语言的专利么？" class="headerlink" title="猴子补丁是动态语言的专利么？"></a>猴子补丁是动态语言的专利么？</h2><p>使用猴子补丁的条件主要是可以打开类、可以重定义现有属性、方法。修改类方法的指针，或者属性</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>C++ 类有哪个方法是编译时确定好的, 没法打开类, 对象属于哪个类是 new 对象的代码确定好的, 既然 new 的代码在编译时确定了, 再载入补丁库也修改不了 (除非搞缓冲区溢出攻击…)</p>
<p>比如python中可以math.Pi=3。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>java强大的反射，即使<code>属性</code>或<code>方法</code>被设置为了<code>private final</code>也可以动态更改。讲道理也可以动态补丁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不是脚本语言的专利……是语言设计留不留口的问题？</p>
<h2 id="猴子补丁的坑"><a href="#猴子补丁的坑" class="headerlink" title="猴子补丁的坑"></a>猴子补丁的坑</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ua2V5X3BhdGNo">Monkey patch | wikipedia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyNjE5My93aGF0LWlzLW1vbmtleS1wYXRjaGluZw==">what-is-monkey-patching | StackOverflow<i class="fa fa-external-link-alt"></i></span></li>
<li>待看 《松本行弘的程序世界》专门有一章讲了猴子补丁的设计</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ydWJ5LWNoaW5hLm9yZy90b3BpY3MvMTc2MTk=">猴子补丁是动态语言的专利么？ | ruby-china<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuaHN6b2ZmaWNpYWwuc2l0ZS9UdXRvcmlhbEZvclB5dGhvbi8lRTUlODUlODMlRTclQkMlOTYlRTclQTglOEIvJUU3JThDJUI0JUU1JUFEJTkwJUU4JUExJUE1JUU0JUI4JTgxJUU1JTkyJThDJUU3JTgzJUFEJUU2JTlCJUI0JUU2JTk2JUIwLmh0bWw=">猴子补丁和热更新 | 网络博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
      </categories>
  </entry>
  <entry>
    <title>rsync 原理</title>
    <url>/pub/af0b984c/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>rsync是Unix下的一款应用软件，它能同步更新两处计算机的文件与目录，并适当<strong>利用差分编码以减少数据传输量</strong>。rsync中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync可以拷贝／显示目录内容，以及拷贝文件，并<strong>可选压缩</strong>以及递归拷贝。</p>
<p>在常驻模式（daemon mode）下，rsync默认监听TCP端口873，以原生rsync传输协议或者通过远程shell如RSH或者SSH提供文件。SSH模式下，rsync客户端运行程序必须同时在本地和远程机器上安装。</p>
<p>rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法<strong>只传送两个文件的不同部分</strong>，而不是每次都整份传送，因此速度相当快。</p>
<h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><ol>
<li>如何判断文件是否变更？</li>
<li>如何找到变更的部分？</li>
<li>对于二进制文件怎样处理？</li>
<li>对于大文件怎样处理？</li>
</ol>
<h1 id="rsync算法"><a href="#rsync算法" class="headerlink" title="rsync算法"></a>rsync算法</h1><ol>
<li>按固定大小将A分为多块，每块都计算出一个32位的滚动哈希值和一个128位的MD4（有些也用MD5），发给B一端。</li>
<li>B一端从位置0开始按的同样块大小的滚动哈希值，查找看是否命中A给的某个滚动哈希值，若匹配，则表明B文件中的这块内容与对应的A中的那块内容很可能是一致的，但由于32位的哈希值强度不够，因此再计算MD4，若还是匹配，则确认是一致内容，这时B发给A端匹配的段号。对于那些不能匹配的内容，则发给A端原始内容。</li>
<li>A端得到B端给的匹配信息，构造一个与B一致的复本，若是匹配的块，则拷贝原A文件中对应的块，若是不匹配内容则追加之。</li>
</ol>
<h2 id="分块Checksum算法"><a href="#分块Checksum算法" class="headerlink" title="分块Checksum算法"></a>分块Checksum算法</h2><p>首先，我们会把fileDst的文件平均切分成若干个小块，比如每块512个字节（最后一块会小于这个数），然后对每块计算两个checksum，</p>
<ul>
<li>一个叫rolling checksum，是弱checksum，32位的checksum，其使用的是Mark Adler发明的adler-32算法，</li>
<li>另一个是强checksum，128位的，以前用md4，现在用md5 hash算法。</li>
</ul>
<p>为什么要这样？因为若干年前的硬件上跑md4的算法太慢了，所以，我们需要一个快算法来鉴别文件块的不同，但是弱的adler32算法碰撞概率太高了，所以我们还要引入强的checksum算法以保证两文件块是相同的。也就是说，弱的checksum是用来区别不同，而强的是用来确认相同。（checksum的具体公式可以参看这篇文章）</p>
<h2 id="传输算法"><a href="#传输算法" class="headerlink" title="传输算法"></a>传输算法</h2><p>同步目标端会把fileDst的一个checksum列表传给同步源，这个列表里包括了三个东西，rolling checksum(32bits)，md5 checksume(128bits)，文件块编号。</p>
<p>我估计你猜到了同步源机器拿到了这个列表后，会对fileSrc做同样的checksum，然后和fileDst的checksum做对比，这样就知道哪些文件块改变了。</p>
<p>但是，聪明的你一定会有以下两个疑问：</p>
<p>如果我fileSrc这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和fileDst这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？<br>如果这个checksum列表特别长，而我的两边的相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？<br>很好，让我们来看一下同步源端的算法。</p>
<h2 id="checksum查找算法"><a href="#checksum查找算法" class="headerlink" title="checksum查找算法"></a>checksum查找算法</h2><h2 id="比对算法"><a href="#比对算法" class="headerlink" title="比对算法"></a>比对算法</h2><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h1 id="基于rsync的应用"><a href="#基于rsync的应用" class="headerlink" title="基于rsync的应用"></a>基于rsync的应用</h1><ul>
<li>Rclone</li>
<li>Back In Time</li>
</ul>
<p>…</p>
<p>都没听过</p>
<h1 id="基于rsync的改进算法"><a href="#基于rsync的改进算法" class="headerlink" title="基于rsync的改进算法"></a>基于rsync的改进算法</h1><p>基于rsync的改进算法主要有多轮rsync和本地rsync两个。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUnN5bmM=">维基百科<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvNzQyNS5odG1s">RSYNC 的核心算法 | 酷壳<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3dhbmd5dWFuemp1LmJsb2cuMTYzLmNvbS9ibG9nL3N0YXRpYy8xMzAyOTIwMTAxMDEyNTI2MzI5OTgv">Dropbox差异同步算法rsync及其改进算法原理  <i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
      </categories>
      <tags>
        <tag>checksum</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>开源密码管理工具对比</title>
    <url>/pub/74ac13e4/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th></th>
<th>KeepPass</th>
<th>KeepPassX</th>
<th>LessPass</th>
<th>clipperz</th>
<th>Encryptr</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td></td>
<td>keepass的山寨版，很弱</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>github-fork</td>
<td>代码由sourceforget-svn托管。老顽固拒绝github</td>
<td>535</td>
<td>106</td>
<td>121</td>
<td>121</td>
<td>submoduel的contributor是否算在主仓库中？</td>
</tr>
<tr>
<td>github-star</td>
<td></td>
<td>3613</td>
<td>2618</td>
<td>569</td>
<td>1480</td>
<td></td>
</tr>
<tr>
<td>github-contributor</td>
<td></td>
<td>29</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>github近期更新</td>
<td>☆</td>
<td>☆☆</td>
<td>☆☆☆</td>
<td>☆☆</td>
<td>☆☆</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>主仓库</td>
<td></td>
<td>主仓库即所有代码，C++ Qt客户端</td>
<td>shell</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>backend</td>
<td></td>
<td></td>
<td>python-django</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>frontend</td>
<td></td>
<td></td>
<td>vuejs + html</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cli</td>
<td></td>
<td></td>
<td>nodejs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>desktop</td>
<td></td>
<td></td>
<td>node + js 编译成windos、linux、max客户端</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>webextension</td>
<td></td>
<td>无</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>移动客户端</td>
<td></td>
<td>由第三方提供，并非开源。种类繁多，良莠不齐</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>同步</td>
<td></td>
<td>借助dropbox等第三方</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>主推功能</td>
<td></td>
<td></td>
<td>synchronize，多设备同步</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>模块化/组件化</td>
<td>也有很多plugin</td>
<td></td>
<td>基于nodejs，模块化很好</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>优点</td>
<td>比keepassx好用</td>
<td></td>
<td>1. C++看着吃力，python看着爽，nodejs也比较火 2. 多设备同步很重要3. 模块化很赞</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>老顽固拒绝github<br><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcC9rZWVwYXNzL2Rpc2N1c3Npb24vMzI5MjIxL3RocmVhZC85NzExMGMyOS8=">https://sourceforge.net/p/keepass/discussion/329221/thread/97110c29/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p> LastPass（最大的优势是跨浏览器平台</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>密码管理</category>
      </categories>
  </entry>
  <entry>
    <title>矢量图的制作</title>
    <url>/pub/ac890a3f/</url>
    <content><![CDATA[<h2 id="矢量图制作"><a href="#矢量图制作" class="headerlink" title="矢量图制作"></a>矢量图制作</h2><p>入门级(并不低级)：</p>
<ul>
<li>powerpoint: 首先group元素，然后save as png/emf。如需要svg，可再用Inkscape转化。</li>
<li>visio:</li>
<li>Inkscape 功能貌似很强大，但我用过它的格式转化功能。<span class="exturl" data-url="aHR0cHM6Ly9jb2xhaC5naXRodWIuaW8vcG9zdHMvMjAxNS0wOC1VbmRlcnN0YW5kaW5nLUxTVE1zLw==">实例图片<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>专业级：</p>
<ul>
<li>Adobe Illustrator</li>
<li>Corel Draw</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy50ZXhhbXBsZS5uZXQvdGlrei8=">TeX and PGF/TikZ<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01hcmtMb2RhdG8vdmlzdWFsLWdpdC1ndWlkZQ==">示例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>visio<br>iGrafx（流程图）</p>
<p>online工具:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3BpY3Jlc2l6ZS5jb20v">http://picresize.com/<i class="fa fa-external-link-alt"></i></span></li>
<li>Google Drawings  – web-based diagramming</li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29sLmx1L2Zhdmljb24v">https://tool.lu/favicon/<i class="fa fa-external-link-alt"></i></span>  16<em>16 32</em>32 转化</li>
</ul>
<h2 id="ico制作"><a href="#ico制作" class="headerlink" title="ico制作"></a>ico制作</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>绘图工具</category>
      </categories>
      <tags>
        <tag>矢量图</tag>
      </tags>
  </entry>
  <entry>
    <title>单页应用</title>
    <url>/pub/fd7a7791/</url>
    <content><![CDATA[<blockquote>
<p>单页应用（英语：single-page application，缩写SPA）是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非<code>传统的从服务器重新加载整个新页面</code>。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）<code>动态装载适当的资源并添加到页面</code>。尽管可以用位置散列或HTML5历史API来提供应用程序中单独逻辑页面的感知和导航能力，但页面在过程中的任何时间点都不会重新加载，也不会将控制转移到其他页面。[2]与单页应用的交互通常涉及到与网页服务器后端的动态通信。<br>– wikipedia</p>
</blockquote>
<p>就是基于ajax技术交互的动态页面呗。</p>
<blockquote>
<p>诸如AngularJS、Ember.js、Meteor.js、ExtJS和React等面向网页浏览器的JavaScript框架采纳了单页应用（SPA）原则。</p>
</blockquote>
<p>这句话怎么理解？这些框架是为了单页应用设计的？为什么这么说？</p>
<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>参考自掘金 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTBlYTRlYzZmYjlhMDQ1MDQwNzcyNWM=">https://juejin.im/post/5a0ea4ec6fb9a0450407725c<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th></th>
<th>单页面应用（SPA）</th>
<th>多页面应用（MPA）</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>一个外壳页面和多个页面片段组成</td>
<td>多个完整页面构成</td>
</tr>
<tr>
<td>资源共用(css,js)</td>
<td>共用，只需在外壳部分加载</td>
<td>不共用，每个页面都需要加载</td>
</tr>
<tr>
<td>刷新方式</td>
<td>页面局部刷新或更改</td>
<td>整页刷新</td>
</tr>
<tr>
<td>url 模式</td>
<td>a.com/#/pageone</td>
<td>a.com/pageone.html</td>
</tr>
<tr>
<td>用户体验</td>
<td>页面片段间的切换快，用户体验良好</td>
<td>页面切换加载缓慢，流畅度不够，用户体验比较差</td>
</tr>
<tr>
<td>转场动画</td>
<td>容易实现</td>
<td>无法实现</td>
</tr>
<tr>
<td>数据传递</td>
<td>容易</td>
<td>依赖 url传参、或者cookie 、localStorage等</td>
</tr>
<tr>
<td>搜索引擎优化(SEO)</td>
<td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td>
<td>实现方法简易</td>
</tr>
<tr>
<td>试用范围</td>
<td>高要求的体验度、追求界面流畅的应用</td>
<td>适用于追求高度支持搜索引擎的应用</td>
</tr>
<tr>
<td>开发成本</td>
<td>较高，常需借助专业的框架</td>
<td>较低 ，但页面重复代码多</td>
</tr>
<tr>
<td>维护成本</td>
<td>相对容易</td>
<td>相对复杂</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么SPA不利于SEO？<br>单页页面，数据在前端渲染。爬虫一般只抓取静态页面，不会调用js来动态生成新页面。</p>
<p>为什么SPA要首次加载大量资源？<br>前端渲染，肯定前端需要很多js。SPA一定要前端渲染吗，后端可以渲染好html部分元素返回前台吧？</p>
<p>SPA首次加载大量的静态资源，是前端渲染任务重造成的？</p>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>首屏渲染速度除了受js文件大小的影响，还有HTML的解析时机。为了提早加载完document，最好将没有用到的其他文件的下载往后推或者异步下载（不要让他阻塞document的加载）。这里给这些js文件添加了 defer属性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThEJTk1JUU5JUExJUI1JUU1JUJBJTk0JUU3JTk0JUE4">单页应用 | wikipedia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNzkyMDY0">单页应用有那些优缺点？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3RpbnlhbWJpdGlvbi5jb20vU2luZ2xlLVBhZ2UtQXBwLUJyZWFrLyVFNyVBQyVBQzAxJUU3JUFCJUEwJTIwJUU0JUJEJTk1JUU0JUI4JUJBJUU1JThEJTk1JUU5JUExJUI1JUU1JUJBJTk0JUU3JTk0JUE4Lmh0bWw=">单页应用开发基础<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>单页应用</tag>
        <tag>angular</tag>
        <tag>react</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>关于域名</title>
    <url>/pub/8dcc3c99/</url>
    <content><![CDATA[<h2 id="顶级域名比较"><a href="#顶级域名比较" class="headerlink" title="顶级域名比较"></a>顶级域名比较</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTkyJUU4JTgxJTk0JUU3JUJEJTkxJUU5JUExJUI2JUU3JUJBJUE3JUU1JTlGJTlGJUU1JTg4JTk3JUU4JUExJUE4">互联网顶级域列表<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>google页面数(million)</th>
<th>域名数目</th>
<th>域名饱和度</th>
<th>开放时间</th>
<th>价格</th>
<th>审核</th>
<th>星级</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>.com</td>
<td>原用于商业组织，现无限制</td>
<td>25,270</td>
<td>13290万</td>
<td>4字母的基本饱和</td>
<td>1985-01-01</td>
<td></td>
<td></td>
<td>☆☆☆☆☆</td>
<td></td>
</tr>
<tr>
<td>.net</td>
<td>原用于网络服务，现无限制</td>
<td>2,790</td>
<td>1437万</td>
<td>大批量4字母</td>
<td>1985-01-01</td>
<td></td>
<td></td>
<td>☆☆☆☆</td>
<td></td>
</tr>
<tr>
<td>.org</td>
<td>原用于非营利组织，现无限制</td>
<td>5,040</td>
<td>1040万</td>
<td>大批量4字母</td>
<td>1985-01-01</td>
<td></td>
<td></td>
<td>☆☆☆☆</td>
<td>国内不能实名认证，不能备案</td>
</tr>
<tr>
<td>.info</td>
<td>适用于提供信息服务的企业</td>
<td>738</td>
<td>656万</td>
<td></td>
<td>2001-06-26</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.cn</td>
<td>中国</td>
<td>425</td>
<td>1134万</td>
<td></td>
<td>1990-11-28</td>
<td></td>
<td>需提供政府颁发的有效身份证件。</td>
<td>☆☆☆☆</td>
<td></td>
</tr>
<tr>
<td>.us</td>
<td>美国</td>
<td>420</td>
<td>205万</td>
<td></td>
<td>1985-02-15</td>
<td></td>
<td></td>
<td></td>
<td>美国的网站很喜欢使用.com的域名。因此.us网站相对较少</td>
</tr>
<tr>
<td>.io</td>
<td>新秀，“Indian Ocean”为英属印度洋领地的缩写</td>
<td>193</td>
<td>33万</td>
<td></td>
<td>1997-09-16</td>
<td>贵</td>
<td></td>
<td>☆☆☆☆</td>
<td>该顶级域十分受初创公司和IT公司欢迎</td>
</tr>
<tr>
<td>.biz</td>
<td></td>
<td>104</td>
<td>200万</td>
<td></td>
<td>2001-06-26</td>
<td></td>
<td></td>
<td></td>
<td>取意来自英文单词 “business” ，代表着商业领域，在 .com 资源日渐枯竭的情况下， .biz 必将代替 .com 成为企业注册域名的首选。</td>
</tr>
<tr>
<td>.cc</td>
<td></td>
<td>91</td>
<td>96万</td>
<td></td>
<td>1997-10-13</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.ai</td>
<td>英国海外属地安圭拉国家及地区顶级域</td>
<td>25</td>
<td>3万</td>
<td></td>
<td>1995-02-16</td>
<td>贵</td>
<td></td>
<td>☆☆☆☆</td>
<td>由于近来人工智能的大热，.ai域名热度极度攀升</td>
</tr>
<tr>
<td>.xyz</td>
<td></td>
<td>24</td>
<td>184万</td>
<td></td>
<td>2014-02-06</td>
<td>贵</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.top</td>
<td></td>
<td>1</td>
<td>168万</td>
<td></td>
<td>2014-07-24</td>
<td>便宜</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.vip</td>
<td></td>
<td>0.6</td>
<td>74万</td>
<td></td>
<td>2015-07-30</td>
<td>便宜</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>特殊用途域名</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.gov</td>
<td>政府部门</td>
<td>1,170</td>
<td>0.5万</td>
<td></td>
<td>1985-01-01</td>
<td></td>
<td>需提供相关证件资料</td>
<td>☆☆☆☆☆☆</td>
<td>域名少，页面丰富</td>
</tr>
<tr>
<td>.edu</td>
<td>教育机构</td>
<td>601</td>
<td>0.7万</td>
<td></td>
<td>1985-01-01</td>
<td></td>
<td>需提供相关证件资料</td>
<td>☆☆☆☆☆☆</td>
<td></td>
</tr>
</tbody></table>
<h2 id="中文域名"><a href="#中文域名" class="headerlink" title="中文域名"></a>中文域名</h2><p>比如 <code>域名.com</code>，有点贵</p>
<h2 id="溢价域名"><a href="#溢价域名" class="headerlink" title="溢价域名"></a>溢价域名</h2><p>溢价域名，是注册局根据ICANN相关规定，在开放注册后可以保留一定时间后再开放的。<br>通常情况下，溢价域名是注册局保留的精品优质域名。</p>
<h2 id="域名实名认证"><a href="#域名实名认证" class="headerlink" title="域名实名认证"></a>域名实名认证</h2><p>.org .cc .me的域名不能实名认证，不在阿里云实名认证列表里。会有一下提示：</p>
<blockquote>
<p>根据工信部和域名注册局新的实名认证要求，该后缀域名暂时停止实名认证，具体开放时间等待进一步通知</p>
</blockquote>
<p>阿里云实名认证文档:</p>
<blockquote>
<p>为贯彻国家工信部对域名持有者实名制审核管理的相关规范，阿里云将全面推行域名实名认证。域名实名认证包括域名命名审核（指域名将由国家监管部门认定是否含有政策不允许注册的字符）和域名持有人信息资料实名认证。</p>
</blockquote>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20va25vd2xlZGdlX2RldGFpbC8zNTg4MS5odG1s">须完成实名认证或命名审核的域名<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<blockquote>
<p>按照工信部 2017 年全面域名实名认证的要求，目前阿里云已接到相关注册局通知：若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。涉及的域名后缀包括：.cn/.中国/.公司/.网络/.xin/.com/.net/.top/.xyz/.vip/.club/.shop/.wang/.ren/.site/.我爱你/.集团/.biz/.red/.kim/.pro/.info/.mobi/.ltd/.group/.link/.ink/.在线/.中文网/.网址/.work/.online/ .tech/.fun/.store/.网店/.live/.social/.pub/.video。</p>
</blockquote>
<p>没有实名认证的域名可以备案吗？ 不能，因为备案需要域名证书</p>
<p>没有办法 转国外了</p>
<p>我想问 你们域名都在国外，NS有没在国内？比如cloudxns？<br>有啊，我就是namesilo域名，cloudxns解析，没啥问题</p>
<h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><ul>
<li>2018年1月1日起，工信部要求备案域名必须完成域名实名认证，未完成实名认证、实名信息与备案信息不一致等会被管局驳回。</li>
<li>备案订单有效期为45天(自提交当天开始计算)，订单超期后自动失效，请您尽快提交并完成备案。为避免影响网站备案及访问，请注意服务器的服务期限及时续费。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20va25vd2xlZGdlX2RldGFpbC82NDI4OS5odG1s">网站备案域名核验<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="提示域名不支持备案怎么办？"><a href="#提示域名不支持备案怎么办？" class="headerlink" title="提示域名不支持备案怎么办？"></a>提示域名不支持备案怎么办？</h3><p>市面上流通的域名后缀并非都可以备案。只有工信部收录的域名后缀才允许开放备案，目前工信部暂未收录 .pub/.rocks/.band/.market/software/.social/.lawyer/.engineer/.link/.click/.help/.gift/.pics/.photo/.news/.video/.win/.party/.date/.trade/.science/.online/.tech/.website/.space/.press/.wiki/.design/.live/.studio/.red/.loan/.bid/.mom/.lol/.work/.game/.store/.ltd 等后缀的域名，故无法进行网站备案。</p>
<p>您可以访问 工信部备案管理系统 （<span class="exturl" data-url="aHR0cDovL3d3dy5taWl0YmVpYW4uZ292LmNuKSzov5vlhaUv">www.miitbeian.gov.cn），进入<i class="fa fa-external-link-alt"></i></span> 公共查询 &gt; 域名类型 查看域名后缀是否已收录。如果您购买的域名后缀无法进行备案，您可将域名指向中国大陆以外免备案服务器。中国大陆以外节点服务器无需进行备案。</p>
<p>此外，部分省市管局对可备案域名有特殊要求，请查看各省管局 备案规则。</p>
<h2 id="认可度，信任程度，稳定性，正式度，流行度排名。"><a href="#认可度，信任程度，稳定性，正式度，流行度排名。" class="headerlink" title="认可度，信任程度，稳定性，正式度，流行度排名。"></a>认可度，信任程度，稳定性，正式度，流行度排名。</h2><h3 id="国内域名"><a href="#国内域名" class="headerlink" title="国内域名"></a>国内域名</h3><ol>
<li><code>.cn</code>  要使用您的域名，您必须提供政府颁发的有效身份证件。</li>
<li><code>.com.cn</code> 要使用您的域名，您必须提供政府颁发的有效身份证件。</li>
<li><code>.org.cn</code></li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><code>.song</code> 神奇的亚马逊还有这个域名</li>
<li>特殊功能域名  .shoes .map .data .game .x 等</li>
<li>last.fm del.icio.us flic.kr .blog<br>…</li>
</ol>
<p>适宜个人：.me .name .blog .site（换个说法就是不适宜商用，）</p>
<p>锤子花高价买t.tt<br>所以不流行的域名里，配合好的二级域名也是有投资价值的</p>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><ul>
<li>无商业投资价值的域名不会火，<br>规律，商人、组织、企业们看中哪个域名，哪个域名就火。像个人主义的域名，再名字再好，在商业投资价值下，也变得逊色。比如.me</li>
</ul>
<h2 id="收费-amp-续费"><a href="#收费-amp-续费" class="headerlink" title="收费 &amp; 续费"></a>收费 &amp; 续费</h2><p>[万网-阿里云价格]<span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vaGVscC9wcmljZS5odG1s">https://wanwang.aliyun.com/help/price.html<i class="fa fa-external-link-alt"></i></span></p>
<p>续费小技巧：先将域名转到国内，续费个好几年，等 2 个月后转出到国外。<br>比如 <span class="exturl" data-url="aHR0cDovL3NodWFpZ2UubWUv">shuaige.me<i class="fa fa-external-link-alt"></i></span> 已续费到 2023 年， 13 年 37 一年续到了 22 年，今天转到了 gandi 花了 99</p>
<h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2><h3 id="注册量总排名"><a href="#注册量总排名" class="headerlink" title="注册量总排名"></a>注册量总排名</h3><p><strong>全球十大域名后缀，.cn仅次于.com</strong></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jY3cuY2MveW16Y2wv">实时查询<i class="fa fa-external-link-alt"></i></span></p>
<img src="http://img2.ctoutiao.com/uploads/2017/07/20/1500537225490956.jpg">
                                              |

<h3 id="国别域名-注册量排名"><a href="#国别域名-注册量排名" class="headerlink" title="国别域名 注册量排名"></a>国别域名 注册量排名</h3><p><strong>.cn域名总量达2140万，国别域名中位居全球第一</strong><br><img src="http://img2.ctoutiao.com/uploads/2017/07/20/1500537225451161.jpg"><br>截至2017年3月31日，国别域名的注册总量为1.431亿个，环比增长03.%，同比增长1.7%。其中排名前十的分别是.cn（中国）、.tk（托克劳）、.de（德国）、.uk（英国）、.ru（俄罗斯）、.nl（荷兰）、.br（巴西）、.eu（欧盟）、.au（澳大利亚）和.it（意大利）。</p>
<p>目前(2018-02-27)，<code>.tk</code> 第一，<code>.de</code>第二，<code>.cn</code>第三</p>
<img src="https://cdn0.tnwcdn.com/wp-content/blogs.dir/1/files/2016/03/NominetMap.jpg">

<h4 id="神奇的-tk"><a href="#神奇的-tk" class="headerlink" title="神奇的 .tk"></a>神奇的 .tk</h4><p>.tk 托克劳是一个太平洋上的蕞尔小岛国，却无疑是互联网世界中的真正霸主。它力压所有国家成为了域名最多的国家。</p>
<p>托克劳使用了一种目前在互联网上极为流行的“免费增值”商业模式，以.tk注册的网站只享有免费的使用权。若想完全拥有这个域名仍需要支付一笔费用。这些费用占了托克劳年收入的六分之一。</p>
<p>域名免费提供给任何人。</p>
<h3 id="新域名排名"><a href="#新域名排名" class="headerlink" title="新域名排名"></a>新域名排名</h3><p><strong>新顶级域名总量达2540万，.xyz、.top、.loan位居前三</strong></p>
<p><img src="https://user-images.githubusercontent.com/13825126/35474303-564fe59c-03c7-11e8-9bb0-653d1fa9800f.jpg" alt="1500537226527745"></p>
<p>.xyz注册量这么大，不可思议。也许因为便宜，8元一个。另外还免费送，在中国备案也助长注册量吧。目前已经在走下坡路了</p>
<p><img src="https://user-images.githubusercontent.com/13825126/35456536-d0b104fe-0310-11e8-92ff-2602cdf13b0d.PNG" alt="default"></p>
<blockquote>
<p>知乎<br>一切不能在中国备案的域名后缀球都不值  (什么意思？)</p>
</blockquote>
<h2 id="域名对SEO的影响"><a href="#域名对SEO的影响" class="headerlink" title="域名对SEO的影响"></a>域名对SEO的影响</h2><p>域名对网页搜索没有影响。</p>
<ul>
<li><a href="">百度说</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VhcmNoZW5naW5lam91cm5hbC5jb20vZ29vZ2xlLWFsbC1kb21haW4tZXh0ZW5zaW9ucy1hcmUtd2VpZ2h0ZWQtdGhlLXNhbWUvMTM3MTM5Lw==">google说<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li>wikipedia</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucXVvcmEuY29tL1doYXQtaXMtYS1iZXR0ZXItYWx0ZXJuYXRpdmUtZm9yLWEtc3RhcnR1cC13aGVuLXRoZS1jb20taXMtdGFrZW4tY28taW8tbmV0LW9yLW9yZw==">https://www.quora.com/What-is-a-better-alternative-for-a-startup-when-the-com-is-taken-co-io-net-or-org<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jdG91dGlhby5jb20vMjM5Njk4Lmh0bWw=">http://www.ctoutiao.com/239698.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="域名注册机构变化"><a href="#域名注册机构变化" class="headerlink" title="域名注册机构变化"></a>域名注册机构变化</h2><h3 id="注册商"><a href="#注册商" class="headerlink" title="注册商"></a>注册商</h3><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV0hPSVM=">whois<i class="fa fa-external-link-alt"></i></span></h3><p>是用来查询互联网中域名的IP以及所有者等信息的传输协议。早期的WHOIS查询多以命令行接口（Command Line）存在，但是现在出现了一些基于网页接口的简化在线查询工具，甚至可以一次向不同的数据库查询。网页接口的查询工具仍然依赖WHOIS协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。<br>WHOIS通常使用TCP协议43端口。每个域名或IP的WHOIS信息由对应的管理机构保存，例如，以.com结尾的域名的WHOIS信息由.com域名运营商VeriSign管理，中国国家顶级域名.cn域名由CNNIC管理。</p>
<p>通常情况下，域名或IP的信息可以由公众自由查询获得，具体的查询方法是登陆由管理机构提供的WHOIS服务器，输入待查询的域名进行查询。</p>
<h3 id="whois-ai的变化"><a href="#whois-ai的变化" class="headerlink" title="whois.ai的变化"></a>whois.ai的变化</h3><p>ai-domain也在这次升级中变为注册商，代号ai-domain。可惜的是，新用户已经无法在whois.ai创建账户，这意味着，新用户只能通过注册商进行注册了。而且注册局的用户的域名只出不进，即只提供转出功能，不提供转入功能。whois.ai已经变成一个遗留系统，趋势上会慢慢退出历史的舞台。前后模式的变化如下图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-75760893eb5c084d8629a762d521a943_hd.jpg" alt="ss"></p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU3NjQyNDk5L2Fuc3dlci8xNTQ4NTY0MzU=">https://www.zhihu.com/question/57642499/answer/154856435<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="域名转让-交易"><a href="#域名转让-交易" class="headerlink" title="域名转让/交易"></a>域名转让/交易</h2><ul>
<li><p>带价push，是直接Push到对方账户里，他要付款接收。（自己找买家，随意商议价格）</p>
</li>
<li><p>一口价域名发布,一口价需要他找域名批量或逐个购买（阿里平台给你找买家，当然要手续费）  烂域名就一口价甩出去</p>
</li>
<li><p>线上议价域名发布 （）</p>
</li>
<li><p>竞价域名发布</p>
</li>
<li><p>一口价挂出来，有被其他人秒走的可能(好域名可以线上议价)</p>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20va25vd2xlZGdlX2RldGFpbC80NTA1MS5odG1sP3NwbT01MTc2LjExMDY1MjU5LjE5OTY2NDYxMDEuc2VhcmNoY2xpY2tyZXN1bHQuNDI4MjMyN2VvS1BydFM=">交易手续费<i class="fa fa-external-link-alt"></i></span> 手续费为 1%<br>平台支持的一口价、线上议价会收取手续费，带价 push 免费。</p>
<p>交易费由谁承担？<br>由卖家承担，对于域名买家不受影响。</p>
<p>根据ICANN域名转移政策调整要求，为了确保交易的顺利进行，请所有卖家选择关闭“60天内禁止转出阿里云”限制，否则不能发布域名交易，且在2017年1月10日24点前未完成确认的已发布交易域名将全部下架处理，点击确认</p>
<h2 id="域名发展史"><a href="#域名发展史" class="headerlink" title="域名发展史"></a>域名发展史</h2><img class="portrait ui_qtext_image zoomable_in zoomable_in_feed lazy_loaded lazy_loading" src="https://qph.ec.quoracdn.net/main-qimg-1927c70c81fbd8278f89a5caca02dcf7.webp" master_src="https://qph.ec.quoracdn.net/main-qimg-31835c9f203076569e83cef18f9d495b-c" master_w="1100" master_h="8865" style="opacity: 1;">
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>domain</tag>
        <tag>web</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>【建站】汇总</title>
    <url>/pub/9c3f29da/</url>
    <content><![CDATA[<h1 id="建站流程"><a href="#建站流程" class="headerlink" title="建站流程"></a>建站流程</h1><ol>
<li><a href="../8dcc3c99/">购买域名</a></li>
<li><a href="../65131a14/">网站的托管服务器</a></li>
</ol>
<p>完整案例</p>
<ul>
<li><a href="../6c2187f/">利用Github Pages搭建独立域名的个人博客</a></li>
</ul>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul>
<li>SEO: <a href="../8b29356c/">Hexo中的SEO技巧</a></li>
<li><a href="../41fcf36a/">双线部署</a></li>
<li>CDN加速</li>
</ul>
<h1 id="背景-amp-原理"><a href="#背景-amp-原理" class="headerlink" title="背景 &amp; 原理"></a>背景 &amp; 原理</h1><ul>
<li><a href="../87420f16/">DNS解析之“记录类型”</a></li>
<li><a href="../bfc2ae40/">Github Pages托管静态博客-原理浅析</a></li>
<li><a href="../d2f02b9b/">Coding Pages托管静态博客-原理浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>关于websocket</title>
    <url>/pub/5f589e78/</url>
    <content><![CDATA[<p>websocket属于服务器推送技术的一种。<br>HTML5定义了 WebSocket 协议，以及相关的编程API，能更好的实现双向通信且节省服务器资源和带宽。</p>
<blockquote>
<p> WebSocket 实际上指的是一种协议，与我们熟知的 Http 协议是同等的一个网络协议。用网络模型结构来解释的话， WebSocket 和 Http 协议都属于 应用层协议，两者都基于传输层协议 TCP。</p>
</blockquote>
<p>http协议  <code>http:// </code><br>ftp协议   <code>ftp://</code><br>websocket协议 <code>ws://</code></p>
<p>Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。<br>在握手阶段是一样的</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>以前的网站为了实现推送功能，使用的方法都是轮询。所谓的轮询就是在特定的时间间隔（例如1秒），由浏览器向服务器发出一个 Http request，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于Http Request的Header（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 Header上。从网上资料得知后来还有改进的轮询方法叫做 Comet，使用 Ajax。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>首先WebSocket 服务器启动，并监听端口</li>
<li>客户端new websocket(dfd)，建立连接</li>
</ol>
<h2 id="客户端的API-js"><a href="#客户端的API-js" class="headerlink" title="客户端的API (js)"></a>客户端的API (js)</h2><p>不同浏览器有不同的实现，但都提供的javascript API，所以客户端API都类似，或者可以统一API。</p>
<h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>websocket服务器则因语言不同而提供不同的调用方式。</p>
<p>是叫实现，还是应该叫封装？</p>
<ul>
<li>基于java的实现<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvdG9tY2F0LWV4YW1wbGUvdHJlZS9tYXN0ZXIvV0VCLUlORi9jbGFzc2VzL3dlYnNvY2tldC8=">tomcat的websocket实现<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="">jetty的websocket实现</a></li>
</ul>
</li>
<li>基于nodejs的实现<ul>
<li>服务器端的socket.io，搭配客户端js库<code>socket.io-client</code></li>
</ul>
</li>
<li>基于python的实现</li>
<li>基于shell的实现<ul>
<li>WebSocketd</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket      <span class="comment">## 这个就是Websocket的核心了，告诉Apache、Nginx等服务器：注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</span></span><br><span class="line">Connection: Upgrade    <span class="comment">##</span></span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDUvd2Vic29ja2V0Lmh0bWw=">http://www.ruanyifeng.com/blog/2017/05/websocket.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyaXNvbl9vZl9XZWJTb2NrZXRfaW1wbGVtZW50YXRpb25z">https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiYnNoci9hYmJzaHIuZ2l0aHViLmlvL2lzc3Vlcy8yMg==">学习WebSocket协议—从顶层到底层的实现原理<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMjE1NTYx">WebSocket 是什么原理？为什么可以实现持久连接？<i class="fa fa-external-link-alt"></i></span>  —很赞</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWE1YzU1OWM1MTg4MjU3MzQ4NTllZTVl">理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li>websocket是依赖TCP吗？</li>
</ul>
<h4 id="如何debug-websocket？"><a href="#如何debug-websocket？" class="headerlink" title="如何debug websocket？"></a>如何debug websocket？</h4><p><strong>方式一：在chrome inspect中查看websocket连接</strong></p>
<p>network下的WS选项可以查看websocket连接。<br>能看到Request连接:wss://echo.websocket.org/<br>在frame中能看到明文数据，wss竟然也是明文传输</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rYWF6aW5nLmNvbS9pbnNwZWN0aW5nLXdlYnNvY2tldC10cmFmZmljLXdpdGgtY2hyb21lLWRldmVsb3Blci10b29scy8=">超详细教程<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>方式二：通过chrome console中命令查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var webSocket = new WebSocket(&#x27;ws://address:port&#x27;);</span><br><span class="line">webSocket.onmessage = function(data) &#123; console.log(data); &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式三：在chrome internal里查看</strong></p>
<p>chrome://net-internals/#sockets</p>
<p><strong>方式四：通过抓包查看</strong></p>
<p>见network/tools/wireshark/抓包</p>
<h4 id="如何查看websocket发送的数据？"><a href="#如何查看websocket发送的数据？" class="headerlink" title="如何查看websocket发送的数据？"></a>如何查看websocket发送的数据？</h4><p>浏览器inspect能看到websocket连接，为什么没看到发送的数据包？<br>那么通过抓包总能够看到吧。</p>
<ul>
<li>websocket的实现原理是什么？在TCP的基础上做了什么？加了header？</li>
</ul>
<h2 id="online-demo"><a href="#online-demo" class="headerlink" title="online demo"></a>online demo</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb2NrZXQuaW8vZGVtb3MvY2hhdC8=">socket.io的在线聊天室<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53ZWJzb2NrZXQub3JnL2VjaG8uaHRtbA==">webSocket.org Echo demo<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>服务器推送</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>rclone简介</title>
    <url>/pub/7294e32c/</url>
    <content><![CDATA[<h2 id="rclone"><a href="#rclone" class="headerlink" title="rclone"></a>rclone</h2><p>Rclone是一款的命令行工具，支持在不同对象存储、网盘间同步、上传、下载数据。</p>
<p>支持的主流对象存储：</p>
<ul>
<li>Google Drive</li>
<li>Amazon S3</li>
<li>Openstack Swift / Rackspace cloud files / Memset Memstore</li>
<li>Dropbox</li>
<li>Google Cloud Storage</li>
<li>Amazon Drive</li>
<li>Microsoft One Drive</li>
<li>Hubic</li>
<li>Backblaze B2</li>
<li>Yandex Disk</li>
<li>The local filesystem</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yY2xvbmUub3JnL2Rvd25sb2Fkcy8=">https://rclone.org/downloads/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="京东云OSS"><a href="#京东云OSS" class="headerlink" title="京东云OSS"></a>京东云OSS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:&gt; rclone config</span><br><span class="line">Current remotes:</span><br><span class="line"></span><br><span class="line">Name                 Type</span><br><span class="line">====                 ====</span><br><span class="line">cloud-oss          s3</span><br><span class="line"></span><br><span class="line">e) Edit existing remote</span><br><span class="line">n) New remote</span><br><span class="line">d) Delete remote</span><br><span class="line">r) Rename remote</span><br><span class="line">c) Copy remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">e/n/d/r/c/s/q&gt; n</span><br><span class="line"></span><br><span class="line">Enter name for new remote.</span><br><span class="line">name&gt; abc</span><br><span class="line"></span><br><span class="line">Option Storage.</span><br><span class="line">Type of storage to configure.</span><br><span class="line">Choose a number from below, or type in your own value.</span><br><span class="line"> 1 / 1Fichier</span><br><span class="line">   \ (fichier)</span><br><span class="line"> 2 / Akamai NetStorage</span><br><span class="line">   \ (netstorage)</span><br><span class="line"> 3 / Alias for an existing remote</span><br><span class="line">   \ (alias)</span><br><span class="line"> 4 / Amazon Drive</span><br><span class="line">   \ (amazon cloud drive)</span><br><span class="line"> 5 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, China Mobile, Cloudflare, ArvanCloud, Digital Ocean, Dreamhost, Huawei OBS, IBM COS, IDrive e2, Lyve Cloud, Minio, Netease, RackCorp, Scaleway, SeaweedFS, StackPath, Storj, Tencent COS and Wasabi</span><br><span class="line">   \ (s3)</span><br><span class="line"> 6 / Backblaze B2</span><br><span class="line">   \ (b2)</span><br><span class="line"> 7 / Better checksums for other remotes</span><br><span class="line">   \ (hasher)</span><br><span class="line"> 8 / Box</span><br><span class="line">   \ (box)</span><br><span class="line"> 9 / Cache a remote</span><br><span class="line">   \ (cache)</span><br><span class="line">10 / Citrix Sharefile</span><br><span class="line">   \ (sharefile)</span><br><span class="line">11 / Combine several remotes into one</span><br><span class="line">   \ (combine)</span><br><span class="line">12 / Compress a remote</span><br><span class="line">   \ (compress)</span><br><span class="line">13 / Dropbox</span><br><span class="line">   \ (dropbox)</span><br><span class="line">14 / Encrypt/Decrypt a remote</span><br><span class="line">   \ (crypt)</span><br><span class="line">15 / Enterprise File Fabric</span><br><span class="line">   \ (filefabric)</span><br><span class="line">16 / FTP</span><br><span class="line">   \ (ftp)</span><br><span class="line">17 / Google Cloud Storage (this is not Google Drive)</span><br><span class="line">   \ (google cloud storage)</span><br><span class="line">18 / Google Drive</span><br><span class="line">   \ (drive)</span><br><span class="line">19 / Google Photos</span><br><span class="line">   \ (google photos)</span><br><span class="line">20 / HTTP</span><br><span class="line">   \ (http)</span><br><span class="line">21 / Hadoop distributed file system</span><br><span class="line">   \ (hdfs)</span><br><span class="line">22 / HiDrive</span><br><span class="line">   \ (hidrive)</span><br><span class="line">23 / Hubic</span><br><span class="line">   \ (hubic)</span><br><span class="line">24 / In memory object storage system.</span><br><span class="line">   \ (memory)</span><br><span class="line">25 / Internet Archive</span><br><span class="line">   \ (internetarchive)</span><br><span class="line">26 / Jottacloud</span><br><span class="line">   \ (jottacloud)</span><br><span class="line">27 / Koofr, Digi Storage and other Koofr-compatible storage providers</span><br><span class="line">   \ (koofr)</span><br><span class="line">28 / Local Disk</span><br><span class="line">   \ (local)</span><br><span class="line">29 / Mail.ru Cloud</span><br><span class="line">   \ (mailru)</span><br><span class="line">30 / Mega</span><br><span class="line">   \ (mega)</span><br><span class="line">31 / Microsoft Azure Blob Storage</span><br><span class="line">   \ (azureblob)</span><br><span class="line">32 / Microsoft OneDrive</span><br><span class="line">   \ (onedrive)</span><br><span class="line">33 / OpenDrive</span><br><span class="line">   \ (opendrive)</span><br><span class="line">34 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH)</span><br><span class="line">   \ (swift)</span><br><span class="line">35 / Pcloud</span><br><span class="line">   \ (pcloud)</span><br><span class="line">36 / Put.io</span><br><span class="line">   \ (putio)</span><br><span class="line">37 / QingCloud Object Storage</span><br><span class="line">   \ (qingstor)</span><br><span class="line">38 / SSH/SFTP</span><br><span class="line">   \ (sftp)</span><br><span class="line">39 / Sia Decentralized Cloud</span><br><span class="line">   \ (sia)</span><br><span class="line">40 / Storj Decentralized Cloud Storage</span><br><span class="line">   \ (storj)</span><br><span class="line">41 / Sugarsync</span><br><span class="line">   \ (sugarsync)</span><br><span class="line">42 / Transparently chunk/split large files</span><br><span class="line">   \ (chunker)</span><br><span class="line">43 / Union merges the contents of several upstream fs</span><br><span class="line">   \ (union)</span><br><span class="line">44 / Uptobox</span><br><span class="line">   \ (uptobox)</span><br><span class="line">45 / WebDAV</span><br><span class="line">   \ (webdav)</span><br><span class="line">46 / Yandex Disk</span><br><span class="line">   \ (yandex)</span><br><span class="line">47 / Zoho</span><br><span class="line">   \ (zoho)</span><br><span class="line">48 / premiumize.me</span><br><span class="line">   \ (premiumizeme)</span><br><span class="line">49 / seafile</span><br><span class="line">   \ (seafile)</span><br><span class="line">Storage&gt; 5</span><br><span class="line"></span><br><span class="line">Option provider.</span><br><span class="line">Choose your S3 provider.</span><br><span class="line">Choose a number from below, or type in your own value.</span><br><span class="line">Press Enter to leave empty.</span><br><span class="line"> 1 / Amazon Web Services (AWS) S3</span><br><span class="line">   \ (AWS)</span><br><span class="line"> 2 / Alibaba Cloud Object Storage System (OSS) formerly Aliyun</span><br><span class="line">   \ (Alibaba)</span><br><span class="line"> 3 / Ceph Object Storage</span><br><span class="line">   \ (Ceph)</span><br><span class="line"> 4 / China Mobile Ecloud Elastic Object Storage (EOS)</span><br><span class="line">   \ (ChinaMobile)</span><br><span class="line"> 5 / Cloudflare R2 Storage</span><br><span class="line">   \ (Cloudflare)</span><br><span class="line"> 6 / Arvan Cloud Object Storage (AOS)</span><br><span class="line">   \ (ArvanCloud)</span><br><span class="line"> 7 / Digital Ocean Spaces</span><br><span class="line">   \ (DigitalOcean)</span><br><span class="line"> 8 / Dreamhost DreamObjects</span><br><span class="line">   \ (Dreamhost)</span><br><span class="line"> 9 / Huawei Object Storage Service</span><br><span class="line">   \ (HuaweiOBS)</span><br><span class="line">10 / IBM COS S3</span><br><span class="line">   \ (IBMCOS)</span><br><span class="line">11 / IDrive e2</span><br><span class="line">   \ (IDrive)</span><br><span class="line">12 / Seagate Lyve Cloud</span><br><span class="line">   \ (LyveCloud)</span><br><span class="line">13 / Minio Object Storage</span><br><span class="line">   \ (Minio)</span><br><span class="line">14 / Netease Object Storage (NOS)</span><br><span class="line">   \ (Netease)</span><br><span class="line">15 / RackCorp Object Storage</span><br><span class="line">   \ (RackCorp)</span><br><span class="line">16 / Scaleway Object Storage</span><br><span class="line">   \ (Scaleway)</span><br><span class="line">17 / SeaweedFS S3</span><br><span class="line">   \ (SeaweedFS)</span><br><span class="line">18 / StackPath Object Storage</span><br><span class="line">   \ (StackPath)</span><br><span class="line">19 / Storj (S3 Compatible Gateway)</span><br><span class="line">   \ (Storj)</span><br><span class="line">20 / Tencent Cloud Object Storage (COS)</span><br><span class="line">   \ (TencentCOS)</span><br><span class="line">21 / Wasabi Object Storage</span><br><span class="line">   \ (Wasabi)</span><br><span class="line">22 / Any other S3 compatible provider</span><br><span class="line">   \ (Other)</span><br><span class="line">provider&gt; 22    # 阿里云，就选2</span><br><span class="line"></span><br><span class="line">Option env_auth.</span><br><span class="line">Get AWS credentials from runtime (environment variables or EC2/ECS meta data if no env vars).</span><br><span class="line">Only applies if access_key_id and secret_access_key is blank.</span><br><span class="line">Choose a number from below, or type in your own boolean value (true or false).</span><br><span class="line">Press Enter for the default (false).</span><br><span class="line"> 1 / Enter AWS credentials in the next step.</span><br><span class="line">   \ (false)</span><br><span class="line"> 2 / Get AWS credentials from the environment (env vars or IAM).</span><br><span class="line">   \ (true)</span><br><span class="line">env_auth&gt;</span><br><span class="line"></span><br><span class="line">Option access_key_id.</span><br><span class="line">AWS Access Key ID.</span><br><span class="line">Leave blank for anonymous access or runtime credentials.</span><br><span class="line">Enter a value. Press Enter to leave empty.</span><br><span class="line">access_key_id&gt; ***  </span><br></pre></td></tr></table></figure>


<p>生成的配置文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[cloud-oss]</span><br><span class="line">type = s3</span><br><span class="line">provider = Other</span><br><span class="line">env_auth = true</span><br><span class="line">access_key_id = ***</span><br><span class="line">secret_access_key = *** </span><br><span class="line">endpoint = https://**.com</span><br></pre></td></tr></table></figure>


<h2 id="rclone-命令"><a href="#rclone-命令" class="headerlink" title="rclone 命令"></a>rclone 命令</h2><p><strong>rclone config</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone config - 进入交互式配置选项，进行添加、删除、管理网盘等操作。</span><br><span class="line"></span><br><span class="line">rclone config file - 显示配置文件的路径，一般配置文件在 ~/.config/rclone/rclone.conf</span><br><span class="line"></span><br><span class="line">rclone config show - 显示配置文件信息</span><br></pre></td></tr></table></figure>



<p><strong>rclone ls</strong><br>列出bucket下所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rclone ls cloud-oss:nlp-object-store</span><br></pre></td></tr></table></figure>

<p>列出bucket特定path下所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rclone ls cloud-oss:nlp-object-store/jr</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>rclone lsl</strong> - 比上面多一个显示上传时间。</li>
<li><strong>rclone lsd</strong> 列出指定路径下的目录</li>
<li><strong>rclone lsf</strong> - 列出指定路径下的目录和文件</li>
</ul>
<p><strong>rclone copy</strong></p>
<p><strong>rclone sync</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rclone sync --help</span><br><span class="line">$ rclone sync source:path dest:path   # 单向的，只改变dest， 双向同步使用 bisync</span><br><span class="line"></span><br><span class="line"># 本地 同步到 服务器</span><br><span class="line">$ rclone sync E:/test cloud-oss:nlp-object-store/test</span><br><span class="line"></span><br><span class="line"># 服务器 同步到 本地</span><br><span class="line">$ rclone sync cloud-oss:nlp-object-store/test E:/test</span><br></pre></td></tr></table></figure>

<p>Sync the source to the destination, changing the destination only.</p>
<p>注意：</p>
<ul>
<li>同步数据时，可能会删除目的地址的数据；建议先使用–dry-run 标志来检查要复制、删除的数据。</li>
<li>同步数据出错时，不会删除任何目的地址的数据。</li>
<li>同步的始终是 path 目录下的数据，而不是 path 目录。（空目录将不会被同步）</li>
<li>同步频率？ 是一次性同步，不是随时同步</li>
</ul>
<p><strong>rclone bisync</strong></p>
<p>这是个新增的feature：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JjbG9uZS9yY2xvbmUvcHVsbC81MTY0">https://github.com/rclone/rclone/pull/5164<i class="fa fa-external-link-alt"></i></span></p>
<p>注意：bisync is EXPERIMENTAL. Don’t use in production!</p>
<p><strong>rclone mount</strong>：太棒了</p>
<p>rclone mount cloud-oss:nlp-object-store/test X: –cache-dir D:\logs_rcloneCache –vfs-cache-mode writes</p>
<p>这个依赖winfsp</p>
<ul>
<li>这个挂载，会把数据全部下载，不只是meta信息</li>
<li>是双向同步</li>
<li>同步频率，是不是有点慢？怎么修改</li>
</ul>
<p>如何开机自动挂载？</p>
<p><strong>rclone md5sum</strong> - 为指定路径下的所有文件产生一个md5sum文件。</p>
<p><strong>rclone sha1sum</strong> - 为指定路径下的所有文件产生一个sha1sum文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9yY2xvbmUub3JnL2RvY3Mv">https://rclone.org/docs/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2FrdUNpY2FkYS9wLzEzNTczMTMyLmh0bWw=">https://www.cnblogs.com/KakuCicada/p/13573132.html<i class="fa fa-external-link-alt"></i></span> 这个文档格式挺不错</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0bG5zLmdpdGh1Yi5pby8yMDE2LzExLzI4L3JjbG9uZS1ndWlkZS8=">https://softlns.github.io/2016/11/28/rclone-guide/<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvY3JhdGVzL2FydGljbGUvZGV0YWlscy8xMDQ4MDA3MDk=">https://blog.csdn.net/socrates/article/details/104800709<i class="fa fa-external-link-alt"></i></span> 阿里云 亚马逊云配置 rclone</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>中间件</category>
        <category>对象存储</category>
      </categories>
  </entry>
  <entry>
    <title>【读图识政治】图解中国官员级别--2013</title>
    <url>/pub/88222587/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2NucG9saXRpY3Mub3JnLzIwMTMvMDMvY2hpbmVzZS1vZmZpY2lhbHMv">图来自政见网<i class="fa fa-external-link-alt"></i></span><br>貌似被墙了</p>
<p><img src="/images/raw/Politics - ChineseOfficials2013 - cnpolitics.jpg"></img></p>
<p>2005年4月27日通过的《公务员法》第十六条规定：</p>
<ul>
<li>公务员职务分为<strong>领导职务</strong>和<strong>非领导职务</strong>。</li>
<li>领导职务层次分为：国家级正职、国家级副职、省部级正职、省部级副职、厅局级正职、厅局级副职、县处级正职、县处级副职、乡科级正职、乡科级副职。</li>
</ul>
<h2 id="国家副主席是国家级正职吧？"><a href="#国家副主席是国家级正职吧？" class="headerlink" title="国家副主席是国家级正职吧？"></a>国家副主席是国家级正职吧？</h2><p>No</p>
<p>2013年，中共十二届全国人大第一次会议上，李源潮顺利“当选”国家副主席，这使得李源潮成为中国政府约20年来首位非政治局常委的国家副主席，前一“非常”副主席是王震。令人们十分好奇的内容之一是，他在随后的5年时间里，更准确地说是他在2017年秋季召开中共十九大之前的这段时间里，到底会享受和7名政治局常委一样的“正国级”待遇，还是继续享受十八届中央领导集体内和他党内身份相同的其他政治局委员们共同享受的“副国级”待遇。</p>
<p>中共此前有明文规定，以下职位：中共中央总书记、中央政治局常委、国家主席、国务院总理、全国人大常委会委员长、全国政协主席、中央军委主席、国家副主席为正国家级别。因此，有观点认为，延续原来的惯例，现在在职的正国家领导有八位，<strong>7大常委</strong> 和国家副主席李源潮。</p>
<p>但也有观点认为，中国的国家主席一般是中央总书记，行政级别是是国家级，在这届李源潮之前近20年间，国家副主席均是政治局常委，属于党和国家领导人，其行政级别是国家级，但从今年开始，国家副主席不是政治局常委，而是政治局委员，因此，他的行政级别是副国级。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cDovL20uY3JlYWRlcnMubmV0L2NoaW5hLzIwMTUvMDEvMjAvMTQ4MDM1OS5odG1s">参考<i class="fa fa-external-link-alt"></i></span></p>
<p>  “高级检察院” “中级检察院” 笑尿了</p>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
      </categories>
      <tags>
        <tag>官员级别</tag>
        <tag>国家领导</tag>
      </tags>
  </entry>
  <entry>
    <title>【读图识政治】图解中国领导团队新阵容 &amp; 主要行政机构 --2018</title>
    <url>/pub/6de9771b/</url>
    <content><![CDATA[<h1 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h1><p>今年全国两会适逢换届，至3月19日，国家机构和全国政协新领导层均已产生，中国领导团队的新阵容已组建完毕。</p>
<p>人民日报客户端根据两会报道和相关公开资料，梳理绘制了一张中国领导团队新阵容思维导图</p>
<img alt="中国领导团队新阵容--2018" src="/images/raw/Politics - 中国领导团队新阵容2018 - 人民日报.jpg">


<h1 id="职责-分工"><a href="#职责-分工" class="headerlink" title="职责 分工"></a>职责 分工</h1><p>中国领导团队，有<code>三大分支</code>：党、人大、政协。党选举党内领导，人大选举国家领导，政协包括各党派。<br>一般每个分支的大boss都是政治局常委。</p>
<ul>
<li>李克强：国务院总理 (中央人民政府)</li>
<li>栗战书：人大委员长</li>
<li>汪洋：政协主席</li>
<li>王沪宁：中央书记处书记，主管意识形态。 上一任刘云山 <!-- 刘云山还兼职中央党校校长 --><!--</li>
<li>王沪宁毕业后在一直中央政策研究室从事纯理论工作，一干就是二十年，“清水衙门”。</li>
<li>王沪宁直接参与、起草了江泽民“三个代表”重要思想、胡锦涛“科学发展观”以及习近平“新时代中国特色社会主义思想”等重大政治理论与思想，辅佐了三代总书记，是中共高层的重要理论智囊。</li>
<li>王沪宁有元老们的认同支持。江曾力挺，胡锦涛也有好感</li>
<li>栗战书、王沪宁主导了2018宪法修正案。</li>
<li>他是继邓力群之后，又一位<strong>理论界人士</strong>担任中央书记处书记职务。</li>
<li>王沪宁代表当前最高意识形态，拥有“习近平思想”解释权。</li>
<li>-&gt;</li>
<li>赵乐际：纪委书记</li>
<li>韩正：国务院副总理 (原上海市委书记)</li>
</ul>
<h2 id="党"><a href="#党" class="headerlink" title="党"></a>党</h2><p>2017年10月25，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU1JTlCJUJEJUU1JTg1JUIxJUU0JUJBJUE3JUU1JTg1JTlBJUU3JUFDJUFDJUU1JThEJTgxJUU0JUI5JTlEJUU1JUIxJThBJUU0JUI4JUFEJUU1JUE0JUFFJUU1JUE3JTk0JUU1JTkxJTk4JUU0JUJDJTlBJUU3JUFDJUFDJUU0JUI4JTgwJUU2JUFDJUExJUU1JTg1JUE4JUU0JUJEJTkzJUU0JUJDJTlBJUU4JUFFJUFF">中共19大<i class="fa fa-external-link-alt"></i></span></p>
<p>选举，党内领导。</p>
<h2 id="人大"><a href="#人大" class="headerlink" title="人大"></a>人大</h2><p>13届全国人大，选举国家领导。</p>
<h2 id="政协"><a href="#政协" class="headerlink" title="政协"></a>政协</h2><p>2018年3月14日，第13届全国人民政治协商会议，选举政协领导。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table>
<thead>
<tr>
<th>排名</th>
<th>肖像姓名</th>
<th>党职</th>
<th>公职</th>
<th>分工</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>习近平</td>
<td>中共中央总书记中共中央军委主席</td>
<td>国家主席中央军委主席</td>
<td>中央国家安全委员会主席中央全面深化改革委员会主任中央全面依法治国委员会主任中央财经委员会主任中央外事工作委员会主任中央对台工作领导小组组长中央网络安全和信息化委员会主任中央军委深化国防和军队改革领导小组组长中央军委联合作战指挥中心总指挥中央军委联合作战指挥中心总指挥中央军民融合发展委员会主任</td>
</tr>
<tr>
<td>2</td>
<td>李克强</td>
<td>中共中央政治局常委国务院党组书记</td>
<td>国务院总理</td>
<td>中央国家安全委员会副主席中央全面深化改革委员会副主任中央财经委员会副主任中央机构编制委员会主任国家国防动员委员会主任国家能源委员会主任中央网络安全和信息化委员会副主任中央军民融合发展委员会副主任</td>
</tr>
<tr>
<td>3</td>
<td>栗战书</td>
<td>中共中央政治局常委全国人大常委会党组书记</td>
<td>全国人大常委会委员长</td>
<td>中央国家安全委员会副主席中央港澳工作协调小组组长</td>
</tr>
<tr>
<td>4</td>
<td>汪　洋</td>
<td>中共中央政治局常委全国政协党组书记</td>
<td>全国政协主席</td>
<td>中央西藏工作协调小组组长中央新疆工作协调小组组长中央对台工作领导小组副组长</td>
</tr>
<tr>
<td>5</td>
<td>王沪宁</td>
<td>中共中央政治局常委中央书记处书记中央文明委主任中央政策研究室主任</td>
<td></td>
<td>中央全面深化改革委员会副主任中央宣传思想工作领导小组组长中央党的建设工作领导小组组长中央党的群众路线教育实践活动领导小组组长中央机构编制委员会副主任中央网络安全和信息化委员会副主任中央财经委员会成员中央军民融合发展委员会副主任</td>
</tr>
<tr>
<td>6</td>
<td>赵乐际</td>
<td>中共中央政治局常委中共中央纪委书记</td>
<td></td>
<td>中央党的建设工作领导小组副组长中央巡视工作领导小组组长中央深化国家监察体制改革试点工作领导小组组长</td>
</tr>
<tr>
<td>7</td>
<td>韩　正</td>
<td>中共中央政治局常委国务院党组副书记</td>
<td>国务院副总理</td>
<td>中央全面深化改革委员会副主任国家能源委员会副主任国务院食品安全委员会主任中央财经委员会成员中央军民融合发展委员会副主任兼办公室主任</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="变动"><a href="#变动" class="headerlink" title="变动"></a>变动</h1><h2 id="续期七大常委"><a href="#续期七大常委" class="headerlink" title="续期七大常委"></a>续期七大常委</h2><ul>
<li>习近平</li>
<li>李克强</li>
</ul>
<p>其他5个都是新晋常委</p>
<h2 id="原常委"><a href="#原常委" class="headerlink" title="原常委"></a>原常委</h2><ul>
<li>王岐山 -&gt; 副主席 (2017年10月，中共十九大后，王岐山不再担任中央委员会和中纪委领导职务。)<br>王岐山在党内排名第八位，在副总理韩正之后，仅次于七位政治局常委</li>
</ul>
<p>对比以下链接 中国官员级别–2013</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>中央军委是党的会议选举的吧？怎么也挂在人民代表大会下面？</p>
<h1 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h1><p>五年前，习近平和李克强双接班，人们按照先前的江朱体制和胡温体制的说法，称之为习李体制。但人们很快就发现，没有什么习李体制，李克强这个国务院总理的地位远远比不上先前的朱镕基和温家宝；倒是政治局常委名列第六的王岐山更重要，俨然习王体制。现在，王岐山将出任国家副主席，必将是中共建政以来权力最大的副主席。</p>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
      </categories>
      <tags>
        <tag>国家领导</tag>
        <tag>两会</tag>
        <tag>国家机构</tag>
        <tag>国家机构改革</tag>
      </tags>
  </entry>
  <entry>
    <title>修宪 - 2018</title>
    <url>/pub/275d8a6f/</url>
    <content><![CDATA[<ul>
<li><span class="exturl" data-url="aHR0cDovL2NuLmdpdGh1Yi5pby9jb25zdGl0dXRpb24vMTk4Mi0xMi0wNC5odG1s">中华人民共和国宪法 (1982-12-04)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NuLmdpdGh1Yi5pby9jb25zdGl0dXRpb24vMjAwNC0wMy0xNC5odG1s">中华人民共和国宪法 (2004-03-14)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="2018年修宪"><a href="#2018年修宪" class="headerlink" title="2018年修宪"></a>2018年修宪</h1><p>全名：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU1JThEJThFJUU0JUJBJUJBJUU2JUIwJTkxJUU1JTg1JUIxJUU1JTkyJThDJUU1JTlCJUJEJUU1JUFFJUFBJUU2JUIzJTk1JUU0JUJGJUFFJUU2JUFEJUEzJUU2JUExJTg4XygyMDE4JUU1JUI5JUI0KQ==">《中华人民共和国宪法修正案》（2018年）<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>2017年9月29日 - 成立宪法修改小组<!--
宪法修改小组，由张德江任组长，栗战书、王沪宁任副组长。
同年10月18日，中共十九大召开，栗战书及王沪宁当选新一届政治局常委</li>
<li>-&gt;</li>
<li>2018年1月30日 - 由人大常委会提请申报成功，全票通过《中华人民共和国宪法修正案（草案）》</li>
<li>2018年2月25日 - 由<span class="exturl" data-url="aHR0cDovL3d3dy54aW5odWFuZXQuY29tL3BvbGl0aWNzLzIwMTgtMDIvMjUvY18xMTIyNDUxMTg3Lmh0bQ==">新华社<i class="fa fa-external-link-alt"></i></span>和新闻联播于公布 《中国共产党中央委员会关于修改宪法部分内容的建议》</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NuL2NvbnN0aXR1dGlvbi9wdWxsLzIvY29tbWl0cy84MTE1NDg0ZDE4NDhkMzA5ZjY4YzcwOWQ4ZWExNzYzNzRiMmIxMTYw">划重点<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">第七十九条</span><br><span class="line"><span class="deletion">- 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。</span></span><br><span class="line"><span class="addition">+ 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同。</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- 在马克思列宁主义、毛泽东思想、邓小平理论和“三个代表”重要思想指引下</span></span><br><span class="line"><span class="addition">+ 在马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想指引下</span></span><br><span class="line"></span><br><span class="line">第六十三条 全国人民代表大会有权罢免下列人员：</span><br><span class="line">   主席、副主席、国务院总理、副总理、军事委员会主席、最高人民法院院长、最高人民检察院检察长</span><br><span class="line"><span class="addition">+ （四）国家监察委员会主任；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>宪法第七十九条第三款，删除<code>“国家主席、副主席连续任职不得超过两届”</code>，而引起国际关注。外界普遍将之视为邓小平时代提出的“废除干部领导职务终身制”的结束。</li>
<li>宪法序言增写<code>“科学发展观”</code>、<code>“习近平新时代中国特色社会主义思想”</code>及<code>“富强民主文明和谐美丽的社会主义现代化强国”</code>字样</li>
</ul>
<h2 id="关于-监察机关-国家监察委员会"><a href="#关于-监察机关-国家监察委员会" class="headerlink" title="关于 监察机关 国家监察委员会"></a>关于 监察机关 国家监察委员会</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 第一百二十三条 中华人民共和国各级监察委员会是国家的监察机关。</span></span><br><span class="line"><span class="addition">+ 第一百二十四条 中华人民共和国设立国家监察委员会和地方各级监察委员会。监察委员会由下列人员组成</span></span><br><span class="line"><span class="addition">+  主任，</span></span><br><span class="line"><span class="addition">+  副主任若干人，</span></span><br><span class="line"><span class="addition">+  委员若干人。</span></span><br><span class="line"><span class="addition">+  监察委员会主任每届任期同本级人民代表大会每届任期相同。国家监察委员会主任连续任职不得超过两届。</span></span><br></pre></td></tr></table></figure>

<h1 id="关于修宪历史"><a href="#关于修宪历史" class="headerlink" title="关于修宪历史"></a>关于修宪历史</h1><p>中国现行宪法制定于1982年。当时，为废除实际存在的领导职务终身制，吸取文革个人崇拜的教训，宪法规定了国家主席连续任职不得超过两届，在客观上限定了中国国家元首任职不能超过十年。</p>
<p>中共于1988年、1993年、1999年、2004年对现行宪法进行了四次修改</p>
<h2 id="1988年修宪：为“私营经济”正名"><a href="#1988年修宪：为“私营经济”正名" class="headerlink" title="1988年修宪：为“私营经济”正名"></a>1988年修宪：为“私营经济”正名</h2><h2 id="1993年修宪"><a href="#1993年修宪" class="headerlink" title="1993年修宪"></a>1993年修宪</h2><p>1993年，中共总书记、中央军委主席江泽民接替杨尚昆出任国家主席，定下了总书记、国家主席、中央军委主席“三位一体”的最高领导模式。</p>
<p>国家的奋斗目标，则由建设“高度文明、高度民主的社会主义国家”变为建设“富强、民主、文明的社会主义国家”。两个字的增加、两个词顺序的变化，看似微小，却深意可见。</p>
<p>“市场经济”一词的入宪、“计划经济”一词的淡出。</p>
<h2 id="1999年修宪：为“法治”鼓与呼"><a href="#1999年修宪：为“法治”鼓与呼" class="headerlink" title="1999年修宪：为“法治”鼓与呼"></a>1999年修宪：为“法治”鼓与呼</h2><p>“依法治国”。</p>
<h2 id="2004-第四次修改，"><a href="#2004-第四次修改，" class="headerlink" title="2004- 第四次修改，"></a>2004- 第四次修改，</h2><h2 id="关于连任"><a href="#关于连任" class="headerlink" title="关于连任"></a>关于连任</h2><ul>
<li><p>根据邓小平在1980年提倡的“废除干部领导职务终身制”，重新设立的国家主席和副主席任期为五年一届，连任不能超过两届。</p>
</li>
<li><p>党总书记、军委主席是中国政治体系中拥有最大权力的两个职务，没有连任次数的限制。</p>
</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1Nak01TWpBeE5ETTRNQT09Jm1pZD0yNjY2MTg5NTE2JmlkeD0xJnNuPWZlMmVmZTdmNzYyYTg3YWY0MGM2ODFlYTA1ZDczZTI3JmNoa3NtPWJkYjJiYjhmOGFjNTMyOTk0OGU4NjBiMDJiMjJjMDAwMzc4MDE2MDIxODc3OTFmMGMwYmUxZmMxNjAwYWY4NWZjYjI0ZDQ1YWJmNDAmbXBzaGFyZT0x">修宪前后完整对比<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzQ5MTQ4">为什么美国的 1787 宪法可以至今沿用?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
      </categories>
      <tags>
        <tag>宪法</tag>
        <tag>国家监察委员会</tag>
      </tags>
  </entry>
  <entry>
    <title>行政名词 扫盲</title>
    <url>/pub/5f1b2d12/</url>
    <content><![CDATA[<h2 id="“部”与“委员会”有何区别？"><a href="#“部”与“委员会”有何区别？" class="headerlink" title="“部”与“委员会”有何区别？"></a>“部”与“委员会”有何区别？</h2><p> 简单理解：“部”是一颗颗珍珠，“委”则是串起这些珍珠的链子。前者具有单一职能，重在执行，后者主要在于协调，重在推进。</p>
<p>比如发改委，几乎涉及了国务院组成部门大部分部级单位的部分权力。</p>
<h2 id="国务院组成部门、直属机构、办事机构、直属事业单位的区别？"><a href="#国务院组成部门、直属机构、办事机构、直属事业单位的区别？" class="headerlink" title="国务院组成部门、直属机构、办事机构、直属事业单位的区别？"></a>国务院组成部门、直属机构、办事机构、直属事业单位的区别？</h2><p>各级机构中，尤以国务院所属机构的名称特征更加明显，包括国务院组成部门、直属机构、办事机构，都能从名称上识别。</p>
<ul>
<li>国务院直属特设机构，只有一个，如国资委。</li>
<li>国务院直属机构，共16个，如国家税务总局、工商总局、安监总局、统计局、林业局等。有办事机构，共4个，如侨务办、研究室等。</li>
<li>直属事业单位，共17个，如新华社、中科院、银监委员会、证监委员会、保监委员会等。</li>
<li>部委管理的局22个，如信访局、粮食局、能源局等，其中个别的叫委，如国家语言文字工作委员会。</li>
</ul>
<p>国务院直属机构，不属于国务院级组成部门，其负责人不属于国务院全体会议的组成人员。在国务院直属机构中，没有部的称谓，但有委员会的称谓。直属机构中的正职负责人，有的是正部级，总局的应该都是，局的不是，可能还有就是局级待遇的。事业单位的正职，一般会是正部级。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwODM4ODc3L2Fuc3dlci8xNjM1MjUyNA==">https://www.zhihu.com/question/20838877/answer/16352524<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="省部级：“部”、“总局”、“总署”-一般都是正部级"><a href="#省部级：“部”、“总局”、“总署”-一般都是正部级" class="headerlink" title="省部级：“部”、“总局”、“总署” 一般都是正部级"></a>省部级：“部”、“总局”、“总署” 一般都是正部级</h2><h2 id="厅局级：司-局-区别"><a href="#厅局级：司-局-区别" class="headerlink" title="厅局级：司 局 区别"></a>厅局级：司 局 区别</h2><p>国务院部门中，为何有的叫“部(委)”，有的叫“总局(局)”？司和局有什么区别？</p>
<p>在国务院部门中，“司”和“局”虽然行政级别一样，但职能有所区别。</p>
<p>2012年4月，事业单位改革指导意见正式公布后，不少人发现，像中国气象局、中国证监会这些从名称上看似行政机构，实际也承担行政职能的单位，竟然也被归为事业单位。不过，他们或许能借这次改革，被划入行政序列。</p>
<p>每个中央机关，都有诸多内设机构，每个部门都有一个办公厅(室)。除此之外，党委部门如中组部、中宣部、统战部的其他内设机构一般都叫“局”。</p>
<p>国务院下属行政机构的内设机构一般叫“司”，但也还有少量的“局”，如广电总局下设十多个“司”，还有一个电影局，铁道部下设多个司，还有一个运输局。</p>
<p>在国务院部门中，“司”和“局”虽然在行政级别上是一样的，但在职能上有所区别，文化部一位退休的司级干部用他的自身经历，向南方周末记者说明这个差别。他所在的部门现在叫文化部艺术司，过去叫艺术局。</p>
<p>在他看来，“司”和“局”在业务上没有太大区别，但在对外协调上有所区别。原来的文化部艺术局，除了下设业务处室之外，还有党委、人事处、计划财务处，统筹文化部在京直属单位如国家京剧院、国家话剧院、国家美术馆等的人、财、物。但变成艺术司之后，就成了一个纯业务部门，对人、财、物的统筹工作，就上交由文化部相关部门负责。</p>
<p>另外一个变化是，文化部艺术局是可以直接对“外”的，可以直接向各省市的文化厅(局)直接发文。但改成艺术司以后，就不能直接发文了，如需要发文，只能是起草好之后，以文化部或文化部办公厅的名义对外发。</p>
<h2 id="“国家”、“中国”、“中华”、“中央”，有何差别？"><a href="#“国家”、“中国”、“中华”、“中央”，有何差别？" class="headerlink" title="“国家”、“中国”、“中华”、“中央”，有何差别？"></a>“国家”、“中国”、“中华”、“中央”，有何差别？</h2><p>在日常称呼中，人们一般喜欢将国务院部门简称为“国家××部(委)”，如“国家发改委”、“国家工商总局”。</p>
<p>但如果你去看机构全称，就会发现，不同部门的准确名称，开头几个字是不同的。有的开头是“中华人民共和国”，如中华人民共和国发展和改革委员会，有的开头却是“中国”，如中国气象局，有的开头又是“国家”，如国家工商行政管理总局。</p>
<p>这里，都有什么区别和讲究呢？</p>
<p>“名称的开头”，其实是个外行的说法，规范的说法是“区域名”。在中国，机构名称一般都由三个部分组成，分别是区域名、矢名和格级名。</p>
<p>以中华人民共和国外交部为例，“中华人民共和国”是它的区域名，表明它的管理范围和隶属关系；“外交”是它的矢名，表明工作内容；“部”是它的格级名，表明了它的级别规格。</p>
<p>目前国务院部门，分别组成部门、直属机构、办事机构、议事协调机构、事业单位等几类。一般来说，同类机构的区域名、格级名一致，能从名称大体判断的它的机构属性。</p>
<p>比如，区域名为“中华人民共和国”的，大多都是国务院组成部门，如中华人民共和国教育部、文化部、公安部等。国务院27个组成部门中，只有中国人民银行例外，区域名是“中国”。除了央行和审计署之外，组成部门的格级名都是“部”、“委”。</p>
<p>而国务院直属机构，区域名大多都是“国家”，如国家广电总局、国家旅游局、国家统计局。国务院15个直属机构中，唯有海关总署的区域名是“中华人民共和国”。这也是唯一一个区域名是“中华人民共和国”，但不是国务院组成部门的机构。国务院直属机构的格级名一般叫“局”、“总局”、“总署”。</p>
<p>此外，所有部委管理的国家局中，除了2008年机构改革后的中国民航局，其他局的区域名都是“国家”，如国家信访局、国家文物局。</p>
<p>国务院办事机构的区域名都是“国务院”，如国务院法制办、国务院研究室。</p>
<p>区域名为“中国”的国务院机构中，除了央行是国务院组成部门，其他都是国务院事业单位，如中国气象局、中国地震局、中国科学院、中国证监会等。事业单位中，还有少数区域名不是“中国”的，如国家电监会、国研中心等。</p>
<p>国务院系统之外，党委部门区域名一般都是“中央”，人大、政协也有各自的区域名，再有一类就是人民团体，一般而言，区域名为“中华”、“全国”的都是人民团体，如中华全国总工会、中华全国妇女联合会等。</p>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
      </categories>
      <tags>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>残差网络ResNet</title>
    <url>/pub/4f6e26d2/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="越深网络一定越好吗？"><a href="#越深网络一定越好吗？" class="headerlink" title="越深网络一定越好吗？"></a>越深网络一定越好吗？</h2><!-- Is learning better networks as easy as stacking more layers? -->

<p>深层网络会遭遇退化问题(degradation): 随着网络层数的增加，精度会到达饱和区，而后迅速下降。</p>
<p><img title="CIFAR-10上的20层和50层的训练误差(左图)、测试误差(右图)。深层网络竟然会造成更高的训练误差。
with 20-layer and 56-laye" src="/images/raw/NN - Resnet - degradation2.png"></p>
<p>作者在CIFAR-10数据进行实验，采用3x3 卷积层的简单堆叠来测试网络深度的影响。<br>发现当层数增加到20层的时候网络进入饱和区(即使再增加网络的深度，精度也不会提高)。<br>不仅如此，继续增加深度还会导致模型退化，<strong>训练精度</strong>和测试精度迅速下降。<br>这说明当网络变得很深以后，深度网络就变得更加难以训练了。(<strong>注意：这不是过拟合</strong>。过拟合是训练误差小，测试误差大)</p>
<p>随着网络层级的不断增加，模型精度不断得到提升。<br>而当网络层级增加到一定的数目以后，</p>
<blockquote>
<p>“Overly deep” plain nets have higher training error</p>
</blockquote>
<p>【问题来了】为什么随着网络层级越深，训练误差越大了？</p>
<p>从原理上来说其实56层网络的解空间是包括了20层网络的解空间的。<br>换而言之也就是说，56层网络取得的性能应该大于等于20层网络的性能的。但是从训练的迭代过程来看，56层的网络无论从训练误差来看还是测试误差来看，误差都大于20层的网络（这也说明了为什么这不是过拟合现象，因为56层网络本身的<strong>训练误差都没有降下去</strong>）。导致这个原因就是虽然56层网络的解空间包含了20层网络的解空间，但是我们在训练网络用的是随机梯度下降策略，往往解到的不是全局最优解，而是局部的最优解，显而易见<strong>56层网络的解空间更加的复杂，所以导致使用随机梯度下降算法无法解到最优解</strong>。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>如何又能加深网络层数、又能解决梯度消失问题、又能提升模型精度呢？</p>
<blockquote>
<p>那么我们作这样一个假设：假设现有一个比较浅的网络（Shallow Net）已达到了饱和的准确率，这时在它后面再加上几个恒等映射层（Identity mapping，也即y=x，输出等于输入），这样就增加了网络的深度，并且<strong>起码误差不会增加</strong>，也即更深的网络不应该带来训练集上误差的上升。而这里提到的使用恒等映射直接将前一层输出传到后面的思想，便是著名深度残差网络ResNet的灵感来源。</p>
</blockquote>
<p>这里没看懂。恒等映射层是 y=x, 还是y=f(x)+x ?</p>
<h1 id="residual-shortcut-connection"><a href="#residual-shortcut-connection" class="headerlink" title="residual/shortcut connection"></a>residual/shortcut connection</h1><p>shortcut连接有多重形式</p>
<ul>
<li>恒等映射(Identity Mapping)<ul>
<li>无参</li>
<li>有利于模型训练</li>
</ul>
</li>
<li>变换后的映射(Projection Shortcuts)<ul>
<li>A: zero-padding shortcuts are used for increasing dimensions, and all shortcuts are parameterfree</li>
<li>B: projection shortcuts are used for increasing dimensions, and other<br>shortcuts are identity; 论文推荐用这个策略？</li>
<li>C: all shortcuts are projections。</li>
</ul>
</li>
</ul>
<h2 id="恒等映射"><a href="#恒等映射" class="headerlink" title="恒等映射"></a>恒等映射</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">structure:</span> <span class="string">basic-block</span></span><br><span class="line"><span class="attr">shortcut:</span> <span class="string">Identity</span> <span class="string">Mapping</span></span><br></pre></td></tr></table></figure>

<p>Residual Learning</p>
<div style="display:inline;">
<img height="250px" style="margin: 20px;" title="plain net" src="/images/raw/NN - Resnet - plain net.png">
<img height="250px" style="margin: 20px;" title="residual connection" src="/images/raw/NN - Resnet - residual connection.png">
</div>


<ul>
<li>普通网络中：<br>$H(x)$ is any desired mapping,<br>hope the 2 weight layers fit $H(x)$</li>
<li>残差网络：$H(x)$ is any desired mapping,<br>hope the 2 weight layers fit 𝐻(𝑥)<br>hope the 2 weight layers fit $F(x)$<br>let $H(x)=F(x)+x$</li>
</ul>
<blockquote>
<p>resnet中首次提出</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZjaG9sbGV0L2RlZXAtbGVhcm5pbmctbW9kZWxzL2Jsb2IvbWFzdGVyL3Jlc25ldDUwLnB5I0w0Mg==">code-pytorch<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Bottleneck架构"><a href="#Bottleneck架构" class="headerlink" title="Bottleneck架构"></a>Bottleneck架构</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">structure:</span> <span class="string">bottleneck</span></span><br><span class="line"><span class="attr">shortcut:</span> <span class="string">Identity</span> <span class="string">Mapping</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>resnet中首次提出</p>
</blockquote>
<img title="左边是basic block, 右侧是bottleneck block。两者都加入了residual connection。" src="/images/raw/NN - Resnet - bottleneck - xusong.png">

<img title="另外一种画法，强调highway" src="/images/raw/NN - Resnet - bottleneck - wide resnet.png">

<!--
left: basic-block with IdentityMapping; right: bottleneck-block with IdentityMapping
-->

<p>右侧是bottleneck连接，左右两个网络具有相似的复杂度，但是右侧的bottlenect设计能够用于更深层的网络。</p>
<h2 id="conv-as-shortcut"><a href="#conv-as-shortcut" class="headerlink" title="conv as shortcut"></a>conv as shortcut</h2><!-- conv layer at shortcut -->

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">structure:</span> <span class="string">bottleneck</span></span><br><span class="line"><span class="attr">shortcut:</span> <span class="string">conv</span></span><br></pre></td></tr></table></figure>

<p>这里的shortcut不再是恒等映射(identity mapping)，而是采用的conv。</p>
<p>这是对恒等映射的改进吗？相比恒等映射，优势在哪？</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZjaG9sbGV0L2RlZXAtbGVhcm5pbmctbW9kZWxzL2Jsb2IvbWFzdGVyL3Jlc25ldDUwLnB5I0wxMTc=">code-pytorch<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="为什么不能简单地增加网络层数？"><a href="#为什么不能简单地增加网络层数？" class="headerlink" title="为什么不能简单地增加网络层数？"></a>为什么不能简单地增加网络层数？</h2><p>对于原来的网络，如果简单地增加深度，会导致梯度弥散或梯度爆炸。</p>
<blockquote>
<p>对于该问题的解决方法是正则化初始化和中间的正则化层（Batch Normalization），这样的话可以训练几十层的网络。</p>
</blockquote>
<p>虽然通过上述方法能够训练了，但是又会出现另一个问题，就是退化问题，网络层数增加，但是在训练集上的准确率却饱和甚至下降了。这个不能解释为overfitting，因为overfit应该表现为在训练集上表现更好才对。<br>退化问题说明了深度网络不能很简单地被很好地优化。<br>作者通过实验：通过浅层网络+ y=x 等同映射构造深层模型，结果深层模型并没有比浅层网络有等同或更低的错误率，推断退化问题可能是因为深层的网络并不是那么好训练，也就是求解器很难去利用多层网络拟合同等函数。</p>
<h2 id="怎么解决退化问题？"><a href="#怎么解决退化问题？" class="headerlink" title="怎么解决退化问题？"></a>怎么解决退化问题？</h2><p>深度残差网络。如果深层网络的后面那些层是恒等映射，那么模型就退化为一个浅层网络。那现在要解决的就是学习恒等映射函数了。 但是直接让一些层去拟合一个潜在的恒等映射函数H(x) = x，比较困难，这可能就是深层网络难以训练的原因。但是，如果把网络设计为H(x) = F(x) + x,如下图。我们可以转换为学习一个残差函数F(x) = H(x) - x. 只要F(x)=0，就构成了一个恒等映射H(x) = x. 而且，拟合残差肯定更加容易。</p>
<h1 id="维度设计"><a href="#维度设计" class="headerlink" title="维度设计"></a>维度设计</h1><img title="常见的卷积网络架构，厚度代表维度" src="/images/raw/NN - CNN - WHC - cs231n.jpeg">

<ul>
<li><strong>整体架构</strong>: channel数目(depth)逐渐增加，W,H逐渐减小</li>
<li><strong>局部设计</strong>: bottleneck，即降维-&gt;变换-&gt;升维</li>
</ul>
<img title="ResNet的架构(ImageNet)" src="/images/raw/NN - Resnet - architecture.png">


<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thaW1pbmdIZS9kZWVwLXJlc2lkdWFsLW5ldHdvcmtz">官方实现 | KaimingHe caffe<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><strong>keras</strong></p>
<p>强调identity_block，恒等映射</p>
<p><strong>pytorch</strong></p>
<p>强调bottlenect</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvZXhhbXBsZXMvdHJlZS9tYXN0ZXIvaW1hZ2VuZXQ=">resnet示例-pytorch<i class="fa fa-external-link-alt"></i></span><ul>
<li>依赖 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvdmlzaW9uL2Jsb2IvbWFzdGVyL3RvcmNodmlzaW9uL21vZGVscy9yZXNuZXQucHk=">resnet模型-pytorch<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>另外一个resnet版本 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcmFzLXRlYW0va2VyYXMvYmxvYi9tYXN0ZXIva2VyYXMvYXBwbGljYXRpb25zL3Jlc25ldDUwLnB5">https://github.com/keras-team/keras/blob/master/keras/applications/resnet50.py<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvbW9kZWxzL3RyZWUvbWFzdGVyL29mZmljaWFsL3Jlc25ldA==">resnet-tensorflow<i class="fa fa-external-link-alt"></i></span><ul>
<li>提供cifar10 imagenet的示例</li>
</ul>
</li>
</ul>
<h1 id="ResNet可视化"><a href="#ResNet可视化" class="headerlink" title="ResNet可视化"></a>ResNet可视化</h1><!-- 2*2布局 -->
<img title="56层的VGG网络" src="/images/raw/NN - visualization - VGG56.png">
<img title="110层的VGG网络" src="/images/raw/NN - visualization - VGG110.png">
<img title="56层的resnet" src="/images/raw/NN - visualization - resnet56.png">
<img title="121层的resnet" src="/images/raw/NN - visualization - densenet121.png">

<p>来自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudW1kLmVkdS9+dG9tZy9wcm9qZWN0cy9sYW5kc2NhcGVzLw==">https://www.cs.umd.edu/~tomg/projects/landscapes/<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjYyNDE5Mw==">SGD在两层神经网络上是怎么收敛的？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBM016STRNamd6TXc9PSZtaWQ9MjY1MDc0MTIxMSZpZHg9MSZzbj1mYTIyMjlmOTdhNjM5Nzc4NTNkN2ViY2VhNzg1ODA3NiZjaGtzbT04NzFhZGRhNWIwNmQ1NGIzNDM4OWVkYWM4NTVmNTViNDE2M2I4MWZmYzI1YzM4ZjI2Y2MxMmU5OTgyMmQ4N2MzZTI4YzQ1OWQ3OGY5Jm1wc2hhcmU9MSZzY2VuZT0xJnNyY2lkPTA0MjdFbmpKcDFPMTBaeHNWNmNqek40aCZwYXNzX3RpY2tldD14VkQ2dEZNT2NCdU1qMENFQkIySVA5MkErK2tTZ0NRR0VHZFNwRU8wK1ZnTFR6Yy8xOHhuWjZTN2Fsd0dJWGhvI3Jk">ResNet及其多种变体<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lNTg0MzdmMzlmNjU=">https://www.jianshu.com/p/e58437f39f65<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>CNN</category>
      </categories>
  </entry>
  <entry>
    <title>highway network</title>
    <url>/pub/94935b3e/</url>
    <content><![CDATA[<h1 id="identity-mapping-in-resnet"><a href="#identity-mapping-in-resnet" class="headerlink" title="identity mapping in resnet"></a>identity mapping in resnet</h1><p>$$<br>y=H(x,W_H)+x<br>$$</p>
<h1 id="Highway"><a href="#Highway" class="headerlink" title="Highway"></a>Highway</h1><p>所谓Highway网络，无非就是输入某一层网络的数据一部分经过非线性变换，另一部分直接从该网络跨过去<strong>不做任何转换，就像走在高速公路上一样</strong>。<br>而多少的数据需要非线性变换，多少的数据可以直接跨过去，是由一个权值矩阵和输入数据共同决定的。</p>
<p>$$<br>y=H(x,W_H)\bigodot T(x,W_T)+x\bigodot C(x,W_C)<br>$$</p>
<p>highway就是在resnet的基础上<strong>增加了两个gate</strong>。即$T$: transform gate，$C$: carry gate。</p>
<p>为了简便起见，有时候令C=1−T，1 代表了维度和T 一样长的向量。</p>
<p>如果我们想更改x的维度从A变成B的话，一种方法是采用zero-padding和下采样的方法，或者是引入一个维度为A*B的变换矩阵，使每次都乘上这个矩阵。</p>
<p>主要解决的是多层深度神经网络的训练收敛问题，即使层数很多也可以使用简单的方法比方说 backpropogation来进行训练，保证合理的迭代范围内收敛，而传统的网络是很难保证收敛的。</p>
<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><blockquote>
<p>A highway layer can smoothly vary its behavior between that of a plain layer and that of a layer which simply passes its inputs through.</p>
</blockquote>
<p>也就是说Highway也就是让输入数据的一部分变换，另一部分直接通过，相当于整体上来讲在这两者的效果中选了一个均衡。</p>
<p>从广义的角度来说，Highway更像是一种思想，它不但可以用在全连接网络中，也可以用在卷积神经网络中，原文里说：“Convolutional highway layers are constructed similar to fully connected layers. Weight-sharing and local receptive fields are utilized for both H and T transforms. We use zero-padding to ensure that the block state and transform gate feature maps are the same size as the input.”。</p>
<p>其实深度残差网络和Highway网络这两种网络结构都能够让一部分的数据可以跳过某些变换层，而直接到后面的层中去，只不过Highway网络需要一个权值来控制每次直接通过的数据量，而深度残差网络就直接让一部分数据通到了后面。从大量的实验中，我感觉这两种网络只有在很深的场景中才能发挥出“威力”，如果本身网络层数较浅，勉强使用这两种结构是很难得到好的结果的。</p>
<p>highway network很大程度借鉴了LSTM的长期短期记忆的门机制的一些思想，使得网络在很深都可以学习！</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>ResNet可以被看作是Highway Network的一个特例。</p>
<p>ResNet并不是第一个利用shortcut connection的，Highway Network[5]引入了“gated shortcut connection”，其中带参数的gate控制了shortcut中可通过的信息量。类似的做法也存在于LSTM[6]单元里，在LSTM单元中也有一个forget gate来控制着流入下一阶段的信息量。因此，ResNet可以被看作是Highway Network的一个特例。然而实验结果显示，Highway Network的表现并不比ResNet要出色。这个结果似乎有些奇怪，因为Highway Network的解空间（solution space）中包含了ResNet，所以它的性能表现按理来说应该要比ResNet好的。这就表明保持这些“梯度高速路”的畅通可能比追求更大的解空间更重要。</p>
<p>照着这一想法，文章的作者们进一步完善了残差块，并且提出了一个残差块的pre-activation变体，梯度可以在这个变体中通过shortcut无阻碍地传播到前面的任何一层。实际上，利用[2]中的原始残差块，训练后1201层ResNet的性能比110层的ResNet的性能要差。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lOTZiNDczOTI2ZWQ=">https://www.jianshu.com/p/e96b473926ed<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3l1aGFvYWFhL2FydGljbGUvZGV0YWlscy81NDA5MzkxMw==">https://blog.csdn.net/guoyuhaoaaa/article/details/54093913<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>CNN</category>
      </categories>
  </entry>
  <entry>
    <title>RNN研究现状以及发展趋势，LSTM的变种 (variants of LSTM)</title>
    <url>/pub/7f7eb3f4/</url>
    <content><![CDATA[<p>训练算法，如Back Propagation Through Time(BPTT)、Real-time Recurrent Learning(RTRL)、Extended Kalman Filter(EKF)等学习算法，以及梯度消失问题(vanishing gradient problem)</p>
<ol start="3">
<li>详细介绍Long Short-Term Memory(LSTM，长短时记忆网络)；</li>
<li>详细介绍Clockwork RNNs(CW-RNNs，时钟频率驱动循环神经网络)；</li>
<li>基于Python和Theano对RNNs进行实现，包括一些常见的RNNs模型。</li>
</ol>
<h1 id="GRU-gated-recurrent-unit"><a href="#GRU-gated-recurrent-unit" class="headerlink" title="GRU - gated recurrent unit"></a>GRU - gated recurrent unit</h1><p>It combines the forget and input gates into a single “update gate.” It<br>also merges the cell state and hidden state, and makes some other changes. The resulting model is simpler than<br>standard LSTM models, and has been growing increasingly popular.</p>
<h1 id="SRNN"><a href="#SRNN" class="headerlink" title="SRNN -"></a>SRNN -</h1><p>上海交通大学的Zeping Yu 和Gongshen Liu，在论文“Sliced Recurrent Neural Networks”中，提出了全新架构“切片循环神经网络”（SRNN）。SRNN可以通过将序列分割成多个子序列来实现并行化。SRNN能通过多个层获得高级信息，而不需要额外的参数。</p>
<h1 id="SRU-simple-recurrent-unit"><a href="#SRU-simple-recurrent-unit" class="headerlink" title="SRU - simple recurrent unit"></a>SRU - simple recurrent unit</h1><h1 id="lightRNN"><a href="#lightRNN" class="headerlink" title="lightRNN"></a>lightRNN</h1><h1 id="autoML"><a href="#autoML" class="headerlink" title="autoML"></a>autoML</h1><p> Architecture Search</p>
<p>LSTM initialized with a large positive forget gate bias<br>outperformed both the basic LSTM and the GRU!</p>
<p>Gradients will vanish if f is close to 0. Using a large positive bias<br>ensures that f has values close to 1, especially when training begins.<br>牛逼</p>
<p>An empirical exploration of recurrent network architectures, ICML 2015</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
  </entry>
  <entry>
    <title>【深度学习-RNN系列】递归神经网络 RNN (从HMM到RNN)</title>
    <url>/pub/d66c7262/</url>
    <content><![CDATA[<blockquote>
<p>递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），另一种是结构递归神经网络（recursive neural network）。<br>时间递归神经网络的神经元间连接构成矩阵，而结构递归神经网络利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。单纯递归神经网络因为无法处理随着递归，权重指数级爆炸或消失的问题（Vanishing gradient problem），难以捕捉长期时间关联；而结合不同的LSTM可以很好解决这个问题。<br>—— 维基百科</p>
</blockquote>
<p>其他翻译</p>
<ul>
<li>recurrent：“循环神经网络”</li>
<li>recursive 递归神经网络</li>
<li>feedforward</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>RNN解决了HMM的</li>
<li>双向RNN解决了上下文依赖问题</li>
<li>LSTM解决了RNN训练中梯度消失和梯度爆炸的问题</li>
<li>GRU取消了LSTM中的cell，结构上更加简单，在性能上，训练时间更短，epoch更小的情况下可以收敛。</li>
</ul>
<h2 id="序列建模的发展史"><a href="#序列建模的发展史" class="headerlink" title="序列建模的发展史"></a>序列建模的发展史</h2><ul>
<li>Memoryless models for sequences</li>
<li>Markov:  bi-gram, tri-gram, n-gram<ul>
<li>严格的独立性假设条件，<strong>无法建模任意长度的上下文信息</strong>。</li>
<li>n-gram矩阵太大，太稀疏，(2-gram也很大很稀疏)。怎样解决？词典大小$V$，</li>
<li>详见HMM博客</li>
</ul>
</li>
<li>HMM</li>
<li>RNN<ul>
<li>HMM转移概率矩阵太大，这里可以认为是对其降维。</li>
</ul>
</li>
<li>LSTM</li>
</ul>
<p><strong>RNN与HMM</strong></p>
<p>基本结构上是挺像的，都是通过hidden state 的演化来刻画 序列间的依赖关系</p>
<p>RNN与HMM的本质区别是RNN没有马尔科夫假设，可以考虑很长的历史信息。</p>
<ol>
<li>隐状态的表示: hmm是onehot, RNN是分布表示，RNN的表示能力强很多，或者说在面对高维度时，表示效率更高。类似nlp里，对单个token的表示，一种是onehot, 一种是word vector 。</li>
<li>隐状态的演化方式: hmm是线性的，RNN是高度非线性。</li>
<li>在垂直方向上，实际中的lstm还会增加depth, 来增加不同层面的抽象表示，也会使得表示能力指数增加，随着depth 增加。</li>
</ol>
<p>RNN也是基于马尔可夫假设的，当前的隐状态仅依赖前一个时刻的隐状态。在有马尔可夫假设的模型中，不代表距离超过1的两个状态是无依赖的。</p>
<p>印象中有paper证明， 在HMM中两个状态的依赖关系随距离指数衰减，而在RNN中是power law decay.  也就是大家通常说的 rnn可以略好的刻画 long term dependency.</p>
<p>另，SLAM中还有种算法跟hmm类似，kalman filter.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU3Mzk2NDQzL2Fuc3dlci8yNjMwMTk3MDI=">https://www.zhihu.com/question/57396443/answer/263019702<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="RNN-Overview"><a href="#RNN-Overview" class="headerlink" title="RNN Overview"></a>RNN Overview</h2><ul>
<li>狭义上的RNN，指vanilla RNN。</li>
<li>广义上的RNN，lstm gru等都属于RNN框架。</li>
</ul>
<p>该文章针对广义上的RNN。</p>
<p>RNN的核心思想就是利用当前时刻的输入$X_t$和上一时刻的隐状态$h_{t-1}$来计算$h_t$:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">out, hidden = lstm(<span class="built_in">input</span>, hidden)  <span class="comment"># 来自pytorch的抽象</span></span><br></pre></td></tr></table></figure>
<p>$$ h_t = f(x_t, h_{t-1}) $$</p>
<p>针对不同的任务又有不同的RNN形式<br><image title="RNN的不同展开形式" src="/images/raw/NN - RNN - overview.png" ></p>
<p>大部分应用都可归入该框架。具体的应用可参考<span class="exturl" data-url="aHR0cDovL2thcnBhdGh5LmdpdGh1Yi5pby8yMDE1LzA1LzIxL3Jubi1lZmZlY3RpdmVuZXNzLw==">karpathy<i class="fa fa-external-link-alt"></i></span></p>
<!-- 框架之外的模型: attention -->


<p>名词解释:</p>
<ul>
<li>hidden 也叫cell, hidden_state, cell_state。它是forget的关键</li>
<li>out 也叫 output，</li>
<li>hidden</li>
<li>cell</li>
<li>output在stack RNN中也叫hidden</li>
</ul>
<p>output = new_state =</p>
<p>Most basic RNN:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">output = new_state = act(W * <span class="built_in">input</span> + U * state + B)</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucXVvcmEuY29tL0hvdy1pcy10aGUtaGlkZGVuLXN0YXRlLWgtZGlmZmVyZW50LWZyb20tdGhlLW1lbW9yeS1jLWluLWFuLUxTVE0tY2VsbA==">https://www.quora.com/How-is-the-hidden-state-h-different-from-the-memory-c-in-an-LSTM-cell<i class="fa fa-external-link-alt"></i></span></p>
<p>vanilla RNN中没有cell，所以hidden=cell=out<br>LSTM中</p>
<h2 id="RNN的高层抽象"><a href="#RNN的高层抽象" class="headerlink" title="RNN的高层抽象"></a>RNN的高层抽象</h2><blockquote>
<p>抽象不是实现，是API。由整体到局部，可把RNN当做一个黑盒子，有需求的情况下再细看其具体实现。</p>
</blockquote>
<h3 id="keras的RNN抽象"><a href="#keras的RNN抽象" class="headerlink" title="keras的RNN抽象"></a>keras的RNN抽象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.layers.RNN(cell, return_sequences=<span class="literal">False</span>, return_state=<span class="literal">False</span>, go_backwards=<span class="literal">False</span>, stateful=<span class="literal">False</span>, unroll=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># return_sequences: 是否返回整个序列out</span></span><br><span class="line"><span class="comment"># return_state: 是否返回整个序列的hidden</span></span><br></pre></td></tr></table></figure>


<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlcmFzLXRlYW0va2VyYXMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvaW1kYl9sc3RtLnB5I0w0MQ==">应用示例–lstm用于二分类<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(num_words, <span class="number">128</span>))  <span class="comment"># 输入整个sequence</span></span><br><span class="line">model.add(LSTM(<span class="number">128</span>, dropout=<span class="number">0.2</span>, recurrent_dropout=<span class="number">0.2</span>)) <span class="comment"># 输出最后一个cell的output</span></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)) <span class="comment"># 二分类</span></span><br></pre></td></tr></table></figure>
<p>这是上图中的<code>many to one</code>模式。</p>
<ul>
<li>关于</li>
<li>关于静态图：sequence的数目固定为80</li>
</ul>
<details>
  <summary>[应用示例--基于lstm的seq2seq](https://github.com/keras-team/keras/blob/master/examples/lstm_seq2seq.py)</summary>
  <div>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define an input sequence and process it.</span></span><br><span class="line">encoder_inputs = Input(shape=(<span class="literal">None</span>, num_encoder_tokens))</span><br><span class="line">encoder = LSTM(latent_dim, return_state=<span class="literal">True</span>)</span><br><span class="line">encoder_outputs, state_h, state_c = encoder(encoder_inputs)</span><br><span class="line"><span class="comment"># We discard `encoder_outputs` and only keep the states.</span></span><br><span class="line">encoder_states = [state_h, state_c]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the decoder, using `encoder_states` as initial state.</span></span><br><span class="line">decoder_inputs = Input(shape=(<span class="literal">None</span>, num_decoder_tokens))</span><br><span class="line"><span class="comment"># We set up our decoder to return full output sequences,</span></span><br><span class="line"><span class="comment"># and to return internal states as well. We don&#x27;t use the</span></span><br><span class="line"><span class="comment"># return states in the training model, but we will use them in inference.</span></span><br><span class="line">decoder_lstm = LSTM(latent_dim, return_sequences=<span class="literal">True</span>, return_state=<span class="literal">True</span>)</span><br><span class="line">decoder_outputs, _, _ = decoder_lstm(decoder_inputs,</span><br><span class="line">                                     initial_state=encoder_states)</span><br><span class="line">decoder_dense = Dense(num_decoder_tokens, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">decoder_outputs = decoder_dense(decoder_outputs)</span><br></pre></td></tr></table></figure>
  <div>
</details>

<details>
  <summary>[应用示例--基于lstm的attention-seq2seq](https://github.com/keras-team/keras/blob/master/examples/lstm_seq2seq.py)</summary>
  <p><code>
  </code></p>
</details>


<p>keras是对整个sequence做的抽象。因为keras是面向tensorflow和theano的静态图做的封装。</p>
<h3 id="pytorch的RNN抽象"><a href="#pytorch的RNN抽象" class="headerlink" title="pytorch的RNN抽象"></a>pytorch的RNN抽象</h3><p>应用示例–基于lstm的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for a sequence inputs</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">input</span> <span class="keyword">in</span> inputs:</span><br><span class="line">  <span class="comment"># Step through the sequence one element at a time</span></span><br><span class="line">  out, hidden = lstm(<span class="built_in">input</span>, hidden)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output, (h_n, c_n) = lstm(<span class="built_in">input</span>, (h_0, c_0))</span><br></pre></td></tr></table></figure>
<p>pytorch是动态图，会随着inputsequence</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvcHl0b3JjaC9ibG9iL21hc3Rlci90b3JjaC9ubi9tb2R1bGVzL3Jubi5weSNMMzQ2">源码实现<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="tensorflow的抽象"><a href="#tensorflow的抽象" class="headerlink" title="tensorflow的抽象"></a>tensorflow的抽象</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvdHV0b3JpYWxzL3JlY3VycmVudA==">示例–基于lstm的语言模型<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</span><br><span class="line">output, state = lstm(words, state) <span class="comment"># 这里的输入和输出都是符号，类型是tf.placeholder，lstm参数是tf.variable</span></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi9vcHMvcm5uX2NlbGxfaW1wbC5weSNMNDc2">BasicLSTMCell源码<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="基于RNN的变形（mainstream-variation）"><a href="#基于RNN的变形（mainstream-variation）" class="headerlink" title="基于RNN的变形（mainstream variation）"></a>基于RNN的变形（mainstream variation）</h2><h3 id="cell"><a href="#cell" class="headerlink" title="cell"></a>cell</h3><h3 id="cascade-rnn"><a href="#cascade-rnn" class="headerlink" title="cascade rnn"></a>cascade rnn</h3><p>char-rnn + word rnn (Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation)<br>char-cnn + word rnn (Exploring the Limits of Language Modeling)</p>
<h2 id="sequence-labeling"><a href="#sequence-labeling" class="headerlink" title="sequence labeling"></a>sequence labeling</h2><p>Part-of-speech Tagging</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><h2 id="rnn-new-trends"><a href="#rnn-new-trends" class="headerlink" title="rnn new trends"></a>rnn new trends</h2><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><p>recurrent highway network</p>
<h1 id="框架-总结"><a href="#框架-总结" class="headerlink" title="框架 总结"></a>框架 总结</h1><p><code>Sequence Modeling</code>按照架构一般分为：</p>
<ol>
<li>Encoder 架构<ul>
<li>Sequence Classification</li>
<li>Sequence Labeling/Prediction</li>
</ul>
</li>
<li>Deep Encoder 架构</li>
<li>Encoder – Decoder 架构<br><br>其中input和output都是sequence的架构，又叫<code>seq2seq</code><ul>
<li><strong>encoder</strong>:<ul>
<li>CNN：图片一般采用CNN，文本也可以采用CNN</li>
<li>RNN:</li>
</ul>
</li>
<li><strong>decoder</strong>:<ul>
<li><strong>simple decoder</strong>: 通常是LSTM作为解码器[^seq2seq-NN][^seq2seq-MT][^seq2seq-Conversation]. encodes the “meaning” of the input sequence into a single vector of a fixed dimensionality. Then another deep LSTM to decode the target sequence from the vector. (only last output of the encoder. This last output is sometimes called the <code>context vector</code> as it encodes context from the entire sequence.<br>map the input sequence)<br><br><strong>缺陷</strong>：只用了一个vector(<code>context vector</code>)表征输入序列压力太大(it carries the burden of encoding the entire sentence).<br><br><strong>解决</strong>: 整个序列都用<br><br> 1. 一个简单的方式是<span class="exturl" data-url="aHR0cDovL2RlZXBsZWFybmluZy5uZXQvdHV0b3JpYWwvbHN0bS5odG1s">对序列vector取均值<i class="fa fa-external-link-alt"></i></span>，高大上点叫<code>mean pooling</code><br><br> 2. 对序列vector线性加权。难点：加权系数怎么来？因为这是不定长序列，不能像DNN那样放一个全连接参数W让模型去学。于是就出现了attention，以及self-attention。</li>
<li><strong>attention decoder</strong>: LSTM+attention<br><br> The decoder decides parts of the source sentence to pay attention to.<br><br> It relieves the encoder from the burden of having to encode all information in the source sentence into a fixedlength vector.<br>
Attention allows the decoder network to “focus” on a different part of the encoder’s outputs for every step of the decoder’s own outputs. First we calculate a set of `attention weights`.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>列个表，input和output</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[^RNN]: <span class="exturl" data-url="aHR0cDovL2thcnBhdGh5LmdpdGh1Yi5pby8yMDE1LzA1LzIxL3Jubi1lZmZlY3RpdmVuZXNzLw==">The Unreasonable Effectiveness of Recurrent Neural Networks<i class="fa fa-external-link-alt"></i></span><br>[^seq2seq-NN]: <span class="exturl" data-url="aHR0cDovL3BhcGVycy5uaXBzLmNjL3BhcGVyLzUzNDYtc2VxdWVuY2UtdG8tc2VxdWVuY2UtbGVhcm5pbmctd2l0aC1uZXVyYWwtbmV0d29ya3MucGRm">Sequence to Sequence Learning with Neural Networks | nips 2014<i class="fa fa-external-link-alt"></i></span><br>[^seq2seq-MT]: <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE0MDYuMTA3OA==">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation | EMNLP 2014<i class="fa fa-external-link-alt"></i></span><br>[^seq2seq-Conversation]: <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE1MDYuMDU4Njk=">A Neural Conversational Model<i class="fa fa-external-link-alt"></i></span><br>[]: <span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1Nekl3T1RjMk1UVXlNZz09Jm1pZD0yMjQ3NDg0MDI5JmlkeD0xJnNuPWM5M2I1ZWRkZWMzM2RjMjlkYzE3MmE1ZWEwZDc2ODIyJmNoa3NtPTk3NmZhN2UwYTAxODJlZjYxZTM2ZDFjMzJhYTA3MDZjNGU4MWUxNzYyYTdlZTI1NTQxNjViZWVjZGU5MjliNzJjZjAyNmM1YjdhNjQmbXBzaGFyZT0xJnNjZW5lPTIzJnNyY2lkPTA1MDNxemJKZXEwUUIwZWlabzB2QW5NciNyZA==">吴恩达《序列模型》精炼笔记 – 循环神经网络（RNN）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
      <tags>
        <tag>rnn</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【RNN系列】GRU简介 &amp; 源码实现</title>
    <url>/pub/c79f2f90/</url>
    <content><![CDATA[<p>LSTM 计算较为复杂，参数也非常多，难以训练。GRU（Gated Recurrent Units）应运而生。</p>
<h1 id="GRU的简化思想"><a href="#GRU的简化思想" class="headerlink" title="GRU的简化思想"></a>GRU的简化思想</h1><table border="1"><tbody><tr><td width="50%"><image title="LSTM的结构" src="/images/raw/NN - RNN - LSTM - tensorflow with Equation 2 - colah.png"></td><td width="50%"><img title="GRU的结构" src="/images/raw/NN - RNN - GRU with Equation - colah.png"></td></tr></tbody></table>

<ol>
<li><strong>合并输入门i与遗忘门f</strong>: 合并为<code>update gate</code>，即图中的z</li>
<li><strong>合并c和h</strong>: 合并为 h</li>
<li><strong>新增重置门</strong>: 即图中的r</li>
<li>去掉输出门</li>
</ol>
<p><strong>看图，对比公式</strong></p>
<ol>
<li>对比LSTM中的 $j$ 和GRU中的 $\tilde{h}_{t}$ ，GRU中多了个重置门</li>
<li>对比LSTM中的 $c_ {t}$ 和GRU中的 $h_ {t}$ ，注意gate的耦合</li>
</ol>
<h2 id="i与f的合并"><a href="#i与f的合并" class="headerlink" title="i与f的合并"></a>i与f的合并</h2><p>门控信号越接近1，代表”记忆“下来的数据越多；而越接近0则代表”遗忘“的越多。</p>
<blockquote>
<p>Instead of separately deciding what to forget and what we<br>should add new information to, we make those decisions together. We only forget when we’re going to input something<br>in its place.</p>
</blockquote>
<p>这里的遗忘 $z$ 和选择 $(1-z)$ 是联动的。也就是说，对于传递进来的维度信息，我们会进行选择性遗忘，则遗忘了多少权重 $z$，我们就会使用包含当前输入的 $h’$ 中所对应的权重进行弥补 $1-z$ 。以保持一种”恒定“状态。</p>
<p>二值化的更新门z，类似电路里的<code>单刀双掷开关</code>。</p>
<table border="1"><tbody><tr><td><img title="LSTM简图" src="/images/raw/NN - RNN - LSTM - simple diagram.png"></td><td><img title="GRU简图：更新门z类似单刀双掷开关，控制两路；重置开关r控制上一个隐状态h" src="/images/raw/NN - RNN - GRU - simple diagram.png"></td></tr></tbody></table>



<h2 id="reset-gate的作用"><a href="#reset-gate的作用" class="headerlink" title="reset gate的作用"></a>reset gate的作用</h2><p>$r_t$用来控制需要 保留多少之前的记忆，如果$r_t$为0，那么h̃ t只包含当前词的信息。</p>
<p>reset gate实际上与他的名字有点不符。我们仅仅使用它来获得了 $h’$ 。</p>
<p>如果reset gate接近0，那么之前的隐藏层信息$h_{t-1}$就会丢弃，允许模型丢弃一些和未来无关的信息。</p>
<blockquote>
<p>我觉得z也能起到丢弃$h_{t-1}$的作用，为什么非要加个r呢？</p>
</blockquote>
<p> 一般来说那些具有短距离依赖的单元reset gate比较活跃（如果$r_t$为1，而$z_t$为0 那么相当于变成了一个标准的RNN，能处理短距离依赖），具有长距离依赖的单元update gate比较活跃。</p>
<h2 id="c和h的合并"><a href="#c和h的合并" class="headerlink" title="c和h的合并"></a>c和h的合并</h2><p>$z_t$ 控制需要从前一时刻的隐藏层$h_{t−1}$中遗忘多少信息，<br>需要加入多少当前 时刻的隐藏层信息$\tilde{h}_t$，最后得到$h_t$。<br>直接得到最后输出的隐藏层信息，这里与LSTM的区别是GRU中没有<code>output gate</code>：</p>
<p>$$<br>h_t=z_t\circ h_{t-1} + (1-z_t)\circ \tilde{h}_t<br>$$</p>
<h1 id="疑问环节"><a href="#疑问环节" class="headerlink" title="疑问环节"></a>疑问环节</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>LSTM中也有gate，为什么GRU的命名里更强调<code>gated</code>这个词？</p>
<p>是不是因为想摆脱与LSTM的关系，强调与RNN的关系？比如</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>看电路图，或者公式。$h_{t-1}$ 要依次经过$z$和$r$两道开关，这样的信息流设计思想是什么？只用一个$z$有什么毛病吗，即r恒为1会怎样？</p>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>如何通过开关，实现长时间记忆、短时间记忆？</p>
<image title="LSTM的长时间记忆(long memory)" width="50%" src="/images/raw/NN - RNN - LSTM - preservation of gradient - alex.png">

<p><strong>长记忆</strong>: <code>r=z=0</code>，实现长依赖，即简图中z打向左边。实现了信息的长久保持，但问题是，缺少了输出门，不能控制输出啊</p>
<blockquote>
<p>若$z_t$接近1相当于我们之前把之前的隐藏层信息拷贝到当前时刻，可以学习长距离依赖。</p>
</blockquote>
<p>并不是这样吧，能不能长距离依赖，要同时取决于z和r吧。</p>
<p><strong>短依赖</strong>:</p>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><ul>
<li>百度的Deep speech2</li>
</ul>
<h1 id="GRU的实现源码"><a href="#GRU的实现源码" class="headerlink" title="GRU的实现源码"></a>GRU的实现源码</h1><h2 id="GRU-tensorflow"><a href="#GRU-tensorflow" class="headerlink" title="GRU-tensorflow"></a>GRU-tensorflow</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, inputs, state</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Gated recurrent unit (GRU) with nunits cells.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  gate_inputs = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, state], <span class="number">1</span>), self._gate_kernel)</span><br><span class="line">  gate_inputs = nn_ops.bias_add(gate_inputs, self._gate_bias)</span><br><span class="line"></span><br><span class="line">  value = math_ops.sigmoid(gate_inputs)</span><br><span class="line">  r, u = array_ops.split(value=value, num_or_size_splits=<span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  r_state = r * state</span><br><span class="line"></span><br><span class="line">  candidate = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, r_state], <span class="number">1</span>), self._candidate_kernel)</span><br><span class="line">  candidate = nn_ops.bias_add(candidate, self._candidate_bias)</span><br><span class="line"></span><br><span class="line">  c = self._activation(candidate)</span><br><span class="line">  new_h = u * state + (<span class="number">1</span> - u) * c</span><br><span class="line">  <span class="keyword">return</span> new_h, new_h</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE0MDYuMTA3OA==">Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation, 2014<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE0MTIuMzU1NQ==">Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b3dhcmRzZGF0YXNjaWVuY2UuY29tL2xlY3R1cmUtZXZvbHV0aW9uLWZyb20tdmFuaWxsYS1ybm4tdG8tZ3J1LWxzdG1zLTU4Njg4ZjFkYTgzYQ==">Evolution: from vanilla RNN to GRU &amp; LSTMs<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NvbGFoLmdpdGh1Yi5pby9wb3N0cy8yMDE1LTA4LVVuZGVyc3RhbmRpbmctTFNUTXMv">Understanding LSTM Networks | colah<i class="fa fa-external-link-alt"></i></span></li>
<li><a href=".">CS224d</a></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
      <tags>
        <tag>rnn</tag>
        <tag>deep learning</tag>
        <tag>gru</tag>
      </tags>
  </entry>
  <entry>
    <title>准RNN Quasi-recurrent Neural Networks</title>
    <url>/pub/ab77a378/</url>
    <content><![CDATA[<p>QRNN 是 Salesforce Research 团队（Update: 官方pytorch实现）提出的一种使用卷积操作替代传统的循环结构（vanilla RNN, LSTM, GRU）的新网络结构。<br>QRNN 可以视为介于 RNN 和 CNN 之间的特殊结构。<br>由于卷积操作没有循环结构时间上的依赖性，因此，QRNN 的计算并行度高；在训练时，卷积结构也要比循环结构更稳定。因此 ，QRNN 是一种潜在有用的网络，可以 drop-in 地替代各种 RNN。</p>
<h1 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h1><p>RNN 在计算时，有时间的依赖性，并行度受限；而 CNN 受制于有限的 receptive field，因此，信息传递太慢。QRNN 希望能综合RNN和CNN的优点，尽量避免各自的缺陷。</p>
<!-- CNN + RNN 不就行了。如果嫌计算量大，可以先降维，再RNN -->


<h1 id="model"><a href="#model" class="headerlink" title="model"></a>model</h1><p>$$<br>\mathbf{Z} = \tanh(\mathbf{W} _ z * \mathbf{X})<br>$$</p>
<p>$$<br>\mathbf{F} = \sigma(\mathbf{W} _ f * \mathbf{X})<br>$$<br>$$<br>\mathbf{O} = \sigma(\mathbf{W} _ o * \mathbf{X})<br>$$</p>
<p>其中 <code>∗</code> 表示1维卷积操作。显然，这一步操作是没有时序上的依赖的。</p>
<!-- 1维卷积，不就是普通的w映射吗，-->

<p>为建模时序关系，不同时刻 memory 更新如下：</p>
<p>$$ a_{r-2} \mathbf{c}_{t-1} $$<br>$$<br>\mathbf{c}_t = \mathbf{f}_t \odot \mathbf{c} _ {t - 1} + (1 - \mathbf{f} _ t) \odot \mathbf{z} _ t<br>$$</p>
<ol>
<li>仍然保留c和h</li>
<li>。</li>
</ol>
<h2 id="fo-Pool"><a href="#fo-Pool" class="headerlink" title="fo-Pool"></a>fo-Pool</h2><ol>
<li>Mixture of Softmax + QuasiRNN/SRU进行加速</li>
<li>Adaptive Softmax + SRU, 效果较差，(也许是tensorflow的实现有问题，尚未检查)</li>
</ol>
<p>下周计划</p>
<ol>
<li>Adaptive Softmax + SRU/QRNN</li>
<li>初步在sogou数据上验证效果</li>
<li>使用tensorRT 对inference加速</li>
</ol>
<h2 id="dynamic-average-pooling"><a href="#dynamic-average-pooling" class="headerlink" title="dynamic average pooling"></a>dynamic average pooling</h2><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>Quasi-RNN的核心是在 k-gram CNN（文本卷积）的基础上使用 adaptive gating。<br>在讨论k-gram卷积的时候，通常不会使用k=1既 window size 1作为运行参数。这点在包括Q-RNN本身的许多论文中都有体现 。</p>
<p>SRU中的矩阵变换虽然可以看做 k=1的情况，但这跟声称“所有前馈神经网络（fast forward network）都是 k=1 卷积” 或者 “VGG net 和 GoogLeNet 是 AlexNet 改成3*3卷积然后加深度”没有本质差别。<br>3卷积然后加深度”没有本质差别。</p>
<h1 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h1><h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><p>Variational inference–based dropout</p>
<p>卧槽，这么高级。</p>
<h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><h2 id="Encoder–Decoder-架构"><a href="#Encoder–Decoder-架构" class="headerlink" title="Encoder–Decoder 架构"></a>Encoder–Decoder 架构</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5NjE4NTYvYXJ0aWNsZS9kZXRhaWxzLzc3NDMxODY5">https://blog.csdn.net/u011961856/article/details/77431869<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2NjUwMTMvYXJ0aWNsZS9kZXRhaWxzLzgxOTExODUw">https://blog.csdn.net/u014665013/article/details/81911850<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5VGludGluL2FydGljbGUvZGV0YWlscy83Nzk0NTM1NA==">https://blog.csdn.net/JackyTintin/article/details/77945354<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDIuMDc4MjU=">Deep Voice<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDUuMDg5NDc=">Deep Voice 2<i class="fa fa-external-link-alt"></i></span> 利用 QRNN 做 TTS 系统前端的韵律预测</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
  </entry>
  <entry>
    <title>【RNN系列】SRU</title>
    <url>/pub/3a02a648/</url>
    <content><![CDATA[<p>RNN、LSTM、GRU都存在一个严重的问题: 前后两个时刻 $t-1$ 和 $t$ 的计算存在完全的依赖性。这种自回归结构无法并行，不能充分利用GPU计算资源。</p>
<blockquote>
<p>the sequential dependencies that are central to recurrent architectures limit parallelization potential</p>
</blockquote>
<table border="1"><tbody><tr><td width="50%"><image title="LSTM的结构" src="/images/raw/NN - RNN - LSTM - tensorflow with Equation 2 - colah.png"></td><td width="50%"><img title="GRU的结构" src="/images/raw/NN - RNN - GRU with Equation - colah.png"></td></tr></tbody></table>


<blockquote>
<p>GRU对LSTM进行了简化，详见<a href="/pub/c79f2f90">GRU</a>。</p>
</blockquote>
<p>注意观察$c _  {t-1} $ 和 $ h _  {t-1}$的流向。很容易发现，这两个信息几乎影响每一个节点，因此LSTM和GRU是严重的autoregressive，严重的时序依赖。</p>
<p>如何加速？一个自然的思路: 能否尽量减少$t-1$时刻的影响，<strong>剥离出时序无关的计算</strong>，类似以下的架构:</p>
<img title="左图: 传统RNN的全部计算量(灰色块)完全依赖上一时刻，这极大阻碍计算的并行化；右图: 对大量计算取消了时序依赖(大灰块)，仅保留了轻量级的时序依赖(小灰块)" src="/images/raw/NN - RNN - LSTM VS SRU.png">


<p>具体怎么做呢？比如我们大开脑洞，把LSTM中的$h_{t-1}$直接去掉，豁然开朗，下面的都能并行了。(当然脑洞太大往往不靠谱，也许把孩子和洗脚水一起丢了)</p>
<p>如何既能并行，又尽量少的损失时序信息？SRU是这样做的。</p>
<h1 id="SRU"><a href="#SRU" class="headerlink" title="SRU"></a>SRU</h1><p>SRU（Simple Recurrent Unit）则提出更激进的架构，去掉了前后时刻计算的依赖。</p>
<!-- Removing the dependencies between time steps -->

<img title="SRU结构，来自知乎XXYY" src="/images/raw/NN - RNN - SRU.jpg">


<ul>
<li><strong>核心一</strong>: 门$f$不再依赖$t-1$了</li>
<li><strong>核心二</strong>: 门</li>
<li>input gate和forget gate的合并 (借鉴自GRU)</li>
<li>c和h的合并，(并未采用)</li>
<li>宏观上，类似window_size=1的QRNN</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img title="SRU 相比 cuDNN LSTM
训练提速超过 10 倍" src="/images/raw/NN - RNN - SRU - performance.png"></p>
<h1 id="实现细节（trick）"><a href="#实现细节（trick）" class="headerlink" title="实现细节（trick）"></a>实现细节（trick）</h1><p>SRU实现：增加highway连接和变分dropout</p>
<p>首先，他们在循环层之间增加了highway连接，因为此前的研究已经证明，像highway连接这样的skip connections，在训练深度网络时非常有效；</p>
<p>其次，在将RNN正则化时，SRU在标准的dropout外，增加了变分dropout，变分dropout在时间步长t与dropout使用相同的mask。</p>
<p>什么是</p>
<h2 id="CUDA级的优化"><a href="#CUDA级的优化" class="headerlink" title="CUDA级的优化"></a>CUDA级的优化</h2><p>。。。待看</p>
<h1 id="吐槽环节"><a href="#吐槽环节" class="headerlink" title="吐槽环节"></a>吐槽环节</h1><p><strong>关于架构</strong></p>
<ol>
<li>SRU就是QRNN的window_size=1的特例 - Richard Socher (是哎，我也跟着起哄)</li>
<li>autoregressive CNNs with gated incremental pooling perform comparably to RNNs</li>
</ol>
<!--
SRU加速的是training阶段，无法对autoregressive的decoding阶段加速。有一系列针对decoding的加速
-->

<p><strong>关于gate</strong></p>
<ol>
<li>gate的开关只取决于当前输入，不靠谱吧？</li>
</ol>
<h1 id="疑问环节"><a href="#疑问环节" class="headerlink" title="疑问环节"></a>疑问环节</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>图三中，既然要剥离出时序无关的计算，<strong>为什么不把时序无关的计算剥离出RNN作为独立的layer？</strong></p>
<p>可以</p>
<p>SRU等价于: x -&gt; <code>fork layer</code> -&gt; RNN</p>
<p><code>fork layer</code>: 同时映射(W)和分流(分到不同的gate，不同的作用)。<br>(类似transformer中的multi-head)。<br>具体实现: $x’ = Wx$，然后split，然后分工，不同的gate，可以group gate。</p>
<!-- 注意fork和split的区别 -->

<p>LSTM自身也可以视为 x -&gt; <code>fork layer</code> -&gt; 时序依赖。详见cudnnLSTM。</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>。。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rhb2xlaTg3L3NydS9ibG9iL21hc3Rlci9zcnUvc3J1X2Z1bmN0aW9uYWwucHkjTDEyOA==">https://github.com/taolei87/sru/blob/master/sru/sru_functional.py#L128<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>好复杂，看着头疼</p>
<!--
有空看看openreview，
-->

<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li>Training RNNs as Fast as CNNs. <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDkuMDI3NTU=">pdf<i class="fa fa-external-link-alt"></i></span></li>
<li>神仙打架: SRU引发的争议. <span class="exturl" data-url="aHR0cHM6Ly9vcGVucmV2aWV3Lm5ldC9mb3J1bT9pZD1ySkJpdW5sQVc=">openreview<i class="fa fa-external-link-alt"></i></span> | <span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL2Noby5rLmh5dW4vcG9zdHMvMTAyMDg1NjQ1NjM3ODUxNDk=">facebook<i class="fa fa-external-link-alt"></i></span> | <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL01hY2hpbmVMZWFybmluZy9jb21tZW50cy82emR1aDIvcl8xNzA5MDI3NTVfdHJhaW5pbmdfcm5uc19hc19mYXN0X2FzX2NubnMv">reddit<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>sru</tag>
      </tags>
  </entry>
  <entry>
    <title>【RNN系列】RNN的变种 以及提高RNN训练速度的多种方法</title>
    <url>/pub/f81ec361/</url>
    <content><![CDATA[<p>最受欢迎的两个循环单元是长短期记忆（LSTM）和门控循环单元（GRU），两者都可以将先前的记忆存储在隐藏状态，并使用门控机制来确定应该在何种程度将先前的记忆应与当前的输入结合。但是，由于其<strong>循环的结构</strong>，RNN不能并行计算。因此，训练RNN需要花费大量时间，这限制了学术研究和工业应用。</p>
<p>为了解决这个问题，一些学者尝试在NLP领域使用卷积神经网络（CNN）来代替RNN。但是，<strong>CNN无法获得序列的顺序信息</strong>，而顺序信息在NLP任务中非常重要。</p>
<p>线性激活函数</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><image title="LSTM" src="/images/raw/NN - RNN - LSTM - tensorflow with Equation - colah.png">

<img title="GRU" src="/images/raw/NN - RNN - LSTM var - GRU with Equation - colah.png">




<h1 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h1><ol>
<li>训练速度</li>
<li>模型收敛 (梯度消失、弥散)</li>
</ol>
<h2 id="针对LSTM结构的加速策略"><a href="#针对LSTM结构的加速策略" class="headerlink" title="针对LSTM结构的加速策略"></a>针对LSTM结构的加速策略</h2><ul>
<li>合并input gate和forget gate：GRU、SRU</li>
<li>合并cell state和hidden state: GRU、</li>
<li>分割成多个子序列来实现并行化  SRNN。它在不改变循环单元的情况下，能够比标准RNN快得多</li>
<li></li>
</ul>
<h2 id="针对模型收敛的优化"><a href="#针对模型收敛的优化" class="headerlink" title="针对模型收敛的优化"></a>针对模型收敛的优化</h2><ul>
<li>LSTM</li>
<li>shortcut</li>
</ul>
<h2 id="TOD"><a href="#TOD" class="headerlink" title="TOD"></a>TOD</h2><p>SRU+slice。有必要吗？貌似没必要了。SRU中计算</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
  </entry>
  <entry>
    <title>反卷积 逆卷积(Deconvolution)  - CNN的逆过程</title>
    <url>/pub/8e7b306/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>众所周知，神经网络分为<strong>有向网络</strong>，<strong>无向网络</strong>。典型的无向网络有CRF、Autoencoder、RBM等。由于Autoencoder和RBM是层级结构，也叫双向网络。这种是专门设计的双向网络，具有很好的理论依据(特别是RBM)。用的更多的网络，比如NN、CNN等都是单向网络。</p>
<h1 id="PGM"><a href="#PGM" class="headerlink" title="PGM"></a>PGM</h1><p><strong>理论好，实践弱</strong></p>
<p>概率图模型，又称有向图模型。<br>实际上我们是可以通过后验概率，计算图模型的反向。</p>
<p>但是</p>
<ol>
<li>PGM中的<strong>后验概率计算一般都很复杂</strong>，特别是对于深层PGM，要算很多层叠的微积分。没有</li>
<li>模型的求解难<ol>
<li>深层模型要用EM算法，</li>
<li>由于后验求不出来，大家就采用很多近似方法(比如变分)以及基于采样的方法。</li>
</ol>
</li>
</ol>
<p>得益于漂亮的理论基础，PGM也曾大放异彩，占领学术界和工业界高地。比如曾经风靡的HMM，LDA。涌现了Jordan Blei Daffni Ng一大批牛人。<br>但是PGM的深层扩展性较差，常见的比较深层的PGM就是Blei大神的LDA了。然而神经网络已经动不动上百层了。<br>随着大数据来临，PGM越来越力不从心，渐渐被神经网络取代。</p>
<h1 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h1><p><strong>理论漂亮</strong>，实践，大家还是用autoencoder，而不用RBM。</p>
<p>复杂性</p>
<h1 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h1><p>条件随机场，又叫概率无向图，</p>
<h1 id="NN"><a href="#NN" class="headerlink" title="NN"></a>NN</h1><p>首先我们来看一下，RBM和autoencoder是怎样可逆的？</p>
<h2 id="autoencoder"><a href="#autoencoder" class="headerlink" title="autoencoder"></a>autoencoder</h2><p><strong>强制学习双向的全连接参数W</strong>。</p>
<h2 id="deconv"><a href="#deconv" class="headerlink" title="deconv"></a>deconv</h2><p>神奇的CNN逆过程。</p>
<p>在我的世界观里，CNN是用来特征学习的，网络是单向的，特别是卷积层和pooling层是不可逆的。<br>然而竟然听说有deconv network。</p>
<p>实际上就是类似autoencoder的思想。</p>
<h3 id="反池化过程"><a href="#反池化过程" class="headerlink" title="反池化过程"></a>反池化过程</h3><h3 id="反激活"><a href="#反激活" class="headerlink" title="反激活"></a>反激活</h3><p>在Alexnet中，relu函数是用于保证每层输出的激活值都是正数，因此对于反向过程，我们同样需要保证每层的特征图为正值，也就是说这个反激活过程和激活过程没有什么差别，都是直接采用relu函数。</p>
<h3 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h3><p>信号里的卷积是不可逆的，比如高通滤波，难道还能把高频还原？显然是行不通的。</p>
<p>这里只是采用autoencoder的思想，<strong>强制学习双向的卷积kernel</strong>。</p>
<h3 id="反全连接"><a href="#反全连接" class="headerlink" title="反全连接"></a>反全连接</h3><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>deconvolutional network相关文章，其实deconv的用处还挺广的，涉及到visualization/pixel-wiseprediction/unsupervised learning/image generation都会用到deconv的结构。比如Deconvolutional Network[1][2]做图片的unsupervised feature learning，ZF-Net论文中的卷积网络可视化[3]，FCN网络中的upsampling[4]，GAN中的Generative图片生成[5]。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucXVvcmEuY29tL0hvdy1kb2VzLWEtZGVjb252b2x1dGlvbmFsLW5ldXJhbC1uZXR3b3JrLXdvcms=">How does a deconvolutional neural network work? | Quora<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQzNjA5MDQ1">如何理解深度学习中的deconvolution networks？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqaW1jZS9hcnRpY2xlL2RldGFpbHMvNTA1NDQzNzA=">可视化理解卷积神经网络 | CSDN<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>Adaptive deconvolutional networks for mid and high level feature learning</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>生成模型</category>
      </categories>
      <tags>
        <tag>卷积</tag>
        <tag>反卷积</tag>
        <tag>cnn</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow 架构</title>
    <url>/pub/e2f8f86a/</url>
    <content><![CDATA[<p>Tensorflow是一个跨平台库。C API之上兼容很多不同的编程语言。</p>
<img title="tensorflow架构" src="/images/raw/NN - tensorflow - architecture.png">



<ul>
<li>Client:<ul>
<li>Defines the computation as a dataflow graph.</li>
<li>Initiates graph execution using a session.</li>
</ul>
</li>
<li>Distributed Master<ul>
<li>Prunes a specific subgraph from the graph, as defined by the arguments to Session.run().</li>
<li>Partitions the subgraph into multiple pieces that run in different processes and devices.</li>
<li>Distributes the graph pieces to worker services.</li>
<li>Initiates graph piece execution by worker services.</li>
</ul>
</li>
<li>Worker Services (one for each task)<ul>
<li>Schedule the execution of graph operations using kernel implementations appropriate to the available hardware (CPUs, GPUs, etc).</li>
<li>Send and receive operation results to and from other worker services.</li>
</ul>
</li>
<li>Kernel Implementations<ul>
<li>Perform the computation for individual graph operations.</li>
</ul>
</li>
</ul>
<h1 id="各个模块"><a href="#各个模块" class="headerlink" title="各个模块"></a>各个模块</h1><p>-</p>
<ul>
<li><strong>layers module</strong> provides a <strong>high-level API</strong> that makes it easy to construct a neural network</li>
</ul>
<h2 id="High-Level-APIs"><a href="#High-Level-APIs" class="headerlink" title="High Level APIs"></a>High Level APIs</h2><ul>
<li>Eager Execution, which is the easiest way to use tensorflow.</li>
<li>Estimators, which introduces a high-level TensorFlow API that greatly simplifies ML programming.</li>
<li>Importing Data, which explains how to set up data pipelines to read data sets into your TensorFlow program.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZXh0ZW5kL2FyY2hpdGVjdHVyZQ==">TensorFlow Architecture | 官方<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvcHJvZ3JhbW1lcnNfZ3VpZGUv">programmers guide | 官方<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>toolbox</category>
        <category>tensorflow</category>
      </categories>
  </entry>
  <entry>
    <title>倒排索引的分布式存储</title>
    <url>/pub/684b5b69/</url>
    <content><![CDATA[<p>倒排索引又叫反向索引</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>索引数据的规模为TB级。TB相当于1 000 GB，一个1 000 GB的文件是不可想象的。因此将<strong>全部索引文件存放在一台主机上，不仅是不合适的，而且是不安全的</strong>。这样一旦这个倒排文件损坏，全部服务就会受到很大影响，因此倒排索引的<code>分布式存储</code>技术应运而生了。</p>
<h2 id="大数据遇到的问题"><a href="#大数据遇到的问题" class="headerlink" title="大数据遇到的问题"></a>大数据遇到的问题</h2><h3 id="单机的瓶颈"><a href="#单机的瓶颈" class="headerlink" title="单机的瓶颈"></a>单机的瓶颈</h3><ul>
<li>存储：索引数据大</li>
<li>网络：传输瓶颈(网络负载)，尽量减少网络开销</li>
<li>磁盘I/O：</li>
</ul>
<h3 id="多机需要解决的问题-集群或分布式"><a href="#多机需要解决的问题-集群或分布式" class="headerlink" title="多机需要解决的问题 (集群或分布式)"></a>多机需要解决的问题 (集群或分布式)</h3><ul>
<li>数据倾斜问题</li>
<li>可靠性</li>
<li>网络</li>
<li>查询速度，memory db？如何</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>如何解决以上各种问题？</p>
<ul>
<li>没什么特别好的办法…就是各种<code>切分索引</code>，然后把<code>结果合并</code>之类的</li>
</ul>
<p>常见操作</p>
<ul>
<li>重建索引 周期性重建索引</li>
<li>基于主索引的前提下，构建辅助索引，用于储存新文档，维护于内存中，当辅助索引达到一定的内存占用时，写入磁盘与主索引进行合并；</li>
</ul>
<p>种切分索引，然后把结果合并之类的</p>
<p>服务功能的分布式拆分</p>
<ul>
<li>尽量减少网络开销</li>
<li>各个子服务应该是无状态的</li>
<li>每个子服务都应该是可横向扩展的</li>
</ul>
<h1 id="分布式-VS-集群"><a href="#分布式-VS-集群" class="headerlink" title="分布式 VS 集群"></a>分布式 VS 集群</h1><p>数据的分布式拆分</p>
<ul>
<li>搜索引擎索引分片</li>
<li>Log</li>
</ul>
<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNThhYmY5NDMyZjMwMWUwMDZiZGJjMzcz">https://juejin.im/entry/58abf9432f301e006bdbc373<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="常见疑问"><a href="#常见疑问" class="headerlink" title="常见疑问"></a>常见疑问</h1><h2 id="切分索引"><a href="#切分索引" class="headerlink" title="切分索引"></a>切分索引</h2><p>多机分布式索引一般按照文档编号(<code>docId</code>)或者按照索引词编号(<code>wordId</code>)进行划分。按照DocId划分的结果称为<code>局部倒排文</code>件（Local inverted file）；按照WordId划分的结果称为<code>全局倒排文件</code>（Global inverted file）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apple -&gt; 1, 13, 24, 33, 46, 52, 77</span><br><span class="line">banana -&gt; 4, 8, 33, 34, 52, 66, 88</span><br><span class="line">grapes -&gt; 7, 22, 46, 77, 89</span><br><span class="line">pineapple -&gt; 15, 37, 52</span><br><span class="line">delicious -&gt; 24, 34, 46, 77, 89</span><br><span class="line">rotten -&gt; 8, 66</span><br><span class="line">exotic -&gt; 37</span><br></pre></td></tr></table></figure>

<p>按照<code>docid</code>来切分，比如<code>1-100</code>和<code>101-200</code>分在不同的服务器。</p>
<p>按照<code>wordid</code>来切分，比如<code>apple</code> <code>banana</code>分在不同的服务器。</p>
<table>
<thead>
<tr>
<th>group_by</th>
<th>term (全局方案)</th>
<th>index (局部倒排文件)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>index的获取</td>
<td>并行度=term数</td>
<td>并行度不限</td>
<td></td>
<td></td>
</tr>
<tr>
<td>网络负载</td>
<td>单点压力大</td>
<td>分布式结点分担网络负载</td>
<td></td>
<td></td>
</tr>
<tr>
<td>磁盘IO</td>
<td>节约磁盘I/O (如果只检索一个单词，那么只需要在一个索引结点中检索即可)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>可靠性</td>
<td>单点故障很危险</td>
<td>单点故障影响不大</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>索引的存储结果我们人为能看到的就是segment文件，其实索引文件segment的下层结构就是field域（类似于数据库里面的列名，但是这两个概念区别还是蛮大的，只是拿过来类比），对于每一个field里面存储的就是倒排文件，而我们进行查询的过程时，为了加快查询效率就会制定field域去查询，对于每一个term来说会·去查找字典的一种结构（现在存储结构有FST（英文字典存储结构），前缀树等），因为字典是已经排好序的了，所以这里只需要进行二分查找就可以了，对于每一个term查找到的倒排链进行交集或者并集的合并，在合并的过程若要是按照文本相关性排序（不指定排序股则），就会在合并的过程中会进行相关的score分数计算（例如BM25，或者TF-IDF等一些算法），计算出来的文档会存储在一个top-N的小根堆里面，最后返回给用户。对于倒排链的合并过程交集是一个比较消耗性能的操作，比如lucene对于OR操作的优化比较多，比如说把现在N条倒排链按照长度排序（短的文档在前，长的在后），然后分成两组最短的1条一个组，剩下的N-1条一组，然后对于这两个组进行合并。在OR的合并过程中，可以指定最少有几个term满足要求，这样在前N-1中要是没有满足要求，这样最后一条就不需要在进行合并了。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>倒排索引，当有100台server，要把索引表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">An inverted index is used to support text search. The inverted index has a record for each term. Each record has the list of documents that the term appears in. Documents are identified by an integer document ID. The list of document IDs is sorted in ascending order. For the purpose of this problem, assume that the only operation performed on the inverted index is intersection to find the documents that contain all terms in the search query.</span></span><br><span class="line"><span class="comment">For example, the inverted index could have the following data.</span></span><br><span class="line"><span class="comment">Term</span></span><br><span class="line"><span class="comment">Document IDs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">apple -&gt; 1, 13, 24, 33, 46, 52, 77</span></span><br><span class="line"><span class="comment">banana -&gt; 4, 8, 33, 34, 52, 66, 88</span></span><br><span class="line"><span class="comment">grapes -&gt; 7, 22, 46, 77, 89</span></span><br><span class="line"><span class="comment">pineapple -&gt; 15, 37, 52</span></span><br><span class="line"><span class="comment">delicious -&gt; 24, 34, 46, 77, 89</span></span><br><span class="line"><span class="comment">rotten -&gt; 8, 66</span></span><br><span class="line"><span class="comment">exotic -&gt; 37</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expected results from intersections are as follows:</span></span><br><span class="line"><span class="comment">Terms intersected</span></span><br><span class="line"><span class="comment">Document IDs with all terms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delicious apple -&gt; 24, 46, 77</span></span><br><span class="line"><span class="comment">delicious apple grapes -&gt; 46, 77</span></span><br><span class="line"><span class="comment">apple banana -&gt; 33, 52</span></span><br><span class="line"><span class="comment">We have an inverted index that is very large and requires N servers to &quot;fit&quot;. Assume N is 100.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This class will be given a list of words (such as might be tokenized</span></span><br><span class="line"><span class="comment"> * from a paragraph of text), and will provide a method that takes two</span></span><br><span class="line"><span class="comment"> * words and returns the shortest distance (in words) between those two</span></span><br><span class="line"><span class="comment"> * words in the provided text.</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *   WordDistanceFinder finder = new WordDistanceFinder(Arrays.asList(&quot;the&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;quick&quot;));</span></span><br><span class="line"><span class="comment"> *   assert(finder.distance(&quot;fox&quot;, &quot;the&quot;) == 3);</span></span><br><span class="line"><span class="comment"> *   assert(finder.distance(&quot;quick&quot;, &quot;fox&quot;) == 1);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;quick&quot; appears twice in the input. There are two possible distance values for &quot;quick&quot; and &quot;fox&quot;:</span></span><br><span class="line"><span class="comment"> * 	(3 - 1) = 2 and (4 - 3) = 1.</span></span><br><span class="line"><span class="comment"> * Since we have to return the shortest distance between the two words we return 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistanceFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistanceFinder</span> <span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.contains(word))</span><br><span class="line">          map.put(word, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        map.get(word).add(i);         </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distance</span> <span class="params">(String wordOne, String wordTwo)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; index1 = map.get(wordOne);</span><br><span class="line">      List&lt;integer&gt; index2 = map.get(wordTwo);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> min_distance = map.size();</span><br><span class="line">      <span class="keyword">while</span>(i &lt; index1.size() &amp;&amp; j &lt; index2.size()) &#123;</span><br><span class="line">        ind1 = index1[i];</span><br><span class="line">        ind2 = index[j];</span><br><span class="line">        current_distance = math.abs(ind1 - ind2);</span><br><span class="line">        min_distance = current_distance&gt;min_distance?min_distance:current_distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ind1 &lt; ind2) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          j++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> min_distance;</span><br><span class="line">        <span class="comment">// implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>retrieval</category>
        <category>倒排索引</category>
      </categories>
  </entry>
  <entry>
    <title>推荐系统架构</title>
    <url>/pub/7e199c30/</url>
    <content><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><img title="QQ推荐系统架构" src="https://ask.qcloudimg.com/http-save/yehe-1920198/61aytob1de.jpeg?imageView2/2/w/1620">

<h1 id="模型训练层"><a href="#模型训练层" class="headerlink" title="模型训练层"></a>模型训练层</h1><img title="模型训练层的抽象方案 -- QQ" src="https://ask.qcloudimg.com/http-save/yehe-1920198/8fdbxtqvh9.jpeg?imageView2/2/w/1620">

<h1 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h1><image title="推荐系统的服务层架构" src="/images/raw/ML - 推荐系统 - 架构 - 推荐系统实践.jpg" >

<p>推荐系统需要由多个推荐引擎组成，每个推荐引擎负责一类特征和一种任务，而推荐系统的任务只是将推荐引擎的结果按照一定权重或者优先级合并、排序然后返回。</p>
<h2 id="召回：初始推荐结果"><a href="#召回：初始推荐结果" class="headerlink" title="召回：初始推荐结果"></a>召回：初始推荐结果</h2><p>推荐引擎的构建来源于不同的数据源(也就是用户的特征有很多种类，例如统计的、行为的、主题的)+不同的推荐模型算法，推荐引擎的架构可以试多样化的(实时推荐的+离线推荐的)，然后融合推荐结果（人工规则+模型结果），融合方式多样的，有线性加权的或者切换式的等</p>
<p>多个引擎一般也称为多路召回：</p>
<ul>
<li>新鲜度召回</li>
<li>热度召回</li>
<li>质量分召回</li>
<li>个性化<ul>
<li>基于用户CF召回</li>
<li>基于itemCF召回</li>
</ul>
</li>
</ul>
<p>随机提取，每路召回1000个item。10路就10000 item。</p>
<p><strong>优点：</strong></p>
<ul>
<li>支持多种模型，以及自定义模型</li>
<li></li>
<li>可以方便地增加/删除引擎，控制不同引擎对推荐结果的影响。对于绝大多数需求，只需要通过不同的引擎组合实现。</li>
<li>可以实现推荐引擎级别的用户反馈</li>
</ul>
<h2 id="粗排"><a href="#粗排" class="headerlink" title="粗排"></a>粗排</h2><h2 id="精排"><a href="#精排" class="headerlink" title="精排"></a>精排</h2><p>通常采用LR模型，或者LR的变种。</p>
<p>最上层线上推荐服务、中层各个推荐数据召回集（数据主题、分类池子）、底层各种推荐模型。</p>
<!--
经常用的LR.目标是用户观看时长。播放时长=完成度*视频时长。完成度低的，播放时长。用户行为的，评论、点赞，作为正样本。观看过。
XGboost质量分召回。，
-->







<h2 id="推荐系统有哪些坑？-知乎"><a href="#推荐系统有哪些坑？-知乎" class="headerlink" title="推荐系统有哪些坑？ | 知乎"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI4MjQ3MzUz">推荐系统有哪些坑？ | 知乎<i class="fa fa-external-link-alt"></i></span></h2><ul>
<li><p>将“推荐”理解为“推送</p>
</li>
<li><p>高估算法作用</p>
<ul>
<li>推荐系统中，按照影响效果：用户交互界面(UI) &gt; 数据 &gt; 算法。</li>
</ul>
</li>
</ul>
<h1 id="技术点、难点、瓶颈"><a href="#技术点、难点、瓶颈" class="headerlink" title="技术点、难点、瓶颈"></a>技术点、难点、瓶颈</h1><ul>
<li>online/offline</li>
<li>streaming 推荐，比如滑来滑去小视频</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《推荐系统实践》 项亮</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMTE4ODY2">QQ大数据推荐系统的架构演进<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va29iZWRlc2hvdy9wLzM1Njk1MjUuaHRtbA==">推荐系统的架构<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>搜广推</category>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>单播，组播(多播)，广播以及任播</title>
    <url>/pub/dddac94c/</url>
    <content><![CDATA[<h1 id="路由形式"><a href="#路由形式" class="headerlink" title="路由形式"></a>路由形式</h1><ul>
<li>单播（原文：unicast）是指数据包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。</li>
<li>任播（英语：anycast）是一种网络定址和路由的策略，使得资料可以根据路由拓扑来决定送到“最近”或“最好”的目的地。</li>
</ul>
<table style="background-color:white; float:center; margin:1em; border:thin solid black; clear:both; text-align:center;"><tbody><tr><th style="background-color:#CCCCCC; border-bottom:thin solid gray;"><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUFGJUU3JTk0JUIx">路由<i class="fa fa-external-link-alt"></i></span>形式<br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Cast.svg"><img alt="Cast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/100px-Cast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/150px-Cast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/200px-Cast.svg.png 2x" width="100" /></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><a class="mw-selflink selflink">任播</a><br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Anycast.svg"><img alt="Anycast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/100px-Anycast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/150px-Anycast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/200px-Anycast.svg.png 2x" width="100" /></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJCJUEzJUU2JTkyJUFEXyglRTclQjYlQjIlRTglQjclQUYp">广播<i class="fa fa-external-link-alt"></i></span><br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Broadcast.svg"><img alt="Broadcast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/100px-Broadcast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/150px-Broadcast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/200px-Broadcast.svg.png 2x" width="100" /></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU2JTkyJUFE">多播<i class="fa fa-external-link-alt"></i></span><br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Multicast.svg"><img alt="Multicast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/100px-Multicast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/150px-Multicast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/200px-Multicast.svg.png 2x" width="100" /></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTk2JUFFJUU2JTkyJUFE">单播<i class="fa fa-external-link-alt"></i></span><br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Unicast.svg"><img alt="Unicast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/100px-Unicast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/150px-Unicast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/200px-Unicast.svg.png 2x" width="100" /></a></p></th><th style="margin:1em;"><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR2VvY2FzdA==">geocast<i class="fa fa-external-link-alt"></i></span><br /> <a class="image" href="https://zh.wikipedia.org/wiki/File:Geocast.svg"><img alt="Geocast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/100px-Geocast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/150px-Geocast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/200px-Geocast.svg.png 2x" width="100" /></a></p></th></tr></tbody></table>


<p>bgp anycast就是<br>利用一个（多个） as号码在不同的地区广播相同的一个ip段。<br>利用bgp的寻路原则，短的as path 会选成最优路径（bgp寻路原则之n），从而优化了访问速度。<br>其实bgp anycast是不同服务器用了相同的ip地址。</p>
<p>阿里的DNS 就是使用了BGP AnyCast<br>“其实bgp anycast是不同服务器用了相同的ip地址。”</p>
<h2 id="BGP-Anycast-和-IP-Anycast-有区别吗？"><a href="#BGP-Anycast-和-IP-Anycast-有区别吗？" class="headerlink" title="BGP Anycast 和 IP Anycast  有区别吗？"></a>BGP Anycast 和 IP Anycast  有区别吗？</h2><p>BGP Anycast相较于IP Anycast多了BGP AS，也就是说宣告的这段IP拥有独立的AS号，属于独立的自治域。</p>
<h2 id="不同服务器用相同地址，不会冲突吗？"><a href="#不同服务器用相同地址，不会冲突吗？" class="headerlink" title="不同服务器用相同地址，不会冲突吗？"></a>不同服务器用相同地址，不会冲突吗？</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cDovL2NvbG9idS5jb20vMjAxNC8xMC8yMS91ZHAtYW5kLXVuaWNhc3QtbXVsdGljYXN0LWJyb2FkY2FzdC1hbnljYXN0Lw==">http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>广播，是面向什么范围的广播？局域网？世界所有计算机？</p>
<p>ARP广播，比特币中的广播，</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
        <category>5. 第三层 网络层</category>
      </categories>
      <tags>
        <tag>单播</tag>
      </tags>
  </entry>
  <entry>
    <title>陈云霁报告 - 听课笔记</title>
    <url>/pub/8f038bde/</url>
    <content><![CDATA[<h1 id="陈云霁"><a href="#陈云霁" class="headerlink" title="陈云霁"></a>陈云霁</h1><p>陈云霁 14岁上大学 24岁博士毕业 科大少年班。青年千人。</p>
<h1 id="寒武纪"><a href="#寒武纪" class="headerlink" title="寒武纪"></a>寒武纪</h1><p>AI+芯片</p>
<p>寒武纪作为背靠中科院计算所和中科曙光的AI芯片独角兽公司，在芯片开发实力上处于国内领先地位。<br>目前1A芯片通过IP授权形式进入华为手机，并与中科曙光进行产业链互补。</p>
<ol>
<li>2013 研发全球首个深度学习处理器架构DianNao，是智能芯片领域全球被引次数最多的论文</li>
<li>2014 研发全球首个<strong>多核</strong>深度学习处理器架构DaDianNao，是智能芯片全球被引次数第二的论文</li>
<li>2015 成功研制深度学习专用芯片<strong>寒武纪</strong></li>
<li>2016 发布商用深度学习深度学习处理器IP产品 <strong>寒武纪1A</strong>，以及人工智能专用指令集<strong>Cambricon ISA</strong></li>
<li>2017 <strong>寒武纪1A</strong>授权华为海思使用在Kiring 970手机芯片中</li>
<li>2017 发布低功耗场景视觉应用处理器1H8，通用性更高的1H16和智能驾驶新片1M</li>
<li>2018 发布针对服务器推理和训练的机器学习处理器 MLU100</li>
</ol>
<p>从2017年起获得了中科院为期18个月的共计1000万元的专项资金支持。</p>
<p>目前寒武纪主要有三条产品线：</p>
<ol>
<li>IP授权，智能IP指令集可授权集成到手机、安防、可穿戴设备等终端芯片中，2016年全年拿到1亿元订单</li>
<li>在智能云服务器芯片领域，作为PCIe加速卡插在云服务器上，希望能布局进入人工智能训练和推理市场</li>
<li>开发面向家用智能服务机器人、智能驾驶、智能安防等领域的应用芯片</li>
</ol>
<h1 id="深度学习处理器"><a href="#深度学习处理器" class="headerlink" title="深度学习处理器"></a>深度学习处理器</h1><h2 id="寒武纪做的是终端芯片？还是服务器芯片？"><a href="#寒武纪做的是终端芯片？还是服务器芯片？" class="headerlink" title="寒武纪做的是终端芯片？还是服务器芯片？"></a>寒武纪做的是终端芯片？还是服务器芯片？</h2><p>貌似</p>
<h2 id="智能计算和普通计算的区别是什么？"><a href="#智能计算和普通计算的区别是什么？" class="headerlink" title="智能计算和普通计算的区别是什么？"></a>智能计算和普通计算的区别是什么？</h2><h2 id="符号主义不再流行"><a href="#符号主义不再流行" class="headerlink" title="符号主义不再流行"></a>符号主义不再流行</h2><p>符号逻辑表示问题，求解逻辑表达式</p>
<h2 id="行为主义"><a href="#行为主义" class="headerlink" title="行为主义"></a>行为主义</h2><h2 id="联结主义-人工神经网络"><a href="#联结主义-人工神经网络" class="headerlink" title="联结主义 - 人工神经网络"></a>联结主义 - 人工神经网络</h2><p>把神经细胞抽象成数字，把突出抽象成数字。</p>
<ul>
<li>轴突 - 输出</li>
<li>树突 - 输入</li>
<li>交接地方叫 -</li>
</ul>
<p>人工神经网络一千亿个突触，人脑有百万亿突触。数量级的差距。</p>
<p>人工神经元与生物神经元细胞的区别。</p>
<p>逐层抽象处理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>现有硬件的缺陷，cpu gpu高能耗，低性能。alpha go 几千台。耗电几千瓦，李世乭只需要吃碗饭。</p>
<p>ai算法不错，落地困难，有硬件原因。cpu/gpu构建大规模神经网络，消耗很大。因此，</p>
<p>华为，阿里，曙光等手机都集成了寒武纪芯片。</p>
<ul>
<li>拍照时识别东西。自动调节光圈，</li>
<li>本地机器翻译，不需要联网。牛逼，模型多大啊？很消耗内存吧。本地实时翻译。</li>
</ul>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>传统的ASIC(将给定算法硬件化)的思路无法解决深度学习处理的需求。(并不难，比如把C的程序编程virlog程序)</p>
<ul>
<li>有限规模的硬件 VS 任意规模的算法<ul>
<li>电路做神经元 突触。芯片流片后都是固定的，多少神经元。</li>
<li>寒武纪采用的思路是：硬件神经元的虚拟化。通过时分复用，把有限规模的硬件虚拟成任意大规模的硬件<ul>
<li>缺陷是，数据搬运</li>
</ul>
</li>
</ul>
</li>
<li>结构固定的硬件 VS 千变万化的算法  <ul>
<li>任务不同(下棋，语音，图像)，结构差异(卷积、全连接等)。每天有大量新算法 VS 芯片研发周期长</li>
<li>寒武纪解决方案：抽象各种网络的通用算子，找不同算法，最耗时的部分。<ul>
<li>主要运算：向量内积、向量距离、计数、非线性函数、排序</li>
<li>三个柱子：所有变量可概括为三类。</li>
<li>新算法来了，我们只需要对现有算子的组合</li>
</ul>
</li>
</ul>
</li>
<li>能耗受限的硬件 VS 精度优先的算法<ul>
<li>手机上不要超过1w，不然手机发烫，电池续航也不行</li>
<li>服务器不超过300w，散热问题</li>
<li>google大脑不考虑能耗，只考虑精度</li>
<li>做硬件和做算法的人就存在矛盾</li>
<li>寒武纪解决方案：稀疏神经网络处理器<ul>
<li>很好。跳过90%的神经元。问题是多小能够稀疏化，比如0.01导致用户体验下降，那么就调高点。通过运行时，动态调节稀疏度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>华为mate10的深度学习处理器，比iphone10高效。牛逼呀</p>
<p>google大脑采用了1.6万个cpu核，如果提高1万倍，就可以融入手机。寒武纪目标提高性能1万倍。</p>
<h1 id="寒武纪-1"><a href="#寒武纪-1" class="headerlink" title="寒武纪"></a>寒武纪</h1><ul>
<li>是通用机器学习处理器，大部分机器学习算法都支持。 牛逼</li>
</ul>
<p>7nm，流片成本1亿人民币。没有百万量就不能回本。</p>
<ul>
<li>距离通用的gpu，tpu距离多远？往电脑上一插就能用的。</li>
</ul>
<p>应用面没gpu广，比如gpu能处理图片，寒武纪不擅长图片。</p>
<p>性能功耗比: 寒武纪 &gt; tpu &gt; gpu</p>
<p>tpu做cnn效率高，做lstm效率低。</p>
<p>云端PCA加速卡，曙光出了单机20卡，基于寒武纪。</p>
<p>寒武纪芯片是否支持caffe tf pytorch？支持</p>
<p>陈天霁：华为芯片最领先，展讯、比特大陆(挖矿芯片，异军突起)</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jLm0uMTYzLmNvbS9uZXdzL2wvMTc1MjQzLmh0bWw=">北大公开课 - 陈云霁<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>电子</category>
        <category>芯片</category>
        <category>厂商</category>
      </categories>
  </entry>
  <entry>
    <title>路由器</title>
    <url>/pub/5799c0b3/</url>
    <content><![CDATA[<h3 id="路由器是怎样做到连接不同网络的？用到的关键技术有什么？"><a href="#路由器是怎样做到连接不同网络的？用到的关键技术有什么？" class="headerlink" title="路由器是怎样做到连接不同网络的？用到的关键技术有什么？"></a>路由器是怎样做到连接不同网络的？用到的关键技术有什么？</h3><p>路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。</p>
<p>现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如，TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）。</p>
<p>不在同一</p>
<p>&lt;img title=”路由器连接两个网络” alt==”路由器连接两个网络” src=”/images/raw/TCP%20IP%20-%20%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%20-%20TCPIP%E8%AF%A6%E8%A7%A3.PNG”&gt;  </p>
<p>应用层和运输层使用端到端（End-to-end）协议。在<br>图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（ Hop-by-hop）协议，两个端系统和每个中间系统都要使用它。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
        <category>5. 第三层 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>BLAS</title>
    <url>/pub/72d94504/</url>
    <content><![CDATA[<h1 id="什么是BLAS"><a href="#什么是BLAS" class="headerlink" title="什么是BLAS"></a>什么是BLAS</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMv">BLAS<i class="fa fa-external-link-alt"></i></span>是 Basic Linear Algebra Subprograms （基本线性代数子程序）的首字母缩写，主要用来做基础的矩阵计算，或者是向量计算。它分为三级：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8x">BLAS 1级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>向量与向量</strong>的计算</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8y">BLAS 2级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>矩阵和向量</strong>的计算</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8z">BLAS 3级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>矩阵和矩阵</strong>的计算，最典型的是A矩阵*B矩阵，得到一个C矩阵。</li>
</ul>
<!--
Level 1 BLAS perform scalar, vector and vector-vector operations
Level 2 BLAS perform matrix-vector operations
Level 3 BLAS perform matrix-matrix operations
-->


<p>为什么BLAS是一个非常重要的库或者接口，是因为它是很多科学计算的核心之一。每年做超级计算机的排行榜，都要做LINPACK测试，该测试很多部分就是做BLAS 3级矩阵和矩阵的计算。此外，还有很多科学和工程的模拟，在转换后都变成了一种矩阵上的操作。如果你把矩阵优化的特别好的话，对整个应用的提升，都是非常有帮助的。</p>
<p>广泛用于LAPACK</p>
<p><strong>疑问</strong>: 有没有tensor计算？<br>tensor计算要转化成以上三个级别的计算吗？没有。numpy支持高阶矩阵(多维数组)计算。</p>
<p><strong>注意subprograms这个词，表示线性代数库的子项目</strong></p>
<h1 id="BLAS与深度学习"><a href="#BLAS与深度学习" class="headerlink" title="BLAS与深度学习"></a>BLAS与深度学习</h1><p>经过测试，发现Alexnet大部分的时间花费在卷积层（Conv Layer），另外不少时间花在了全连接层（FC layer）。</p>
<ul>
<li>卷基层目前通用的实现是展成矩阵，变成矩阵与矩阵的乘法，就是BLAS 3级。</li>
<li>全连接层一般是变成一个矩阵和向量的乘法，也落成了BLAS操作。</li>
</ul>
<p>也就是说，基于矩阵类学习的深度学习，<strong>有90%或者更多的时间是通过BLAS来操作的</strong>。当然，随着新的算法出现，卷积层对3*3的卷积核有专门的算法，或者用FFT类类算法也可以做，但是在通用上，展矩阵来做也非常广泛。</p>
<p><strong>疑问</strong>: cuda也兼容BLAS接口吗？还是自己独立的接口？</p>
<h1 id="BLAS实现"><a href="#BLAS实现" class="headerlink" title="BLAS实现"></a>BLAS实现</h1><p>BLAS只是定义了接口，但是具体的实现其实有很多种。从商业的角度来讲，存在很多商业版本。基本上为了搭配自己的硬件，对其做了更优的优化。常见的商业版本有</p>
<ul>
<li>Intel MKL</li>
<li>AMD ACML</li>
<li>NVIDIA CUBLAS</li>
<li>IBM ESSL</li>
</ul>
<p>开源</p>
<ul>
<li>GotoBLAS:（2010年中止开发）</li>
<li>ATLAS: 美国一所学校开发</li>
<li>OpenBLAS: 基于GotoBLAS</li>
<li>BLIS: 基于GotoBLAS扩展出来的一个项目</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>parallel computing-高性能计算</category>
        <category>线性代数-blas-lapack-numpy</category>
        <category>0. 矩阵计算</category>
      </categories>
  </entry>
  <entry>
    <title>BLAS</title>
    <url>/pub/72d94504/</url>
    <content><![CDATA[<h1 id="什么是BLAS"><a href="#什么是BLAS" class="headerlink" title="什么是BLAS"></a>什么是BLAS</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMv">BLAS<i class="fa fa-external-link-alt"></i></span>是 Basic Linear Algebra Subprograms （基本线性代数子程序）的首字母缩写，主要用来做基础的矩阵计算，或者是向量计算。它分为三级：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8x">BLAS 1级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>向量与向量</strong>的计算</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8y">BLAS 2级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>矩阵和向量</strong>的计算</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5uZXRsaWIub3JnL2JsYXMvI19sZXZlbF8z">BLAS 3级<i class="fa fa-external-link-alt"></i></span>，主要是<strong>矩阵和矩阵</strong>的计算，最典型的是A矩阵*B矩阵，得到一个C矩阵。</li>
</ul>
<!--
Level 1 BLAS perform scalar, vector and vector-vector operations
Level 2 BLAS perform matrix-vector operations
Level 3 BLAS perform matrix-matrix operations
-->


<p>为什么BLAS是一个非常重要的库或者接口，是因为它是很多科学计算的核心之一。每年做超级计算机的排行榜，都要做LINPACK测试，该测试很多部分就是做BLAS 3级矩阵和矩阵的计算。此外，还有很多科学和工程的模拟，在转换后都变成了一种矩阵上的操作。如果你把矩阵优化的特别好的话，对整个应用的提升，都是非常有帮助的。</p>
<p>广泛用于LAPACK</p>
<p><strong>疑问</strong>: 有没有tensor计算？<br>tensor计算要转化成以上三个级别的计算吗？没有。numpy支持高阶矩阵(多维数组)计算。</p>
<p><strong>注意subprograms这个词，表示线性代数库的子项目</strong></p>
<h1 id="BLAS与深度学习"><a href="#BLAS与深度学习" class="headerlink" title="BLAS与深度学习"></a>BLAS与深度学习</h1><p>经过测试，发现Alexnet大部分的时间花费在卷积层（Conv Layer），另外不少时间花在了全连接层（FC layer）。</p>
<ul>
<li>卷基层目前通用的实现是展成矩阵，变成矩阵与矩阵的乘法，就是BLAS 3级。</li>
<li>全连接层一般是变成一个矩阵和向量的乘法，也落成了BLAS操作。</li>
</ul>
<p>也就是说，基于矩阵类学习的深度学习，<strong>有90%或者更多的时间是通过BLAS来操作的</strong>。当然，随着新的算法出现，卷积层对3*3的卷积核有专门的算法，或者用FFT类类算法也可以做，但是在通用上，展矩阵来做也非常广泛。</p>
<p><strong>疑问</strong>: cuda也兼容BLAS接口吗？还是自己独立的接口？</p>
<h1 id="BLAS实现"><a href="#BLAS实现" class="headerlink" title="BLAS实现"></a>BLAS实现</h1><p>BLAS只是定义了接口，但是具体的实现其实有很多种。从商业的角度来讲，存在很多商业版本。基本上为了搭配自己的硬件，对其做了更优的优化。常见的商业版本有</p>
<ul>
<li>Intel MKL</li>
<li>AMD ACML</li>
<li>NVIDIA CUBLAS</li>
<li>IBM ESSL</li>
</ul>
<p>开源</p>
<ul>
<li>GotoBLAS:（2010年中止开发）</li>
<li>ATLAS: 美国一所学校开发</li>
<li>OpenBLAS: 基于GotoBLAS</li>
<li>BLIS: 基于GotoBLAS扩展出来的一个项目</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>parallel computing-高性能计算</category>
        <category>线性代数-blas-lapack-numpy</category>
        <category>矩阵计算</category>
      </categories>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/pub/fa288682/</url>
    <content><![CDATA[<!--
numpy不算是矩阵计算库，是在矩阵计算库之上的库。应该属于科学计算了
-->
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NumPy是Python语言的一个扩充程序库。支持<strong>高阶大量的维度数组与矩阵运算</strong>，此外也针对数组运算提供大量的数学函数库</p>
<p>NumPy参考CPython(一个使用字节码的解释器)，而在这个Python实现解释器上所写的数学算法代码通常远比编译过的相同代码要来得慢。为了解决这个难题，NumPy引入了多维数组以及可以直接有效率地操作多维数组的函数与运算符。因此在NumPy上只要能被表示为针对数组或矩阵运算的算法，其运行效率几乎都可以与编译过的等效C语言代码一样快。[1]</p>
<h1 id="numpy的依赖"><a href="#numpy的依赖" class="headerlink" title="numpy的依赖"></a>numpy的依赖</h1><h2 id="独立安装"><a href="#独立安装" class="headerlink" title="独立安装"></a>独立安装</h2><p>NumPy这个Python包本身不需依赖任何第三方库就能完成编译和安装使用，只不过其计算性能会受到影响。</p>
<p>在编译NumPy时通常会依赖一些经过特别优化的第三方科学计算库。</p>
<h2 id="高性能NumPy包通常会依赖LAPACK和ATLAS库"><a href="#高性能NumPy包通常会依赖LAPACK和ATLAS库" class="headerlink" title="高性能NumPy包通常会依赖LAPACK和ATLAS库"></a>高性能NumPy包通常会依赖LAPACK和ATLAS库</h2><p>lapack和atlas是科学计算领域的两个针对线性代数运算的经过特别优化的非常强大的工具库，</p>
<p>这两个库对于安装NumPy包来说并不是强制依赖的。</p>
<h1 id="查看-numpy的配置"><a href="#查看-numpy的配置" class="headerlink" title="查看 numpy的配置"></a>查看 numpy的配置</h1><p>本机mac上</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.show_config()</span><br><span class="line">blas_mkl_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">blis_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">openblas_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_3_10_blas_threads_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_3_10_blas_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_blas_threads_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_blas_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">blas_opt_info:</span><br><span class="line">    extra_compile_args = [<span class="string">&#x27;-msse3&#x27;</span>, <span class="string">&#x27;-I/System/Library/Frameworks/vecLib.framework/Headers&#x27;</span>]</span><br><span class="line">    extra_link_args = [<span class="string">&#x27;-Wl,-framework&#x27;</span>, <span class="string">&#x27;-Wl,Accelerate&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;NO_ATLAS_INFO&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">lapack_mkl_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">openblas_lapack_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">openblas_clapack_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_3_10_threads_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_3_10_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_threads_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">atlas_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">lapack_opt_info:</span><br><span class="line">    extra_compile_args = [<span class="string">&#x27;-msse3&#x27;</span>]</span><br><span class="line">    extra_link_args = [<span class="string">&#x27;-Wl,-framework&#x27;</span>, <span class="string">&#x27;-Wl,Accelerate&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;NO_ATLAS_INFO&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br></pre></td></tr></table></figure>

<p>P100 GPU服务器ubuntu</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.__config__.show()</span><br><span class="line">mkl_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;mkl_rt&#x27;</span>, <span class="string">&#x27;pthread&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;SCIPY_MKL_H&#x27;</span>, <span class="literal">None</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    include_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/include&#x27;</span>]</span><br><span class="line">blas_mkl_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;mkl_rt&#x27;</span>, <span class="string">&#x27;pthread&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;SCIPY_MKL_H&#x27;</span>, <span class="literal">None</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    include_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/include&#x27;</span>]</span><br><span class="line">blas_opt_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;mkl_rt&#x27;</span>, <span class="string">&#x27;pthread&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;SCIPY_MKL_H&#x27;</span>, <span class="literal">None</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    include_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/include&#x27;</span>]</span><br><span class="line">lapack_mkl_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;mkl_rt&#x27;</span>, <span class="string">&#x27;pthread&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;SCIPY_MKL_H&#x27;</span>, <span class="literal">None</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    include_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/include&#x27;</span>]</span><br><span class="line">lapack_opt_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;mkl_rt&#x27;</span>, <span class="string">&#x27;pthread&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;SCIPY_MKL_H&#x27;</span>, <span class="literal">None</span>), (<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    include_dirs = [<span class="string">&#x27;/home/song.xu01/anaconda3/include&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>该服务器的全局python</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.__config__.show()</span><br><span class="line">lapack_opt_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;openblas&#x27;</span>, <span class="string">&#x27;openblas&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/usr/local/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    language = c</span><br><span class="line">blas_opt_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;openblas&#x27;</span>, <span class="string">&#x27;openblas&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/usr/local/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    language = c</span><br><span class="line">openblas_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;openblas&#x27;</span>, <span class="string">&#x27;openblas&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/usr/local/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    language = c</span><br><span class="line">blis_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">openblas_lapack_info:</span><br><span class="line">    libraries = [<span class="string">&#x27;openblas&#x27;</span>, <span class="string">&#x27;openblas&#x27;</span>]</span><br><span class="line">    library_dirs = [<span class="string">&#x27;/usr/local/lib&#x27;</span>]</span><br><span class="line">    define_macros = [(<span class="string">&#x27;HAVE_CBLAS&#x27;</span>, <span class="literal">None</span>)]</span><br><span class="line">    language = c</span><br><span class="line">lapack_mkl_info:</span><br><span class="line">  NOT AVAILABLE</span><br><span class="line">blas_mkl_info:</span><br><span class="line">  NOT AVAILABLE</span><br></pre></td></tr></table></figure>


<p>安装numpy的过程，也会显示</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL3B5dGhvbi5qb2Jib2xlLmNvbS84MTMxMC8=">如何获得NumPy的最佳性能<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>parallel computing-高性能计算</category>
        <category>线性代数-blas-lapack-numpy</category>
        <category>科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>java系列 - Error &amp; Exception</title>
    <url>/pub/e2072a3f/</url>
    <content><![CDATA[<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><ul>
<li>catch an error at compile time:  before you even try to run the program  (think in java)</li>
<li><h2 id="java-framework"><a href="#java-framework" class="headerlink" title="java framework"></a>java framework</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Throwable─┬─Exception─┬─RuntimeException─┬─IndexOutOfBoundsException</span><br><span class="line">          │           │                  ├─NullPointerException</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  └─</span><br><span class="line">          │           │                  </span><br><span class="line">          │           ├─ ReflectiveOperationException─┬─NoSuchMethodException</span><br><span class="line">          │           │                               ├─ClassNotFoundException</span><br><span class="line">          │           │                               └─IllegalAccessException</span><br><span class="line">          │           │</span><br><span class="line">          │           │</span><br><span class="line">          │           │</span><br><span class="line">          │           ├─IOException─┬─FileNotFoundException</span><br><span class="line">          │           │             ├─EOFException</span><br><span class="line">          │</span><br><span class="line">          └─Error─┬─</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>RuntimeException</th>
<th>non-RuntimeException</th>
</tr>
</thead>
<tbody><tr>
<td>checked</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>occur in</td>
<td>runtime</td>
<td><strong>runtime</strong></td>
</tr>
<tr>
<td>must catch</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>caused by</td>
<td>programmer,such as NullPointerException, IndexOutOfBoundsException</td>
<td>external, such as FileNotFoundException</td>
</tr>
<tr>
<td>thrown</td>
<td>during the normal operation of JVM</td>
<td></td>
</tr>
</tbody></table>
<p> Compile-Time Checking of Exceptions</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p><strong>RuntimeException</strong><br>一般情况下，不要捕获或声明RuntimeException。因为问题在于你的程序逻辑本身有问题，<br>如果你用异常流程处理了，反而让正常流程问题一直存在。<br>程序应该从逻辑角度尽可能避免这类异常的发生；</p>
<p><strong>non-RuntimeException</strong><br>RuntimeException之外的异常我们统称为非运行时异常。<br>从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</p>
<p>非运行时异常，编译期要做语法检查，即检查是否处理了catch。程序报Exception还是要运行期才能知道的。</p>
<p>An Exception is checked, and a RuntimeException is unchecked.</p>
<ul>
<li>A checked exception must be handled explicitly by the code (catch or throw)</li>
<li>An un-checked exception does not need to be explicitly handled.</li>
</ul>
<h2 id="ambiguous-common-errors-common-misconceptions"><a href="#ambiguous-common-errors-common-misconceptions" class="headerlink" title="ambiguous, common errors, common misconceptions"></a>ambiguous, common errors, common misconceptions</h2><p>Is non-RuntimeException CompiletimeException in java framework?<br>No, non-RuntimeException would be checked in compile time. But the Exception occurs in run time.</p>
<h2 id="where-did-RuntimeException-comes-from"><a href="#where-did-RuntimeException-comes-from" class="headerlink" title="where did RuntimeException comes from"></a>where did RuntimeException comes from</h2><p>since JDK1.0</p>
<h2 id="new-reasonable-framework"><a href="#new-reasonable-framework" class="headerlink" title="new/reasonable framework"></a>new/reasonable framework</h2><p>In my view, the RuntimeException should be renamed as CheckedException</p>
<ul>
<li>RuntimeException<ul>
<li>CheckedException</li>
<li>UncheckedException</li>
</ul>
</li>
<li>CompiletimeException</li>
<li>..</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li>《The Java™ Language Specification》11.2  Compile-Time Checking of Exceptions</li>
</ul>
<h2 id="other-framework"><a href="#other-framework" class="headerlink" title="other framework"></a>other framework</h2><ol>
<li>&lt;Java language specification 8&gt;<blockquote>
<p>Some programming languages and their implementations react to such errors<br>by peremptorily terminating the program; other programming languages allow an<br>implementation to react in an arbitrary or unpredictable way. Neither of these<br>approaches is compatible with the design goals of the Java SE platform: to provide<br>portability and robustness.</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>Instead, the Java programming language specifies that an exception will be thrown<br>when semantic constraints are violated and will cause a non-local transfer of control<br>from the point where the exception occurred to a point that can be specified by the<br>programmer.</p>
</blockquote>
<p>2.</p>
<h3 id="python-framework"><a href="#python-framework" class="headerlink" title="python framework"></a>python framework</h3><p>reference: <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9ydWJ5bG91dnJlL2FyY2hpdmUvMjAxMS8wNi8yMi8yMDg2NjQ0Lmh0bWw=">http://www.cnblogs.com/rubylouvre/archive/2011/06/22/2086644.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="c-framework"><a href="#c-framework" class="headerlink" title="c++ framework"></a>c++ framework</h3>]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java的正则表达式</title>
    <url>/pub/31a07523/</url>
    <content><![CDATA[<h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><p>Java 正则表达式和 Perl 的是最为相似的。</p>
<p>java.util.regex 包主要包括以下三个类：</p>
<h2 id="Pattern-类"><a href="#Pattern-类" class="headerlink" title="Pattern 类"></a>Pattern 类</h2><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
<h2 id="Matcher-类"><a href="#Matcher-类" class="headerlink" title="Matcher 类"></a>Matcher 类</h2><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1yZWd1bGFyLWV4cHJlc3Npb25zLmh0bWw=">菜鸟教程<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密 - RSA</title>
    <url>/pub/7b76f7b5/</url>
    <content><![CDATA[<h1 id="公开密钥密码学"><a href="#公开密钥密码学" class="headerlink" title="公开密钥密码学"></a>公开密钥密码学</h1><p>加密需要双方共享一个私密的随机数。从未谋面的两人，如何就此共享密钥达成一致，而又不让第三方监听者知道呢？</p>
<h1 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h1><p>我们需要一种运算，正常容易，反向很难。于是我们找到了模运算，也称时钟运算。</p>
<p>比如 $46 \  \mathrm {mod} \ 12 = 10$，正向计算很容易。</p>
<p>下面采用质数，</p>
<img src="/images/raw/密码学 - mod运算 - 可汗公开课.png">

<p>对于不同的取值$e$，结果是[0,16]之间均匀分布的。</p>
<p><strong>反向是很困难的</strong></p>
<!-- reverse procedure is hard -->
<!-- 公钥可以随便公开，是不是就像要饭的一个盆，拼多多分享的码？ -->


<p>$$3^{\color{red}{29}} \mathrm {mod} \ 17  \xrightarrow[encrypt]{\color{green}{EASY}}    {\color{blue}12}$$<br>正向加密很容易。</p>
<p>求以上过程的反向，这就很难了。<br>这被称为离散对数问题(discrete logarithm problem)</p>
<p>$$3^{\color{red}?} \mathrm {mod} \ 17  \xleftarrow[decrypt]{\color{red}{HARD}}    {\color{blue}{12}}$$<br>反向解密却很难。已知12，我们只能采用试错法求出匹配的指数。</p>
<p><strong>反向有多难</strong><br>如果模数很小，比较容易。模数若是长达百位的质数，即便借助地球上最强大的计算机，要遍历所有可能情况也需要上千年时间。</p>
<p>单向函数的强度取决于反向过程所需要的时间。</p>
<ul>
<li>反向的难度，具体计算一下</li>
</ul>
<h2 id="迪菲·赫尔曼密钥交换"><a href="#迪菲·赫尔曼密钥交换" class="headerlink" title="迪菲·赫尔曼密钥交换"></a>迪菲·赫尔曼密钥交换</h2><p>Alice如何向Bob发送信息，而不怕Eve截获信息呢？</p>
<img src="/images/raw/密码学 - 赫尔曼密钥交换 - 1 - 可汗学院.png">

<p>首先Alice和Bob公开地就质模数(prime modulus)和生成元(generator)达成一致，也就是这个例子中的p=17，g=3。</p>
<p>然后Alice选择一个私有数，${\color{red}{15}}$，加密后是${\color{blue} 6}$<br>$$3^{\color{red}{15}} \mathrm {mod} \ 17  \equiv   {\color{blue} 6}$$<br>然后公开将此结果发送给Bob。</p>
<p>Bob选择一个私有数13，计算<br>$$3^{\color{red}{13}} \mathrm {mod} \ 17  \equiv   {\color{blue} {12}}$$<br>然后公开将此结果发送给Alice。</p>
<img title="蓝色是公开的，红色是私有的" src="/images/raw/密码学 - 赫尔曼密钥交换 - 2 - 可汗学院.png">


<p>下面就是<strong>关键</strong></p>
<p>Alice经过以下计算，得到共享密钥 (shared secret) ${\color{Apricot}{10} }$</p>
<p>$${\color{blue}{12} }^{\color{red}{15} } \mathrm {mod} \ 17  \equiv   {\color{Apricot}{10} }$$</p>
<p>Bob也计算得到共享密钥，两者计算结果是相同的。</p>
<img title="蓝色是公开的，红色是私有的" src="/images/raw/密码学 - 赫尔曼密钥交换 - 3 - 可汗学院.png">

<p>这是因为<br>$$3^{\color{red}{13 ^{15}} } \mathrm {mod} \ 17  \equiv   3^{\color{red}{15 ^{13}} } \mathrm {mod} \ 17 $$</p>
<p>两种计算实质是相同的，只是指数的顺序不同而已。<br>没有私有数字 ${\color{red}{15}}$、${\color{red}{13}}$，Eve将无法求出结果。Eve会被困在离散对数问题之中，数字足够大时，实践中，她在合理时限内几乎不可能破解。这就解决了交换密钥的问题。这可以同伪随机数生成器结合使用为未曾谋面的人提供通信加密。</p>
<p>Eve将无法求出结果，没太看懂。</p>
<ul>
<li>这两个私有数字，只要有一个就能解密吗？</li>
<li>17，3 是怎么达成一致的？传输过程被截获呢？是public的吗？</li>
</ul>
<h1 id="RSA加密第一步"><a href="#RSA加密第一步" class="headerlink" title="RSA加密第一步"></a>RSA加密第一步</h1><p>对称加密中，要求通信双方共享密钥。但如果Alice和Bob不能实际见面，则需要额外的通信开销，比如使用迪菲-赫尔曼密钥交换。</p>
<p>另外，如果Alice希望同很多人通信，那么她将需要同每个人交换不同密钥。她必须管理好所有这些密钥，发送数以千计的信息，仅仅为了建立它们。</p>
<img src="/images/raw/密码学 - 赫尔曼密钥交换 - 4 - 可汗学院.png">

<p>是否有更简单的额方式？</p>
<p>1970年，英国数学家James Ellis试图实现公开密钥加密(non-secret encryption)。</p>
<p>加密和解密是互逆操作，Alice可以买一把锁，把钥匙留在手里，然后把打开的锁发给Bob。Bob可以将自己的信息上锁，然后发回给Alice。这里无需交换密钥。</p>
<p>这意味着锁是可以公开的，可以让世界上任何人使用它来发信息。而现在Alice只需要留一把钥匙。</p>
<p>Ellis并未找到相关的数学方法，但他提出了应该怎样做的思路。<strong>关键在于将密钥分为两个部分，一部分是加密密钥，一部分是解密密钥</strong>。解密密钥用于解密这一逆操作，而加密是通过加密密钥进行的。</p>
<h1 id="RSA加密第二步"><a href="#RSA加密第二步" class="headerlink" title="RSA加密第二步"></a>RSA加密第二步</h1><p>需要构建一种特殊的单向函数，也叫陷门单向函数(trap door one-way functioin)</p>
<p>这种函数，正向很容易，反向很难，除非你有关于trap door的特殊信息。为此，考虑了模幂运算。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hhbmFjYWRlbXkub3JnL2NvbXB1dGluZy9jb21wdXRlci1zY2llbmNlL2NyeXB0b2dyYXBoeSNtb2Rlcm4tY3J5cHQ=">现代密码学 | 可汗学院<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMDYvcnNhX2FsZ29yaXRobV9wYXJ0X29uZS5odG1s">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>security</category>
        <category>密码学</category>
        <category>非对称加密</category>
      </categories>
  </entry>
  <entry>
    <title>利用travis自动构建Gitbook静态页面，并自动部署到Github Page</title>
    <url>/pub/a8e526f0/</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>实现 Gitbook - Github仓库 - Github Pages 三方同步。</p>
<ul>
<li>修改Gitbook，实现 Github自动同步 + 自动部署静态页面到Github Pages</li>
<li>修改Github仓库，实现Gitbook自动同步 + 自动部署静态页面到Github Pages</li>
</ul>
<p>Gitbook自身已经实现了与Github仓库的同步，现在的问题是，如何实现自动部署静态页面到Github Pages。</p>
<p>当然有很多实现方式，这里我们介绍利用Travis CI自动部署Github Pages。</p>
<h1 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h1><p>Travis CI原理就是当你每次提交commit到在github后，它会自动检测你的提交，同时根据的配置文件，生成一个Linux虚拟机来运行你的命令，通常这些命令用于测试，构建等。在我们的要求下，就可以用它运行一些hexo g d之类的命令来自动生成、部署我静态网页。</p>
<ol>
<li>博客提交修改后push到github</li>
<li>github通知travis ci项目需要构建<ul>
<li>这里需要配置：</li>
</ul>
</li>
<li>travis ci立马安排构建<ul>
<li>这里需要.travis.yml</li>
</ul>
</li>
<li>构建完成后将结果push到github的gh-pages分支<ul>
<li>这里需要github访问权限。即personal access token</li>
<li>把token设置到.travis.yml环境变量中，安全起见，最好加密</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRyYXZpcy1jaS5jb20vdXNlci9lbnZpcm9ubWVudC12YXJpYWJsZXM=">travis环境变量的定义与加密<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>vps利用git钩子将结果部署到web容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install travis-encrypt -g</span><br><span class="line">$ travis-encrypt -r username/repository GH_TOKEN=[the token you created before] -a</span><br><span class="line">$ travis-encrypt -r ESbook/TCP-IP GH_TOKEN=6ad73f4597162bf335caaeef3e1138b77645dd5c -a</span><br><span class="line"><span class="comment"># GH_TOKEN</span></span><br><span class="line">XpJ36JE64TJCwGQ5ZxxWosn64Rhwq3OGOqNJhjKUyeGPlj9B+fNPAqBmP+YTLxB5nRpoLv5UsK62Qw15Of02iZcoO50H8qBrb2cWNEW3z2+Ih12JoeN5qJi4MTShT6ePbwH7Tvid27wosswuYH2+O4hvSQR13WwsHqCPDmzno6Zni+Unt8tya0etSkRqS81hKbHTItL0fOQiDpVIK2GrUioqPAbDV2TNBZfas8EENmSfZMRjHV6BYaOY/ZQg8qx3UuPSnGLU6pmiv9pcaiths4LNBoHb71+Rm87E+FffI6sHtmqrKn9NoW5sEsiiIAUusYQE5woQsn46+uc8lgjlx+1DGBxPstQwvTQNcu8HWzoN0lxlnIYMTWTj/aoUBmc90/Do1GPlpSP9/vONrU2ljfyfKlxxwbUdvHg8pvfU09QsWtTRAqfSjrH305nHOCPKWQgeYv0zbgTqRq/zKh5xTS+iaU6R+VscxFTCnktQaCG1oB6VMSBsU6YjvG5KcY7UZHiyF/fPTRFIH/LtT6iX9DpGlvc3NBb/mA4ERcEvMp/1Bgs7rqHVML+luhwKBwqeivilz0VRajK5JQxBmMeuJ4cDVt/yJuwGjf72chKa8Y909/iwAKm5wJ/FAEKvv7wl1aZJyOFdWEW6n/6u63+6VQy1YF/6aSodbkQcvO/o8qw=</span><br><span class="line">$ git remote add origin <span class="string">&#x27;https://f6884617cab7ada45740e5034604e3e82e4ac722@github.com/ESbook/TCP-IP.git&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>博客：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE4NDI3MDAzL2FydGljbGUvZGV0YWlscy82NDkyMTIwMQ==">http://blog.csdn.net/qq8427003/article/details/64921201<i class="fa fa-external-link-alt"></i></span></li>
<li>应用实例 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzg0MjcwMDMvYm9vay9ibG9iL21hc3Rlci9kZXBsb3ktdG8tZ2l0aHViLnNo">https://github.com/8427003/book/blob/master/deploy-to-github.sh<i class="fa fa-external-link-alt"></i></span></li>
<li>实例&amp;博客：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZla2xhYm5pay9hdXRvbWF0aWNhbGx5X3VwZGF0ZV9naXRodWJfcGFnZXNfd2l0aF90cmF2aXNfZXhhbXBsZQ==">https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example<i class="fa fa-external-link-alt"></i></span></li>
<li>博客：<span class="exturl" data-url="aHR0cHM6Ly9zaGF3bmhvLm1lLzIwMTcvMTEvMjMvZGVwbG95LWhleG8tYmxvZy13aXRoLXRyYXZpcy1jaS8=">https://shawnho.me/2017/11/23/deploy-hexo-blog-with-travis-ci/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="为什么要采用personal-access-token？为什么不采用ssh验证？"><a href="#为什么要采用personal-access-token？为什么不采用ssh验证？" class="headerlink" title="为什么要采用personal access token？为什么不采用ssh验证？"></a>为什么要采用personal access token？为什么不采用ssh验证？</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是HTTPS URLs采用账号密码进行校验，SSH URLs采用SSH秘钥对进行校验。</p>
<p>采用personal access token的方式来访问gitub，目的是代替密码输入。</p>
<p>如果要采用ssh，需要把travis主机的ssh key加入到github中。这样确实能够方便部署，免密码验证，但是存在风险。因为travis主机是很多人共用的，同一个主机加很多github的ssh会存在多账户权限风险。（我猜的）。即使每个github账号对应一个虚机或者docker，不方便多主机CDN。</p>
<h2 id="为什么要travis-encrypt？"><a href="#为什么要travis-encrypt？" class="headerlink" title="为什么要travis encrypt？"></a>为什么要travis encrypt？</h2><p>因为公开personal access token，就基本等同于公开github密码。任何人可以通过用户名+token获得github的相应权限，github中的项目有被恶意篡改，删除的风险。</p>
<p>travis encrypt对token进行加密，该密文仅travis能够识别。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>CI-持续集成</category>
        <category>Travis CI</category>
      </categories>
      <tags>
        <tag>travis</tag>
        <tag>gitbook</tag>
        <tag>自动化部署</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>经典的web编辑器--CKEditor</title>
    <url>/pub/fae97115/</url>
    <content><![CDATA[<h1 id="快速搭建CKEditor"><a href="#快速搭建CKEditor" class="headerlink" title="快速搭建CKEditor"></a>快速搭建CKEditor</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jZG4uY2tlZGl0b3IuY29tLw==">CKEditor CDN<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>CKEditor<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.ckeditor.com/4.8.0/standard/ckeditor.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;editor1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">			CKEDITOR.replace( <span class="string">&#x27;editor1&#x27;</span> );</span></span><br><span class="line"><span class="javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存为html，双击打开即可。<br><a href="https://blog.eson.org/demos/ckeditor/">Online Demo</a></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yLWRldg==">https://github.com/ckeditor/ckeditor-dev<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="CKFinder"><a href="#CKFinder" class="headerlink" title="CKFinder"></a>CKFinder</h2><p>没有CKFinder，CKEditor作为一个编辑器，也是可以正常使用的，但是无法在编辑器里浏览服务器上的用户上传文件。所以要整合CKFinder。</p>
<p>需要后台服务器。(用于文件上传、存储)。支持java php .net等语言</p>
<h1 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h1><ul>
<li>Tinymce</li>
<li>为知笔记也不错，但不开源</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi93ZWIvMTAxMl9tb3lpbmdfY2tlZGl0b3IvaW5kZXguaHRtbA==">https://www.ibm.com/developerworks/cn/web/1012_moying_ckeditor/index.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>formatting</category>
        <category>html-富文本编辑器</category>
      </categories>
  </entry>
  <entry>
    <title>Gitbook自动化部署到Github Pages的方案汇总</title>
    <url>/pub/941b4609/</url>
    <content><![CDATA[<h2 id="采用shell命令"><a href="#采用shell命令" class="headerlink" title="采用shell命令"></a>采用shell命令</h2><ul>
<li>参考一：<br><span class="exturl" data-url="aHR0cDovL3Nhbmdzb29uYW0uZ2l0aHViLmlvLzIwMTYvMDgvMDIvcHVibGlzaC1naXRib29rLXRvLXlvdXItZ2l0aHViLXBhZ2VzLmh0bWw=">http://sangsoonam.github.io/2016/08/02/publish-gitbook-to-your-github-pages.html<i class="fa fa-external-link-alt"></i></span></li>
<li>参考二：<span class="exturl" data-url="aHR0cHM6Ly90b255ZGVuZy5naXRodWIuaW8vZ2l0Ym9vay16aC9naXRib29rLWhvd3RvdXNlL3B1Ymxpc2gvZ2l0cGFnZXMuaHRtbA==">https://tonydeng.github.io/gitbook-zh/gitbook-howtouse/publish/gitpages.html<i class="fa fa-external-link-alt"></i></span></li>
<li>参考三：<span class="exturl" data-url="aHR0cDovL3lhbmdqaC5vc2NoaW5hLmlvL2dpdGJvb2svVXNpbmdQYWdlcy5odG1s">http://yangjh.oschina.io/gitbook/UsingPages.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="封装成node-module"><a href="#封装成node-module" class="headerlink" title="封装成node module"></a>封装成node module</h2><p>借鉴 hexo deploy命令</p>
<h2 id="采用web-hook"><a href="#采用web-hook" class="headerlink" title="采用web hook"></a>采用web hook</h2><p>这是 Github 提供的一种机制，使应用能与 Github 通讯。这种机制实际上就是 Pub/Sub，当 Github 监测到资源（如仓库）有变化就往预先设定的 URL 发送一个 POST 请求（Pub），告知变化情况，而后接收变化的服务器（Sub）即可做一些额外的事情。</p>
<p>这个思路需要有一个服务器并启动一个服务来接收 Github 的请求。这里又有种不同的策略，这两种策略都是基于源码放置在 Github 的前提。第一个是源码将最终文档直接部署在这台服务器上（如使用 Nginx），当接收到 Github 通知直接编译更新到服务器指定的文件夹下即可。另一种策略是当服务器接收到通知后编译更新，而后将编译后的版本提交到 Github 仓库的 gh-pages 分支，让 Github 做 Host。</p>
<h2 id="采用git-hook"><a href="#采用git-hook" class="headerlink" title="采用git hook"></a>采用git hook</h2><p>貌似必须要自己搭建git server。</p>
<h2 id="CI工具"><a href="#CI工具" class="headerlink" title="CI工具"></a>CI工具</h2><p>持续集成（英语：Continuous integration，缩写CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共用主线（mainline）的一种举措。<br>持续集成的提出主要是为解决软件进行系统集成时面临的各项问题，极限编程称这些问题为集成地狱（integration hell）。</p>
<p>常用工具 travis-ci  Jenkins</p>
<p>Jenkins是一个持续集成工具，相当于一个构建调度平台，围绕着scm，ssh, ant,maven插件，进行构建操作。<br>理论上来讲，有合适的插件，大部分自动化行为都可以在jenkins平台上展开。<br>使用Jenkins 来触发和调度，在Jenkins构建执行shell脚本来进行分发和安装，测试，可以部署成流水线的方式，依次运行</p>
<p>已实现</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>formatting</category>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
        <tag>自动化部署</tag>
        <tag>持续集成</tag>
        <tag>travis-ci</tag>
      </tags>
  </entry>
  <entry>
    <title>【Markdown系列】语法进阶 (Advanced Markdown Tips)</title>
    <url>/pub/7c655851/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><!--
## Inline HTML

You can also use raw HTML in your Markdown, and it'll mostly work pretty well.

-->

<p><code>markdown</code>语法简单方便，但要实现复杂的样式仍然要借助html标签。本文介绍常用的<code>html标签</code>，用于对<code>markdown</code>原生格式的增强。</p>
<!--
有些markdown render不支持内嵌html
-->


<h1 id="常用的标签"><a href="#常用的标签" class="headerlink" title="常用的标签"></a>常用的标签</h1><h2 id="折叠块-lt-summary-gt"><a href="#折叠块-lt-summary-gt" class="headerlink" title="折叠块 &lt;summary&gt;"></a>折叠块 <code>&lt;summary&gt;</code></h2><p>你和猪，打一种动物</p>
<details>
  <summary>点击展开答案</summary>
  <p> 象</p>
</details>

<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;点击展开答案&lt;/summary&gt;</span><br><span class="line">  &lt;p&gt; 象&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>

<p>通常用于FAQ页面。</p>
<!--
## click事件

这个要加js，比较复杂。也有不需要js的click，
-->



<h2 id="图片-lt-img-gt"><a href="#图片-lt-img-gt" class="headerlink" title="图片 &lt;img&gt;"></a>图片 <code>&lt;img&gt;</code></h2><p>markdown的语法不支持图片大小，位置等样式。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">图片链接 &quot;optional title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>所以可采用<code>&lt;img&gt;</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;=<span class="symbol">&amp;quot;</span>alternate_text<span class="symbol">&amp;quot;</span>&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://img5.2345.com/duoteimg/zixunImg/local/2016/03/18/14582940693488.gif&quot;</span> <span class="attr">title</span>=<span class="string">&quot;hover&quot;</span> <span class="attr">width</span>=<span class="string">&quot;20%&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<img align="middle" alt="图片样式" src="http://img5.2345.com/duoteimg/zixunImg/local/2016/03/18/14582940693488.gif" title="图片样式" width="20%" />




<h2 id="对齐-align"><a href="#对齐-align" class="headerlink" title="对齐 (align)"></a>对齐 (align)</h2><blockquote>
<p>学而不思则罔，思而不学则殆  <div style="text-align:right" >—— 《论语》</div></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:right&quot;</span> &gt;</span>-- 《论语》<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注释-comment"><a href="#注释-comment" class="headerlink" title="注释 (comment)"></a>注释 (comment)</h2><p>不在页面显示，一般写给自己看，或者写给编辑者看(比如提交issue的模板中附带的注释)</p>
<ul>
<li>方式一: 采用html注释标签    <code>&lt;!-- 这里不会显示  --&gt;</code></li>
<li>方式二: 直接采用&lt;标签   <code>&lt;这里不会显示&gt;</code></li>
</ul>
<p>推荐方式一</p>
<h2 id="代码块-code-block"><a href="#代码块-code-block" class="headerlink" title="代码块 (code block)"></a>代码块 (code block)</h2><h3 id="个性化设置code-block的样式"><a href="#个性化设置code-block的样式" class="headerlink" title="个性化设置code block的样式"></a>个性化设置<code>code block</code>的样式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;sample &lt;b&gt;sample&lt;/b&gt; sample&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<pre>sample <b>sample</b> sample</pre>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;i&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/dapper/man1/prename.1.html&quot;&gt;rename&lt;/a&gt;&lt;/i&gt; sfds</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<pre>
<i><span class="exturl" data-url="aHR0cDovL21hbnBhZ2VzLnVidW50dS5jb20vbWFucGFnZXMvZGFwcGVyL21hbjEvcHJlbmFtZS4xLmh0bWw=">rename<i class="fa fa-external-link-alt"></i></span></i> sfds
</pre>

<p><code>&lt;pre&gt;</code>标签更灵活。但是，不能显示行号，需要自定义每个元素的格式。</p>
<h3 id="code-block不常用的语言"><a href="#code-block不常用的语言" class="headerlink" title="code block不常用的语言"></a>code block不常用的语言</h3><p><code>diff</code>样式用的不多，但比较实用。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">public class Hello1</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line"><span class="deletion">-      System.Console.WriteLine(&quot;Hello, World!&quot;);</span></span><br><span class="line"><span class="addition">+      System.Console.WriteLine(&quot;Rock all night long!&quot;);</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态链接-link"><a href="#动态链接-link" class="headerlink" title="动态链接 (link)"></a>动态链接 (link)</h2><p>这部分属于需要动态link，需要借助<code>javascript</code>。因此需要markdown render支持（比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsZXRjaGVyL011bHRpTWFya2Rvd24vd2lraS9NdWx0aU1hcmtkb3duLVN5bnRheC1HdWlkZSNmb290bm90ZXM=">MultiMarkdown<i class="fa fa-external-link-alt"></i></span>），或者利用插件（比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tjaGVuMHgvaGV4by1yZWZlcmVuY2U=">hexo-reference<i class="fa fa-external-link-alt"></i></span>）</p>
<!--
### section link
-->

<h3 id="链接的集中管理"><a href="#链接的集中管理" class="headerlink" title="链接的集中管理"></a>链接的集中管理</h3><p>对link的集中管理，方便复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是[链接一][1]，这是[链接二][2]。多次引用更方便、更简洁，[链接一][1]。</span><br><span class="line"></span><br><span class="line">   [1]: http://url1</span><br><span class="line">   [2]: http://url2 &quot;这是2的标题，可以试着把指针移到链接二上&quot;</span><br></pre></td></tr></table></figure>

<p>这是<span class="exturl" data-url="aHR0cDovL3VybDEv">链接一<i class="fa fa-external-link-alt"></i></span>，这是<span class="exturl" data-url="aHR0cDovL3VybDIv">链接二<i class="fa fa-external-link-alt"></i></span>。多次引用更方便、更简洁，<span class="exturl" data-url="aHR0cDovL3VybDEv">链接一<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="脚注-footnote"><a href="#脚注-footnote" class="headerlink" title="脚注 (footnote)"></a>脚注 (footnote)</h3><ul>
<li><p>马克飞象支持footnote，它采用的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsZXRjaGVyL011bHRpTWFya2Rvd24vd2lraS9NdWx0aU1hcmtkb3duLVN5bnRheC1HdWlkZSNmb290bm90ZXM=">MultiMarkdown<i class="fa fa-external-link-alt"></i></span>，已经停止开发了。</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tjaGVuMHgvaGV4by1yZWZlcmVuY2U=">https://github.com/kchen0x/hexo-reference<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basic footnote[^demo]</span><br><span class="line"></span><br><span class="line">[^demo]: basic footnote content [title](http://link)</span><br></pre></td></tr></table></figure>



<h3 id="link总结"><a href="#link总结" class="headerlink" title="link总结"></a>link总结</h3><p>集中link和脚注link最好都放在文档末尾。区别是，前者只提供link，后者明文显示参考文献。我更倾向于后者。</p>
<blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTWFya2Rvd24=">维基百科<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="是否支持嵌入js？"><a href="#是否支持嵌入js？" class="headerlink" title="是否支持嵌入js？"></a>是否支持嵌入js？</h3><h3 id="是否支持Markdown-Inside-HTML-Blocks"><a href="#是否支持Markdown-Inside-HTML-Blocks" class="headerlink" title="是否支持Markdown Inside HTML Blocks?"></a>是否支持Markdown Inside HTML Blocks?</h3><blockquote>
<p>Markdown in HTML does not work very well  –来自官方文档</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkzNjg5MDIvaG93LWNhbi1pLXdyYXAtbXktbWFya2Rvd24taW4tYW4taHRtbC1kaXY=">部分支持<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>&lt;div&gt; *Emphasized* text. &lt;/div&gt;</code></li>
<li><input disabled="" type="checkbox"> <code>&lt;div&gt; ## dfd &lt;/div&gt;</code></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkYW0tcC9tYXJrZG93bi1oZXJlL3dpa2kvTWFya2Rvd24tQ2hlYXRzaGVldA==">Github-Markdown | 官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcC9oZXhvL3dpa2kvbWFya2Rvd25fc3ludGF4Lw==">Hexo-Markdown | 官方文档<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>formatting</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>【Markdown系列】marked渲染器</title>
    <url>/pub/c5991053/</url>
    <content><![CDATA[<p>hexo博客默认采用marked引擎进行markdown解析。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZWQuanMub3JnL2RlbW8v">online demo<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>formatting</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Dropbox差异同步算法rsync及其改进算法原理</title>
    <url>/pub/8c8e707b/</url>
    <content><![CDATA[<p>打个比方，你一共在两台电脑上（A,B）用同一个帐号的Dropbox，一共有三个文件（C，D，E），你在A电脑上删了（或者任意操作后保存）C，只要同步，B上面的C就会执行自行同步你在A上对C 的操作。至于Ipad上的同步，原理是一样。</p>
<h2 id="yskin说"><a href="#yskin说" class="headerlink" title="yskin说"></a>yskin说</h2><p>eDonkey2000（好吧，就是大家说的电驴）是这样实现的：把文件按固定大小分成几段，然后每段生成一个Hash码，然后再把所有Hash码合并成一个Hash码表，再对其生成一个Hash码，于是就成为了ed2k链接。下载的时候，先拿ed2k链接找人要到Hash码表，然后再根据码表分别下载每个片段。</p>
<p>Dropbox的增量同步也一样，每4M生成一个Hash码，然后更新的时候把码表和隐藏目录里存储的原码表做一下比较，发现1-10、12-20段都没有改变，只有11段不一样了，于是就只上传了第11段的数据。</p>
<h2 id="dunning说"><a href="#dunning说" class="headerlink" title="dunning说"></a>dunning说</h2><p>dropbox最初是采用了类似rsync的技术，但后来好像还是采用了Fix Sized Chunk进行。一个10MB的文档我曾经试过，修改1个字基本也有50%~70%左右的部分会被重新上传。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>是否有版本记录功能？跟git什么区别？</p>
<p>是否是增量同步？</p>
<p>如何解决冲突问题？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudjJleC5jb20vdC8zNTEyOA==">Dropbox的同步方式是怎样的？ | v2ex<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNTAxNTQ0">云存储或笔记的增量同步是如何实现的？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTQ2ODMwNS9mYThmMTMwN2VhNDczODIyNWZjYQ==">gist<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tL2luY3JlLXN5bmMtdXNlLXJzeW5jLmh0bWw=">基于rsync的文件增量同步方案 | 美团<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1c3NlbGxfdGFvL2FydGljbGUvZGV0YWlscy83MjQwNjYx">详解rsync算法–如何减少同步文件时的网络传输量<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
        <category>云存储-dropbox</category>
      </categories>
      <tags>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>一图知git</title>
    <url>/pub/cd67fa63/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先，这不是一个git命令教程，这是一个用于快速理解git命令的辅助文档。</p>
<p>用了git几年了，每次遇到疑难杂症都要现查，归其原因，是不了解git命令背后到底做了什么。</p>
<p>于是决定整理一下思路。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>存储位置</strong></p>
<ul>
<li><p>工作区：working_directory，working_tree，workspace</p>
</li>
<li><p>暂存区：stage, index  (加入到暂存区的更改：staged/indexed changes, add changes to stage/index)</p>
</li>
<li><p>本地仓库： local_repository, local_commit_history，history</p>
</li>
<li><p>远程仓库：remote_repository</p>
</li>
<li><p>快照：snapshot</p>
</li>
<li><p>Blobs:   即files</p>
</li>
</ul>
<p><strong>文件状态</strong></p>
<ul>
<li>Untrack file：新文件，从未被add的文件。下一步操作往往是<code>git add</code>或者加入<code>.gitignore</code>中</li>
<li></li>
</ul>
<p>**changes **</p>
<ul>
<li>Changes to be committed</li>
<li>Changes not staged for commit</li>
</ul>
<p><strong>操作</strong><br>stage操作：git add<br>commit操作：git commit</p>
<p><strong>指针</strong><br>指针指向实体</p>
<ul>
<li>HEAD指针<ul>
<li>正常状态: 指向一个<branch> (确切说是named branch)</li>
<li>Detached HEAD: 指向了anonymous branch，即<commit></li>
<li>null: 不可能出现这个状态</li>
</ul>
</li>
<li>master</li>
</ul>
<p><strong>HEAD指针状态</strong></p>
<p><strong>实体</strong><br>hash<br><commit>、<branch>、<tree-ish>、<start point>什么区别？<br>能写master<del>吗？能写 jkjdka</del>吗？</p>
<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjMzMDM1NDkvd2hhdC1hcmUtY29tbWl0LWlzaC1hbmQtdHJlZS1pc2gtaW4tZ2l0">https://stackoverflow.com/questions/23303549/what-are-commit-ish-and-tree-ish-in-git<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="上图"><a href="#上图" class="headerlink" title="上图"></a>上图</h2><img src="/images/raw/Git - summary.svg" height="110%" width="110%">



<p>有点紧凑，建议放大看</p>
<h2 id="看图说话"><a href="#看图说话" class="headerlink" title="看图说话"></a>看图说话</h2><p><strong>入门</strong>：<br><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1hZGQ=">git add<i class="fa fa-external-link-alt"></i></span> : 读取工作区文件，写入暂存区 (1个箭头代表1个写操作)</p>
<p><strong>进阶</strong>：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1jaGVja291dA==">git checkout &lt;branch&gt;<i class="fa fa-external-link-alt"></i></span>: 移动本地仓库中的HEAD指针到指定branch，更新index，更新工作区文件 (3个箭头)</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXNldA==">git reset –soft<i class="fa fa-external-link-alt"></i></span>：撤销指定commit，移动HEAD (不涉及工作区、暂存区、远程仓库的操作)</p>
<p>soft mixed hard三个参数的区别也一目了然<br>…</p>
<h2 id="所有涉及更改index区域的操作"><a href="#所有涉及更改index区域的操作" class="headerlink" title="所有涉及更改index区域的操作"></a><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1jb21taXQ=">所有涉及更改index区域的操作<i class="fa fa-external-link-alt"></i></span></h2><ul>
<li><p>git add</p>
</li>
<li><p>git rm</p>
</li>
<li><p>by listing files as arguments to the commit command (without –interactive or –patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</p>
</li>
<li><p>by using the -a switch with the commit command to automatically “add” changes from all known files (i.e. all files that are already listed in the index) and to automatically “rm” files in the index that have been removed from the working tree, and then perform the actual commit;</p>
</li>
<li><p>by using the –interactive or –patch switches with the commit command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the “Interactive Mode” section of git-add[1] to learn how to operate these modes.</p>
</li>
</ul>
<h2 id="逆向操作-undo"><a href="#逆向操作-undo" class="headerlink" title="逆向操作(undo)"></a>逆向操作(undo)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add                 <span class="comment"># 加入index</span></span><br><span class="line">git reset –mixed HEAD   <span class="comment"># 撤销index  对不，是checkout吗？</span></span><br><span class="line"></span><br><span class="line">git commit              <span class="comment">#</span></span><br><span class="line">git commit --amend  </span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~   <span class="comment"># 撤销尚未push的commit</span></span><br><span class="line"></span><br><span class="line">git add + git commit    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push    </span><br><span class="line">push不支持撤销操作       <span class="comment"># 如何撤销已经push的commit？</span></span><br><span class="line"></span><br><span class="line">git push –force         <span class="comment"># 覆盖远程仓库提交历史(太狠)</span></span><br><span class="line">                        <span class="comment"># 参考 https://www.borfast.com/blog/2014/10/19/how-to-undo-a-git-push---force-and-undelete-things/</span></span><br><span class="line">git rm file             <span class="comment"># 删除文件和index</span></span><br><span class="line">git checkout HEAD file  <span class="comment"># 恢复文件和index (index中已经没有该文件的信息，只能从仓库的HEAD中恢复文件)</span></span><br><span class="line"></span><br><span class="line">git rm -r dir           <span class="comment"># 删除整个目录及相应index</span></span><br><span class="line">git checkout HEAD dir   <span class="comment"># 恢复</span></span><br><span class="line"></span><br><span class="line">git add −p</span><br><span class="line">git reset −p</span><br><span class="line"></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git pull --rebase origin master  <span class="comment"># rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。</span></span><br><span class="line">                                 <span class="comment"># 如果你忘加了这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 </span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line">git rebase --abort       <span class="comment"># 碰到了冲突，但发现搞不定，这可以回到 git pull --rebase命令前的样子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个git add 会怎样？会merge为一个吧？git add + rm 前面的add的changes就完全丢了吧？</p>
<p>If you don’t have <code>uncommited changes</code> for removed files, the</p>
<p>如何撤销已经push的commit？</p>
<p>如何撤销已经force push的commit？</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9yZmFzdC5jb20vYmxvZy8yMDE0LzEwLzE5L2hvdy10by11bmRvLWEtZ2l0LXB1c2gtLS1mb3JjZS1hbmQtdW5kZWxldGUtdGhpbmdzLw==">https://www.borfast.com/blog/2014/10/19/how-to-undo-a-git-push---force-and-undelete-things/<i class="fa fa-external-link-alt"></i></span></p>
<p>Reset</p>
<h2 id="关于该图的改进"><a href="#关于该图的改进" class="headerlink" title="关于该图的改进"></a>关于该图的改进</h2><ul>
<li>捡重要的命令放 (init clone不要放)</li>
<li>布局，整体，有点丑</li>
</ul>
<h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2dpdC1yZWNpcGVzL2Jsb2IvbWFzdGVyL3NvdXJjZXMvJUU2JUEzJTgwJUU1JTg3JUJBJUU0JUJCJUE1JUU1JTg5JThEJUU3JTlBJTg0JUU2JThGJTkwJUU0JUJBJUE0Lm1k">https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E6%A3%80%E5%87%BA%E4%BB%A5%E5%89%8D%E7%9A%84%E6%8F%90%E4%BA%A4.md<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2dpdC1yZWNpcGVzL2Jsb2IvbWFzdGVyL3NvdXJjZXMvJUU0JUJCJUEzJUU3JUEwJTgxJUU1JTkwJTg4JUU1JUI5JUI2TWVyZ2UlRTglQkYlOTglRTYlOTglQUZSZWJhc2UubWQ=">代码合并：Merge、Rebase 的选择<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2dpdC1yZWNpcGVzL2Jsb2IvbWFzdGVyL3NvdXJjZXMvJUU5JTg3JThEJUU1JTg2JTk5JUU5JUExJUI5JUU3JTlCJUFFJUU1JThFJTg2JUU1JThGJUIyLm1k">重写项目历史<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2dpdC1yZWNpcGVzL2Jsb2IvbWFzdGVyL3NvdXJjZXMvJUU1JUI4JUI4JUU4JUE3JTgxJUU1JUI3JUE1JUU0JUJEJTlDJUU2JUI1JTgxJUU2JUFGJTk0JUU4JUJFJTgzLm1k">常见工作流比较<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkyMzU3L3doYXQtaXMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi1naXQtcHVsbC1hbmQtZ2l0LWZldGNoLzI5MjM1OQ==">https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch/292359<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2Nz">官方doc<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL21hcmtsb2RhdG8uZ2l0aHViLmlvL3Zpc3VhbC1naXQtZ3VpZGUvaW5kZXgtemgtY24uaHRtbA==">图解git<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理工具 - Everthing原理 之 还没看懂</title>
    <url>/pub/9299c162/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Everything is an Awesome Utility that Locates Files and Folders Instantly in Windows</p>
<p><code>Everything</code>仅支持windows系统的NTFS硬盘格式(不支持FAT、FAT32)。<code>Everything</code>默认对文件名、文件大小、日期以及其它某些meta data建索引，可<span class="exturl" data-url="aHR0cHM6Ly93d3cudm9pZHRvb2xzLmNvbS9zdXBwb3J0L2V2ZXJ5dGhpbmcvaW5kZXhlcy8jb3B0aW1pemluZ19mb3Jfc21hbGxlc3RfbWVtb3J5X2Zvb3RfcHJpbnQ=">关闭某些字段索引来加速<i class="fa fa-external-link-alt"></i></span>。</p>
<ol>
<li>建索引很快<ul>
<li>数据库文件 Everything.db。 这是什么类型的数据库？自定义的吗？</li>
</ul>
</li>
<li>搜索超快<ul>
<li>怎样建的索引？咋这么快？建了个hash索引？倒排索引？</li>
</ul>
</li>
<li>实时性好<ul>
<li>怎样获取的新文件列表？大量的临时文件要不要索引？</li>
</ul>
</li>
</ol>
<p><code>Everything</code>功能如此强大，让人不禁对其工作原理产生强烈的好奇心。<br>但是，<code>Everthing</code>官方<strong>未开源</strong>，这对想学习其工作原理的程序员来说是个bad news。官方提供<span class="exturl" data-url="aHR0cDovL3d3dy52b2lkdG9vbHMuY29tL3N1cHBvcnQvZXZlcnl0aGluZy9zZGsv">SDK<i class="fa fa-external-link-alt"></i></span>不知能否看出一些原理逻辑。待看</p>
<h2 id="啊哈，有相关开源项目"><a href="#啊哈，有相关开源项目" class="headerlink" title="啊哈，有相关开源项目"></a>啊哈，有相关开源项目</h2><p>微软某成员(疑似轮子哥)在codeplex开源了一个类似everything的个人项目<a href="https://archive.codeplex.com/?p=everythingsz"><code>everythingSZ</code></a>。以下介绍EverythingSZ的原理。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Everything搜索文件很快，是利用的NTFS分区的USN功能.</p>
<p>原理：</p>
<ul>
<li>读取NTFS下的USN日志文件<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvZXZlcnl0aGluZy9ibG9iL21hc3Rlci9Vc25PcGVyYXRpb24vVXNuT3BlcmF0b3IuY3M=">UsnOperator类源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>根据USN继续查询；</li>
<li>根据文件编号继续查询；</li>
<li>创建USN（激活USN状态）；</li>
<li>NTFS的Change Journal（更改日志）的方法实现监控功能</li>
</ul>
<blockquote>
<p>未采用 FileSystemWatcher 监听文件变化。(everthing不是采用的这个window api)</p>
</blockquote>
<h2 id="如何建索引"><a href="#如何建索引" class="headerlink" title="如何建索引"></a>如何建索引</h2><h2 id="如何监听文件变化"><a href="#如何监听文件变化" class="headerlink" title="如何监听文件变化"></a>如何监听文件变化</h2><p>这属于操作系统 &amp; 文件系统的范畴。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>即利用windows api。</p>
<p>以下几种方式：</p>
<ol>
<li>FindFirstChangeNotification<ul>
<li>无法获取是哪一个文件发生了改变。</li>
</ul>
</li>
<li>ReadDirectoryChangesW<ul>
<li>据说变化量大又密集时，丢失通知现象很严重</li>
</ul>
</li>
<li>FileSystemWatcher<ul>
<li>貌似是对ReadDirectoryChangesW的封装</li>
</ul>
</li>
<li>NTFS的Change Journal（更改日志）<ul>
<li>Change Journal是标卷上一个特殊的文件，系统将其隐藏，所以用资源管理器或者CMD Shell都看不到，当文件系统中的文件或者目录发生改变时，就会向日志中追加记录。<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fycm93enovYXJ0aWNsZS9kZXRhaWxzLzc1MzA0MDkx">参考<i class="fa fa-external-link-alt"></i></span></li>
<li>通过读取和监控USN（后面会讲）而不是扫描文件来构建索引，所以搜索速度飞快</li>
</ul>
</li>
</ol>
<p>Everything采用了第四种方式，即利用了NTFS系统的Change Journal特性。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><code>inotify</code> 命令<ul>
<li>是Linux自带的监控<code>inode</code>变动的函数</li>
<li>文档 <code>man 7 inotify</code></li>
</ul>
</li>
</ul>
<h1 id="其它疑问"><a href="#其它疑问" class="headerlink" title="其它疑问"></a>其它疑问</h1><h2 id="linux下有没有类似的工具"><a href="#linux下有没有类似的工具" class="headerlink" title="linux下有没有类似的工具"></a>linux下有没有类似的工具</h2><p>比linux下的find命令快，比locate命令实时性好。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8zMTA2My9pcy10aGVyZS1hLWZpbGUtc2VhcmNoLWVuZ2luZS1saWtlLWV2ZXJ5dGhpbmctaW4tbGludXg=">见stackexchange<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="参考-amp-待看"><a href="#参考-amp-待看" class="headerlink" title="参考 &amp; 待看"></a>参考 &amp; 待看</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvZXZlcnl0aGluZw==">EverythingSZ源码 - 轮子哥推荐 | Github C#<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3l1emhlbmd5YW5nL0V2ZXJ5dGhpbmc=">探索Everything背后的技术（USN和MFT）| Github<i class="fa fa-external-link-alt"></i></span></li>
<li> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbHVtbi9kZXRhaWxzLzE2NTc2Lmh0bWw=">NTFS系列<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hleGl5b25nL2FydGljbGUvZGV0YWlscy8xNzIwMDgyNw==">密切关注你的NTFS驱动器 | CSDN<i class="fa fa-external-link-alt"></i></span></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>文件管理</category>
        <category>everything</category>
      </categories>
      <tags>
        <tag>Everthing</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title>从hexo到hugo</title>
    <url>/pub/7959d50e/</url>
    <content><![CDATA[<h1 id="吐槽-hexo"><a href="#吐槽-hexo" class="headerlink" title="吐槽 hexo"></a>吐槽 hexo</h1><ul>
<li><strong>重量级</strong><ul>
<li>node_modules依赖特别大</li>
</ul>
</li>
<li><strong>慢</strong><ul>
<li>filter多，</li>
</ul>
</li>
</ul>
<p><strong>OOM</strong>:<br>在服务器端生成目前的700多篇文章占用大量内存，很难生成成功<br>1000+ 会造成OOM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory</span><br></pre></td></tr></table></figure>

<p>原因: Node.js 的内存限制？一个node进程大概只能使用 1GB 的内存。需要修改启动配置</p>
<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><ul>
<li>生成速度极快，几千篇文章的生成只需几秒，而且资源占用极少</li>
</ul>
<h1 id="吐槽hugo"><a href="#吐槽hugo" class="headerlink" title="吐槽hugo"></a>吐槽hugo</h1><ul>
<li>hexo 用 javascript 写的，一堆搞前端的人做主题。</li>
<li>hugo 用 go 写的，一堆搞后端的人做主题。<br>��，一堆搞后端的人做主题。</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>go-hugo</category>
      </categories>
  </entry>
  <entry>
    <title>【hexo系列】hexo的正确打开方式</title>
    <url>/pub/d3c1b8ca/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul>
<li>利用submodule管理blog  <!--
模块化，解耦合，易整合。hexo本身就是模块化很好的例子。cli server分离，主hexo与theme分离。generator deployer render分离。推荐一个模块化比较好的例子 https://github.com/distillpub</li>
<li>-&gt;<ul>
<li>先fork再add submodule</li>
</ul>
</li>
<li>利用branch管理自己的project和需要PR的project<!--
> 主要目的也是为了不和自己的修改绞在一起产生混乱。比如我从next仓库fork到我自己的仓库，然后我做了一些只用于我自己的个性化修改，这时候我的master分支和远程master分支之间的变动越来越大了。
然后我碰到一个适用于所有人的变动，这时候想提交个pr，最好的方式显然是切换到远程master分支，然后做修改，之后提交到一个新的分支，再然后就可以去github上提交pr了，不会把自己master上的一些修改混到里面
不过如果自己master和远程master始终保持完全一致的话倒是可以直接提交到自己master上，然后直接用自己master分支提交pr</li>
<li>-&gt;</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul>
<li>主仓库 blog<ul>
<li><code>themes/next/</code> 每个theme是一个子仓库  <!--(经常pull一下主题，有很多新功能和bug-fix。不用为了增加某些功能而自己改模板源文件，比如busuanzi，disqus的lazy_load)--></li>
<li><code>source/post/</code> 作为一个子仓库  </li>
<li><code>source/image/</code> 作为一个子仓库<!--
(可多终端同步文章),属于博客无关的。日常笔记</li>
<li>-&gt;<!--
`source/public` 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹。</li>
<li>-&gt;</li>
</ul>
</li>
</ul>
<p><strong>模块搭建&amp;整合流程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. fork hexo-starter 作为blog主仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive git@github.com:esblog/hexo-starter.git blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 submodule</span></span><br><span class="line"><span class="comment"># 2.1 fork theme &amp; add submodule</span></span><br><span class="line">$ <span class="built_in">cd</span> blog/themes/</span><br><span class="line">$ git submodule add git@github.com:esblog/hexo-theme-next.git next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 fork _post &amp; add submodule</span></span><br><span class="line">$ git submodule add git@github.com:esblog/_posts.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 fork project-u-like &amp; add submodule</span></span><br><span class="line">$ mkdir blog/<span class="built_in">source</span>/games/ &amp;&amp; <span class="built_in">cd</span> blog/<span class="built_in">source</span>/games/</span><br><span class="line">$ git submodule add git@github.com:esblog/2048.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否添加成功</span></span><br><span class="line">$ vi .gitmodules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. push到blog主仓库 (整合)</span></span><br><span class="line"><span class="built_in">cd</span> blog/</span><br><span class="line">git commit -m <span class="string">&quot;add submodules hexo-theme-next source/_post games/2048&quot;</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 如果你嫌fork太多，那么可以开一个github小号，管理这些fork。<br>github主账号只放deploy版本。</p>
</blockquote>
<p>实例：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzYmxvZy9lc2Jsb2cuZ2l0aHViLmlvL3RyZWUvZGV2">Dev Repository<i class="fa fa-external-link-alt"></i></span> Main project for all submodules</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzYmxvZy9lc2Jsb2cuZ2l0aHViLmlvLw==">Deployed Repository<i class="fa fa-external-link-alt"></i></span> is deployed by Hexo from <code>Dev Repository</code></li>
<li><span class="exturl" data-url="aHR0cDovL3h1c29uZy52aXAv">Demo Site<i class="fa fa-external-link-alt"></i></span> hosts the <code>Deployed Repository</code></li>
</ul>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><ul>
<li>每个module独立push</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. commit changes from all submodules (e.g. _posts)</span></span><br><span class="line">$ <span class="built_in">cd</span> _posts</span><br><span class="line">$ commit &amp; push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. commit changes from esblog.github.io</span></span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ commit &amp; push</span><br></pre></td></tr></table></figure>



<h2 id="pull-amp-merge"><a href="#pull-amp-merge" class="headerlink" title="pull &amp; merge"></a>pull &amp; merge</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git pull &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; git submodule status</span><br></pre></td></tr></table></figure>

<h2 id="clone-amp-setup"><a href="#clone-amp-setup" class="headerlink" title="clone &amp; setup"></a>clone &amp; setup</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master用于Gitpage的部署</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b dev --recursive git@github.com:esblog/esblog.github.io.git blog-dev</span><br><span class="line">$ <span class="built_in">cd</span> blog-dev</span><br><span class="line">$ git branch <span class="comment"># 确认已经切换到dev分支</span></span><br><span class="line">$ npm install hexo --save  <span class="comment"># install node_modules dependency</span></span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="从官方更新模块（操作较少）"><a href="#从官方更新模块（操作较少）" class="headerlink" title="从官方更新模块（操作较少）"></a>从官方更新模块（操作较少）</h2><p>比如，theme-next有些新功能 如何更新到自己的博客中？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git pull https://github.com/theme-next/hexo-theme-next.git</span><br><span class="line"><span class="comment"># 如果有冲突，需要人工merge</span></span><br></pre></td></tr></table></figure>

<p>也可在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzYmxvZy9oZXhvLXRoZW1lLW5leHQ=">theme的github界面<i class="fa fa-external-link-alt"></i></span>pull &amp; merge</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +&quot;date: %Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure>
<p>生成当前日期，用于放在博客文件头</p>
<h2 id="其他操作建议"><a href="#其他操作建议" class="headerlink" title="其他操作建议"></a>其他操作建议</h2><ul>
<li>每个post都加date，不然每次编辑文档，时间都会变动</li>
<li>draft 可以放在<code>_draft</code>目录下，当然我更习惯放在<code>_post/</code>中，文件名<code>_</code>开头即可，或者整个目录<code>_</code>开头。</li>
<li>文件名不要经常变动(因为会改变url)，title和path可以随时改动</li>
</ul>
<h2 id="非法操作"><a href="#非法操作" class="headerlink" title="非法操作"></a>非法操作</h2><ul>
<li>在<code>Deployed Repository</code>人工提交。(除非你不用hexo d命令，或不用hexo)</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo源码系列】 入门</title>
    <url>/pub/70d0eddc/</url>
    <content><![CDATA[<h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>为什么要看源码呢？因为想自己更便捷高效的管理博客，比如</p>
<ul>
<li>如何更新Hexo。(需要看<code>hexo init</code>的源码，因为该命令隐藏了<code>hexo-starter</code>项目)</li>
<li>如何更新theme。某些bug-fix&amp;新功能。(需要借助git的submodule来高效管理)</li>
<li>如何自己实现一个新功能(比如添加edit button，添加URL哈希。需要了解模板原理)</li>
</ul>
<p>源码不用细看，看个大概能满足自己的需求就够了。</p>
<p>本文仅介绍<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXN0YXJ0ZXI=">Hexo基础包<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3BsdWdpbnMv">扩展包<i class="fa fa-external-link-alt"></i></span>可参考【Hexo插件系列】博客。</p>
<h1 id="查看Hexo和Plugin版本"><a href="#查看Hexo和Plugin版本" class="headerlink" title="查看Hexo和Plugin版本"></a>查看Hexo和Plugin版本</h1><p>首先看一下自己的Hexo和Plugin版本，因为不同的版本是不同的实现。版本号是次要的，主要看是不是同一种包。比如<code>hexo-deployer-git</code>和<code>hexo-deployer-rsync</code>在执行<code>hexo d</code>命令时方式就不同。详见<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>查看<code>package.json</code>文件的依赖项。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;:</span> &#123;</span><br><span class="line">  <span class="attr">&quot;hexo&quot;:</span> <span class="string">&quot;^3.7.0&quot;</span>, <span class="comment"># https://github.com/hexojs/hexo/  hexo仅仅是一个module而已，用于...</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-archive&quot;:</span> <span class="string">&quot;^0.1.5&quot;</span>,  <span class="comment"># generator最复杂</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-category&quot;:</span> <span class="string">&quot;^0.1.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-index&quot;:</span> <span class="string">&quot;^0.2.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-tag&quot;:</span> <span class="string">&quot;^0.2.0&quot;</span>, <span class="comment"># nodejs的模板引擎，有EJS、Jade、Swig、Haml。theme-next采用的swig</span></span><br><span class="line">  <span class="attr">&quot;hexo-renderer-ejs&quot;:</span> <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-stylus&quot;:</span> <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-marked&quot;:</span> <span class="string">&quot;^0.3.2&quot;</span>,  <span class="comment"># markdown的render engine，即`.md`转`html`</span></span><br><span class="line">  <span class="attr">&quot;hexo-server&quot;:</span> <span class="string">&quot;^0.3.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可用以下命令查看版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm ls --depth 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更新各个模块，命令 npm update</p>
</blockquote>
<ul>
<li>hexo-cli，<ul>
<li>提供hexo init、hexo help、hexo version命令</li>
</ul>
</li>
<li>hexo<ul>
<li>hexo new</li>
<li>hexo generate</li>
</ul>
</li>
<li>hexo plugin，即node依赖<ul>
<li>hexo server</li>
<li>hexo deploy</li>
<li>其他命令</li>
</ul>
</li>
</ul>
<h1 id="回顾Hexo搭建流程"><a href="#回顾Hexo搭建流程" class="headerlink" title="回顾Hexo搭建流程"></a>回顾Hexo搭建流程</h1><p>以下来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2Jsb2IvbWFzdGVyL1JFQURNRS5tZA==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Installation</span></span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Setup your blog</span></span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Start the server</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create a new post</span></span><br><span class="line">$ hexo new <span class="string">&quot;Hello Hexo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Generate static files</span></span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>


<h1 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h1><h2 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h2><p>npm是nodejs的包管理器，管理javascript lib<br>hexo-cli是nodejs的一个包，用于运行hexo命令。(有cli难道还有server？)</p>
<p>npm list -g 能够看到安装路径。一般在/usr/lib/node_modules/ 或者/usr/local/lib/node_modules/</p>
<h2 id="2-hexo-init"><a href="#2-hexo-init" class="headerlink" title="2. hexo init"></a>2. hexo init</h2><p><code>hexo init</code>命令做了什么？</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p><code>hexo init</code>等价于以下两行shell命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Cloning hexo-starter to blog</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/hexojs/hexo-starter.git blog</span><br><span class="line"><span class="comment"># 2. Install dependencies</span></span><br><span class="line">$ npm install --production</span><br></pre></td></tr></table></figure>

<p>看到这里，就够用。如果自己的hexo项目是老版本的，可以在这个仓库pull更新(虽然更新很少)。<br>如果对追寻答案的过程感兴趣，可以继续往下看。</p>
<h3 id="追寻答案的旅程-optional"><a href="#追寻答案的旅程-optional" class="headerlink" title="追寻答案的旅程 - optional"></a>追寻答案的旅程 - optional</h3><p><strong>首先看一下hexo</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> hexo</span><br><span class="line">/usr/bin/hexo</span><br><span class="line"></span><br><span class="line">$ cat /usr/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">require(<span class="string">&#x27;../lib/hexo&#x27;</span>)();</span><br></pre></td></tr></table></figure>


<p>这里你会发现，hexo命令是nodejs脚本。 <code>../lib/hexo</code>对应的是<code>usr/lib/hexo</code>，然而没有path。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/hexo</span><br><span class="line"> /usr/bin/hexo -&gt; ../lib/node_modules/hexo-cli/bin/hexo</span><br></pre></td></tr></table></figure>

<p>原来<code>/usr/bin/hexo</code>是个符号链接，链接到nodejs的modules目录里。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat /usr/lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">require(<span class="string">&#x27;../lib/hexo&#x27;</span>)();</span><br></pre></td></tr></table></figure>

<p>即<code>hexo</code>命令对应的是<a href="https://github.com/hexojs/hexo-cli/blob/master/lib/hexo.js"><code>/usr/lib/node_modules/hexo-cli/lib/hexo.js</code></a>文件。</p>
<p>hexo找到了，init命令呢？讲道理应该是个package.json下的script。</p>
<p>原生<code>hexo-cli</code>提供了4个命令，都在<code>hexo-cli/lib/console</code>路径下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo help</span><br><span class="line">$ hexo init</span><br><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>扩展命令通过<code>hexo-cli/lib/extends.console.js</code>实现。</p>
<p><strong>hexo init 命令</strong></p>
<p><strong><code>init.js</code>核心代码</strong></p>
<p>路径<code>hexo-cli/lib/console/init.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> GIT_REPO_URL = <span class="string">&#x27;https://github.com/hexojs/hexo-starter.git&#x27;</span>;</span><br><span class="line"><span class="comment">// 1. git clone --recursive https://github.com/hexojs/hexo-starter.git blog</span></span><br><span class="line">log.info(<span class="string">&#x27;Cloning hexo-starter to&#x27;</span></span><br><span class="line">spawn(<span class="string">&#x27;git&#x27;</span>, [<span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--recursive&#x27;</span>, GIT_REPO_URL, target]);</span><br><span class="line">removeGitDir(target);</span><br><span class="line">removeGitModules(target);</span><br><span class="line"><span class="comment">// 2. npm install --production</span></span><br><span class="line">log.info(<span class="string">&#x27;Install dependencies&#x27;</span>);</span><br><span class="line">spawn(npmCommand, [<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--production&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>实际上吧，如果hexo的log打印出来<code>GIT_REPO_URL</code>就更清晰，非要藏起来等人挖掘。</p>
<p><strong>参考</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXN0YXJ0ZXI=">hexo-starter项目<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvaGV4by5qcw==">hexo.js源码 | hexo-cli 项目<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvY29uc29sZS9pbml0Lmpz">hexo init 命令源码 | hexo-cli 项目<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="3-hexo-server"><a href="#3-hexo-server" class="headerlink" title="3. hexo server"></a>3. hexo server</h2><p>这个不属于hexo-cli了。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXNlcnZlci9ibG9iL21hc3Rlci9saWIvc2VydmVyLmpz">hexo server命令源码<i class="fa fa-external-link-alt"></i></span></p>
<p>暂没兴趣，应该就是启了个nodejs HttpServer。待看</p>
<ul>
<li>额外的逻辑是，如果没generate，先调一下 hexo g</li>
</ul>
<p>但是偶尔出现的bug来源于<code>hexo s</code>，这里的逻辑还需要看一下。</p>
<h2 id="4-hexo-new"><a href="#4-hexo-new" class="headerlink" title="4. hexo new"></a>4. hexo new</h2><h2 id="5-hexo-generate"><a href="#5-hexo-generate" class="headerlink" title="5. hexo generate"></a>5. hexo generate</h2><p>生成器（Generator）<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9nZW5lcmF0b3IuaHRtbA==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>这个好麻烦，看不动了。这么多<code>generator</code>和<code>render</code>。</p>
<p>放个链接 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWdlbmVyYXRvci1pbmRleA==">https://github.com/hexojs/hexo-generator-index<i class="fa fa-external-link-alt"></i></span> ，貌似主要先看这个。</p>
<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>generates static files</p>
<p>这一步最慢。<br>常用的有hexo-renderer-marked<br>hexo-renderer-pandoc</p>
<h3 id="render-模板引擎"><a href="#render-模板引擎" class="headerlink" title="render 模板引擎"></a>render 模板引擎</h3><p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9yZW5kZXJlci5odG1s">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9yZW5kZXJpbmcuaHRtbA==">https://hexo.io/zh-cn/api/rendering.html<i class="fa fa-external-link-alt"></i></span></p>
<p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p>
<p>生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p>
<p>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</p>
<ul>
<li>.md解析成html</li>
<li>.swig渲染为html</li>
</ul>
<h3 id="数据的填充"><a href="#数据的填充" class="headerlink" title="数据的填充"></a>数据的填充</h3><p>数据的填充主要是 hexo -g 的时候将数据传递给 swig 模板，然后再由 swig 模板填充到 HTML 中。</p>
<h2 id="6-hexo-deploy"><a href="#6-hexo-deploy" class="headerlink" title="6. hexo deploy"></a>6. hexo deploy</h2><p>deploy到底干了什么？执行了git push？</p>
<p>deploy配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xu-song/xu-song.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p>
<p><strong>deploy.js核心源码</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWRlcGxveWVyLWdpdC9ibG9iL21hc3Rlci9saWIvZGVwbG95ZXIuanMjTDgz">https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js#L83<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git(<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;-A&#x27;</span>);  <span class="comment">// 对publc目录中执行add操作。</span></span><br><span class="line">git(<span class="string">&#x27;commit&#x27;</span>, <span class="string">&#x27;-m&#x27;</span>, message);</span><br><span class="line">git(<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;-u&#x27;</span>, repo.url, <span class="string">&#x27;HEAD:&#x27;</span> + repo.branch, <span class="string">&#x27;--force&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>即等价于以下几个命令(通常情况下)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ rm -rf .deploy_git  <span class="comment"># log.info(&#x27;Clearing .deploy_git folder...&#x27;);</span></span><br><span class="line">$ cp -rf public .deploy_git <span class="comment"># log.info(&#x27;Copying files from public folder...&#x27;);</span></span><br><span class="line">$ <span class="built_in">cd</span> .deploy_git</span><br><span class="line"></span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">&quot;Site updated: 2018-01-30 *:*:*&quot;</span> <span class="comment">#某时间</span></span><br><span class="line">$ git push -u origin HEAD:master --force</span><br></pre></td></tr></table></figure>

<p>上面命令使用–force选项，强制push到远程主机，会使远程主机更新的版本被覆盖。所以不要在deploy之后的仓库做提交，要在dev仓库提交。</p>
<p>实例：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hzdW5nL2Jsb2ctZGV2LyNzdWJtb2R1bGU=">Dev Repository<i class="fa fa-external-link-alt"></i></span> Main project for all submodules</li>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcveHUtc29uZy5naXRodWIuaW8v">Deployed Repository<i class="fa fa-external-link-alt"></i></span> is deployed by Hexo from <code>Dev Repository</code></li>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cDovL3h1c29uZy52aXAv">Demo Site<i class="fa fa-external-link-alt"></i></span> hosts the <code>Deployed Repository</code></li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s">hexo deploy官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWRlcGxveWVyLWdpdC9ibG9iL21hc3Rlci9saWIvZGVwbG95ZXIuanM=">hexo deploy.js源码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NoZXJyeWJsb2cuc2l0ZS9oZXhvLTQuaHRtbA==">http://cherryblog.site/hexo-4.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NoZXJyeWJsb2cuc2l0ZS9oZXhvLTQuaHRtbA==">深入理解 Hexo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NvZGVydW50aGluZ3MuY29tLzIwMTcvMDgvMjAvaG93aGV4b3dvcmtzLw==">hexo是怎么工作的<i class="fa fa-external-link-alt"></i></span><h2 id="7-Hexo-的模板引擎"><a href="#7-Hexo-的模板引擎" class="headerlink" title="7. Hexo 的模板引擎"></a>7. Hexo 的模板引擎</h2>这个<code>render</code>讲道理应该是在<code>hexo g</code>的时候调用的。 待看</li>
</ul>
<h1 id="如何debug-hexo"><a href="#如何debug-hexo" class="headerlink" title="如何debug hexo"></a>如何debug hexo</h1><p>调试hexo，实质就是调试nodejs</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>源码</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo简介</title>
    <url>/pub/80e7b4b1/</url>
    <content><![CDATA[<h2 id="Hexo剖析"><a href="#Hexo剖析" class="headerlink" title="Hexo剖析"></a>Hexo剖析</h2><p>中文文档：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">https://hexo.io/zh-cn/docs/<i class="fa fa-external-link-alt"></i></span><br>官方主题库：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">https://hexo.io/themes/<i class="fa fa-external-link-alt"></i></span><br>next主题：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ=">https://github.com/theme-next<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Hexo原理综述"><a href="#Hexo原理综述" class="headerlink" title="Hexo原理综述"></a>Hexo原理综述</h2><p>markdown到html的旅程</p>
<ul>
<li>模板渲染</li>
<li>模板渲染</li>
</ul>
<h2 id="hexo文件结构"><a href="#hexo文件结构" class="headerlink" title="hexo文件结构"></a>hexo文件结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">├── _config.yml     <span class="comment"># 站点配置文件</span></span><br><span class="line">├── db.json     <span class="comment"># database，缓存文件</span></span><br><span class="line">├── node_modules  <span class="comment"># 安装的插件以及hexo所需的一些node.js模块</span></span><br><span class="line">├── package.json  <span class="comment"># 应用程序信息，配置hexo运行需要的js包</span></span><br><span class="line">├── public     <span class="comment"># deploy时生成，最终所见网页的所有内容</span></span><br><span class="line">├── scaffolds  <span class="comment"># 模板文件夹，hexo默认包含以下三种布局(layout)    https://hexo.io/zh-cn/docs/writing.html</span></span><br><span class="line">│     ├──draft.md   <span class="comment"># hexo new draft &lt;title&gt; 会在source/_drafts目录下生成md文件</span></span><br><span class="line">│     ├──page.md  <span class="comment"># hexo new page &lt;title&gt; 在source目录下</span></span><br><span class="line">│     └──post.md   <span class="comment"># hexo new post &lt;title&gt;  在source/_posts目录下生成md文件</span></span><br><span class="line">├── source    <span class="comment"># 资源文件夹。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</span></span><br><span class="line">│     ├── _draft  <span class="comment"># 除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略</span></span><br><span class="line">│     └── _posts  <span class="comment">#</span></span><br><span class="line">│             └──  hello-world.md</span><br><span class="line">└── themes   <span class="comment">#主题文件夹</span></span><br><span class="line">      ├──</span><br><span class="line">      └──<span class="built_in">next</span></span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br></pre></td></tr></table></figure>


<h2 id="详解clean"><a href="#详解clean" class="headerlink" title="详解clean"></a>详解clean</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo clean --debug</span><br><span class="line"></span><br><span class="line">INFO  Deleted database.       <span class="comment"># 清空 db.json</span></span><br><span class="line">INFO  Deleted public folder.  <span class="comment"># 删除public目录</span></span><br></pre></td></tr></table></figure>

<h2 id="详解hexo-g"><a href="#详解hexo-g" class="headerlink" title="详解hexo g"></a>详解hexo g</h2><p>每次运行 hexo g 命令，hexo(node.js程序)会遍历你的 source 目录，建立索引，根据你 theme 文件夹的主题生成页面到 public 文件夹。这时 public 文件夹就是一个纯由 html javascript css 等内容制作的博客，而这些恰好能在 git pages 识别</p>
<h2 id="详解deploy"><a href="#详解deploy" class="headerlink" title="详解deploy"></a>详解deploy</h2><p>最后 hexo d 将 public 文件夹的内容复制到临时目录，以 git 方式 push 到 github 的指定项目的指定分支，由 github 进行显示</p>
<p>首次deploy</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo d --debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 首先加载plugin和theme</span></span><br><span class="line">DEBUG Config loaded: ~/xs/blog/_config.yml</span><br><span class="line">DEBUG Plugin loaded: hexo-generator-category</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 开始转化html</span></span><br><span class="line">INFO  Start processing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 处理404页面</span></span><br><span class="line">DEBUG Processed: <span class="built_in">source</span>/404.html  <span class="comment"># 404不需要theme</span></span><br><span class="line">DEBUG Processed: 404.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 加载主题，处理source目录下的.md .html</span></span><br><span class="line">DEBUG Theme config loaded.</span><br><span class="line">DEBUG Processed: _config.yml  <span class="comment"># 这个也需要处理？</span></span><br><span class="line">DEBUG Processed: <span class="built_in">source</span>/css/main.styl  <span class="comment"># 处理source目录下所有文件，包括js image md</span></span><br><span class="line">DEBUG Processed: layout/archive.swig   <span class="comment"># 处理layout languages等</span></span><br><span class="line"></span><br><span class="line">DEBUG Generator: page  <span class="comment"># 还包括post category archive index tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成html，存储在public目录</span></span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 796 ms  <span class="comment">#</span></span><br><span class="line">DEBUG Rendering page: 404.html</span><br><span class="line">DEBUG Rendering post: 2018/01/25/hello-world/index.html</span><br><span class="line">DEBUG Rendering archive: archives/index.html</span><br><span class="line">DEBUG Rendering index: index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. deploy: 创建git repo，在public中拷贝文件，并push</span></span><br><span class="line">INFO  Deploying: git</span><br><span class="line">Initialized empty Git repository   <span class="comment"># git init</span></span><br><span class="line">INFO  Copying files from public folder...  <span class="comment"># 从public复制到.deploy_git目录</span></span><br><span class="line">INFO  Copying files from extend <span class="built_in">dirs</span>...</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git  <span class="comment"># commit &amp; push 已完成</span></span><br><span class="line">DEBUG Database saved</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="详解hexo-server"><a href="#详解hexo-server" class="headerlink" title="详解hexo server"></a>详解hexo server</h2><p>hexo s –debug</p>
<h2 id="hexo的模板引擎-Rendering-HTML"><a href="#hexo的模板引擎-Rendering-HTML" class="headerlink" title="hexo的模板引擎,Rendering HTML"></a>hexo的模板引擎,Rendering HTML</h2><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p>
<p>source 文件夹理解为数据库，而theme文件夹相当于 界面。 hexo g 就将我们的数据和界面相结合生成静态文件 public。</p>
<p>Hexo 的模板引擎是默认使用 ejs 编写的，同类型的东西还有很多，比如jade，swig。</p>
<p>next选用的swig</p>
<h2 id="比较赞的设计"><a href="#比较赞的设计" class="headerlink" title="比较赞的设计"></a>比较赞的设计</h2><ul>
<li>文件名与博客名分离，即title不直接采用文件名。(这样保证了不会因为title的变动引起url的变动)</li>
<li>url路径与实际路径分离 ()</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><span class="exturl" data-url="aHR0cDovL2NvZGVydW50aGluZ3MuY29tLzIwMTcvMDgvMjAvaG93aGV4b3dvcmtzLw==">http://coderunthings.com/2017/08/20/howhexoworks/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何托管你的网站 - 托管服务器</title>
    <url>/pub/65131a14/</url>
    <content><![CDATA[<h1 id="Host-网站托管"><a href="#Host-网站托管" class="headerlink" title="Host - 网站托管"></a>Host - 网站托管</h1><p>web hosting (service)可以被翻译为：网站托管。这里的host，类似于“主持、主办、提供”的含义。</p>
<p>大体分Iaas和PaaS两种</p>
<ul>
<li>IaaS：云主机(或虚拟机) - 权限大，费用贵<ul>
<li>阿里云主机、Google云主机(GCE)、腾讯云主机等</li>
</ul>
</li>
<li>PaaS：云平台(运行软件的平台) - 权限小，便宜或免费<ul>
<li>动态网站托管平台：SAE、GAE等</li>
<li>静态网站托管平台：github pages服务、coding pages服务</li>
</ul>
</li>
</ul>
<!-- Saas：云应用(软件)。我们的网站本身就是应用级别的，要搭建在平台或主机上。-->
<blockquote>
<p><strong>注意区分</strong>：<br>github的仓库(repo)是版本控制软件，是github提供的SaaS服务。<br>github的Pages服务用于网站托管，是github提供的PaaS服务。</p>
</blockquote>
<p>鉴于免费，很多人采用Pages服务来托管自己的网站(个人博客等）。</p>
<!--
github仓库属于软件级别，里面的代码。
我们的网站在github仓库，则作为软件级别的子内容。

-->

<h2 id="关于静态网站-动态网站"><a href="#关于静态网站-动态网站" class="headerlink" title="关于静态网站 动态网站"></a>关于静态网站 动态网站</h2><h3 id="纯静态网站"><a href="#纯静态网站" class="headerlink" title="纯静态网站"></a>纯静态网站</h3><h3 id="静态网站-自己搭建后台应用"><a href="#静态网站-自己搭建后台应用" class="headerlink" title="静态网站 + 自己搭建后台应用"></a>静态网站 + 自己搭建后台应用</h3><p>例如 wordpress的方式。</p>
<p>需要自己租用服务器，自己搭建应用</p>
<h3 id="免费静态网站-免费动态服务平台"><a href="#免费静态网站-免费动态服务平台" class="headerlink" title="免费静态网站 + 免费动态服务平台"></a>免费静态网站 + 免费动态服务平台</h3><p><strong>福利</strong>: 全免费</p>
<p>静态网站建站现在有很多快速的技术和平台。静态网站简单，但是存在很多局限性。</p>
<p>很多网站提供了常用的动态服务，比如评论、流量统计、实时聊天。我们只需要调用其接口，而不用自己租服务器搭建后台应用。</p>
<p>常用的免费动态服务有：</p>
<ul>
<li><strong>评论</strong>: 多说、畅言、disqus、gitment 等，</li>
<li><strong>流量统计</strong>: 百度统计、google统计、不蒜子</li>
<li><strong>实时聊天</strong>:</li>
</ul>
<h2 id="云主机-贵"><a href="#云主机-贵" class="headerlink" title="云主机 - 贵"></a>云主机 - 贵</h2><h2 id="GAE-限额免费"><a href="#GAE-限额免费" class="headerlink" title="GAE - 限额免费"></a>GAE - 限额免费</h2><p>Google App Engine是Google提供的基于Google数据中心的开发、托管网络应用程序的平台，每个 Google App Engine 应用程序都可使用1GB存储空间和每天1G的流量，GAE对于使用资源有各种限制，跑动态网站往往会配置不够用，但如果网站使用纯粹的静态HTML建立，那么这种网站还是可以支持较大的访问量。</p>
<p>GAE网站的<code>免费额度</code>限制主要是：文件总容量小于1G，文件数量少于1万个，每天流量小于1G，由于静态网站对于CPU消耗很少，因此CPU的运算限制可以忽略，通常来说，这样的配额对于普通中小型网站已经足够了。</p>
<h2 id="Pages服务-免费-适合纯静态网站-简单"><a href="#Pages服务-免费-适合纯静态网站-简单" class="headerlink" title="Pages服务 - 免费 - 适合纯静态网站 - 简单"></a>Pages服务 - 免费 - 适合纯静态网站 - 简单</h2><h1 id="图片服务器"><a href="#图片服务器" class="headerlink" title="图片服务器"></a>图片服务器</h1><h2 id="图片服务器的优势"><a href="#图片服务器的优势" class="headerlink" title="图片服务器的优势"></a>图片服务器的优势</h2><p>总得来说，部署图片服务器有以下几点好处：</p>
<ul>
<li>分担 Web 服务器的 I/O 负载 - 将耗费资源的图片服务分离出来，提高服务器的性能和稳定性</li>
<li>能够专门对图片服务器进行优化 - 为图片服务设置有针对性的缓存方案，减少带宽成本，提高访问速度</li>
<li>提高网站的可扩展性 - 通过增加图片服务器，提高图片吞吐能力</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>案例：又拍云存储<br>又拍云是通用的大规模存储服务，主要为用户提供静态文件存储以及 CDN 加速的服务。</p>
<p>又拍云在静态文件存储方面有多年的技术经验，一直专注于静态文件存储处理领域。</p>
<p>又拍云存储在全国各地有 26 个 CDN 节点 ， 300 多台服务器以及电信、联通、移动和教育网四线带宽，能够让用户以极低的价格获得可靠、安全和快速的基础存储服务。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL证书</title>
    <url>/pub/c08a993/</url>
    <content><![CDATA[<h1 id="为什么要用HTTPS？"><a href="#为什么要用HTTPS？" class="headerlink" title="为什么要用HTTPS？"></a>为什么要用HTTPS？</h1><p>HTTP 协议是不加密传输数据的，也就是用户跟你的网站之间传递数据有可能在途中<strong>被截获</strong>，破解传递的真实内容，所以使用不加密的 HTTP 的网站是不太安全的。所以， Google 的 Chrome 浏览器将在 2017 年 1 月开始，标记使用不加密的 HTTP 协议的网站为 Not Secure，不安全。</p>
<p>HTTPS 会为您的网站建立加密的信息安全通道，保证数据传输的安全，防止传输内容被第三方冒充或篡改。</p>
<p>部署 HTTPS 网站的时候需要证书，证书由 CA 机构签发，大部分传统 CA 机构签发证书是需要收费的，这不利于推动 HTTPS 协议的使用。</p>
<h2 id="证书的类型"><a href="#证书的类型" class="headerlink" title="证书的类型"></a>证书的类型</h2><p>SSL证书没有所谓的“品质”和“等级”之分，只有三种不同的类型。SSL证书需要向国际公认的证书证书认证机构（简称CA，Certificate Authority）申请。<code>CA机构</code>颁发的证书有3种类型：</p>
<ul>
<li><strong>域名型SSL证书</strong>（DV SSL）：信任等级普通，只需验证网站的真实性便可颁发证书保护网站；  </li>
<li><strong>企业型SSL证书</strong>（OV SSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高；</li>
<li><strong>增强型SSL证书</strong>（EV SSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高，同时可以激活绿色网址栏。</li>
</ul>
<h3 id="SSL证书的颁发机构-CA机构"><a href="#SSL证书的颁发机构-CA机构" class="headerlink" title="SSL证书的颁发机构 - CA机构"></a>SSL证书的颁发机构 - CA机构</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcv">Let’s Encrypt<i class="fa fa-external-link-alt"></i></span>: Let’s Encrypt 是目前使用范围最为广泛的免费 SSL 证书，而且官方博客宣布，自 2018 年开始提供通配符 SSL 证书，也就是 wildcard certificates。<ul>
<li>在线申请网址1（中文）：<span class="exturl" data-url="aHR0cHM6Ly9mcmVlc3NsLm9yZy8=">https://freessl.org/<i class="fa fa-external-link-alt"></i></span></li>
<li>在线申请网址2（英文）：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3NsZm9yZnJlZS5jb20v">https://www.sslforfree.com/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>Symantec</li>
<li>GeoTrust</li>
<li>TrustAsia 亚信</li>
<li><a href="alwaysonssl.com/">AlwaysOnSSL</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tb2RvLmNvbS8=">Comodo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20v">Cloudflare<i class="fa fa-external-link-alt"></i></span>: Cloudflare 很早就开始提供免费 SSL 证书，前提是你的域名要放在 Cloudflare 解析，注册为 Free Plan 就可以。</li>
</ul>
<p>自从 Let’s encrypt 开始提供免费DV SSL后，SSL 证书市场就已经开始洗牌了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Issued by: Encryption Everywhere DV TLS CA - G1</span><br><span class="line">Issued by: Let&#x27;s Encrypt Authority X3</span><br></pre></td></tr></table></figure>

<h2 id="第三方机构-辅助申请证书"><a href="#第三方机构-辅助申请证书" class="headerlink" title="第三方机构 - 辅助申请证书"></a>第三方机构 - 辅助申请证书</h2><p><strong>阿里云</strong><br>阿里云提供免费DV SSL证书</p>
<ul>
<li>Symantec 免费版 单域名证书 - 免费</li>
<li>GeoTrust <strong>通配符</strong>DV SSL证书 - 收费</li>
</ul>
<p><strong>又拍云</strong> 免费提供 Let’s Encrypt 和 Symantec 签发的两款 DV SSL 证书，也是业内唯一一家提供两种。立即签署颁发，并实现了Let’s Encrypt 自动续期功能。</p>
<p><strong>腾讯</strong>的就是方便，不过时间只有一年。</p>
<p><strong>cloudflare</strong> 免费版并不是很快。而且他强制你 nameserver 指过去(可把域名解析都托管过去，也可只托管指定主机）</p>
<p><strong>coding.net</strong> coding pages会自动给证书续期</p>
<img src="/images/raw/建站 - HTTPS - CodingPages.png">

<blockquote>
<p>注意：申请 SSL/TLS 证书需要通过 Let’s Encrypt 的 HTTP 方式验证域名所有权。如果您的域名在境外无法访问 Coding Pages 的服务器，将导致 SSL/TLS 证书申请失败。</p>
</blockquote>
<h2 id="Let’s-Encrypt证书"><a href="#Let’s-Encrypt证书" class="headerlink" title="Let’s Encrypt证书"></a>Let’s Encrypt证书</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NTc4NDIy">SSL 证书服务，大家用哪家的？<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>Let’s Encrypt：免费，快捷，支持多域名，三条命令即时签署+导出证书。缺点是暂时</li>
<li>2018年3月14日，Let’s Encrypt 对外宣布 ACME v2 已正式支持<code>通配符证书</code>。</li>
</ul>
<p>Let’s encrypt 的免费证书默认有效期为 90 天，到期后如果要续期可以执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certbot-auto renew</span><br></pre></td></tr></table></figure>

<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>要使用 HTTPS，你需要安全机构颁发的安全证书，然后配置服务器，去使用这个证书。下面介绍一下在阿里云免费申请安全证书，还有配置一般的 NGINX 服务器支持 HTTPS 的方法。</p>
<ol>
<li>申请证书、绑定域名</li>
<li>下载证书</li>
<li>使用证书: 配置 相应的Web服务器</li>
</ol>
<h3 id="github-pages如何使用SSL证书？"><a href="#github-pages如何使用SSL证书？" class="headerlink" title="github pages如何使用SSL证书？"></a>github pages如何使用SSL证书？</h3><p>虽然 Github 早在2016年就已经为 <code>*.github.io</code> 添加了 HTTPS 支持，但自定义域名开启 HTTPS 却是一件令人头疼的事情。大家只能使用 Cloudflare 之类的支持 SSL 的 CDN 曲线支持 HTTPS 。</p>
<p><strong>好消息</strong>: 2018年5月1日，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdpdGh1Yi5jb20vMjAxOC0wNS0wMS1naXRodWItcGFnZXMtY3VzdG9tLWRvbWFpbnMtaHR0cHMv">GitHub 宣布与 Let&#39;s Encrypt 合作<i class="fa fa-external-link-alt"></i></span>，为 Github Pages 自定义域名提供官方的HTTPS 支持。如果在 Github Pages 绑定了域名，现在可以使用 Let&#39;s Encrypt 签发的 SSL 证书为绑定的域名开启 HTTPS 访问。</p>
<p>如果 <code>enforce HTTPS</code> 不可勾选，并且提示 <code>Not yet available for your site because the certificate has not finished being issued</code> ，说明证书尚未申请完成，等待一天即可。</p>
<p>github pages采用的github的服务器，不能直接设置https，但可以<strong>通过CDN来设置SSL</strong>。</p>
<ul>
<li>github_pages + cloudflare（cdn+https）</li>
<li>gitpage + 又拍云(cdn,https)</li>
</ul>
<blockquote>
<p>又拍云需要域名备案</p>
</blockquote>
<h2 id="cloudflare"><a href="#cloudflare" class="headerlink" title="cloudflare"></a>cloudflare</h2><h3 id="配置CDN流程"><a href="#配置CDN流程" class="headerlink" title="配置CDN流程"></a>配置CDN流程</h3><ol>
<li>进入万网控制台</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20va25vd2xlZGdlX2RldGFpbC8zOTg0NS5odG1s">修改dns服务器<i class="fa fa-external-link-alt"></i></span>，默认dns服务器 dns1.hichina.com,dns2.hichina.com，修改成cloudflare的dns服务器</li>
</ol>
<blockquote>
<p>To use Cloudflare, you need to change your domain’s authoritative DNS servers, which are also referred to as nameservers.</p>
</blockquote>
<p>用 cloudflare,但是他要我更换 dns 服务器，更换后貌似导致域名访问不了 coding pages 的服务器了。原因是cloudflare接管DNS解析后，不支持双线部署。</p>
<h3 id="设置https"><a href="#设置https" class="headerlink" title="设置https"></a>设置https</h3><ul>
<li>在CF的Crypto页中，SSL设置为Flexible。这将允许CDN到github pages之间的访问为http。</li>
<li>现在，通过https://你的域名已经可以访问站点首页了。</li>
</ul>
<h3 id="强制https"><a href="#强制https" class="headerlink" title="强制https"></a>强制https</h3><p>CF提供Page Rules功能，可设置路由规则。通过规则中的<code>Always use https</code>选项，可以将用户强制跳转到https</p>
<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNoaW9ubGFiLm1vZS8yMDE2LzAxLzI4L2dpdGh1Yi1wYWdlcy13aXRoLWh0dHBzLw==">https://blog.chionlab.moe/2016/01/28/github-pages-with-https/<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="证书信息"><a href="#证书信息" class="headerlink" title="证书信息"></a>证书信息</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">网站:</span> <span class="string">blog.eson.org</span></span><br><span class="line"><span class="string">颁发给:</span> <span class="string">sni90514.cloudflaressl.com</span>  <span class="comment"># 这个是</span></span><br></pre></td></tr></table></figure>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>它的原理是当访客使用 HTTPS 访问站点的时候，</p>
<ol>
<li>从访客到 Cloudflare</li>
<li>然后从 Cloudflare 到站点这段是明文的</li>
</ol>
<p>s</p>
<div id="sequence-0"></div>

<p>虽然不是全程加密，假设从 Cloudflare 到站点的信道相对可靠的话，也能很大程度上解决中间人劫持的问题。</p>
<ul>
<li>更改DNS服务器。这样万网域名<code>eson.org</code>中的所有配置失效，转由cloudflare提供DNS解析服务。<ul>
<li>但是cloudflare没有线路配置，也就没必要双线部署了</li>
</ul>
</li>
<li>DNS导向到github page之前，进行了缓存。</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjI3NzYzMw==">关于免费SSL证书的那些事儿 | 知乎<i class="fa fa-external-link-alt"></i></span><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">浏览器->Cloudflare: 加密数据
Cloudflare-->web服务器: 明文</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>SSL证书</category>
      </categories>
  </entry>
  <entry>
    <title>将Hexo博客到同时部署到Github和Coding实现全球快速访问。</title>
    <url>/pub/41fcf36a/</url>
    <content><![CDATA[<p>coding.net采用https<br>github pages怎样采用https呢？</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>多线，指多条解析线路(isp)。</p>
<p>如果访问量特别大，可以多线部署，比如分别部署电信、网通等多条线路，或者不同省份的线路。这里我们仅采用国内线路、海外线路两种。</p>
<p>一个主机头可以分别解析不同的线路、不同IP，当用户访问网站的时候，智能DNS会判断出他们的线路并解析给他们对应线路的IP，以达到最快的访问速度</p>
<h2 id="配置hexo的-config文件"><a href="#配置hexo的-config文件" class="headerlink" title="配置hexo的_config文件"></a>配置hexo的_config文件</h2><p>这样在执行hexo deploy命令时就会同时部署到github和coding，由于之前已经配置了ssh，所以这里并不需要输密码 非常方便。</p>
<h2 id="DNS解析的配置"><a href="#DNS解析的配置" class="headerlink" title="DNS解析的配置"></a>DNS解析的配置</h2><p><img src="/images/raw/建站 - DNS解析 - 配置.png"></img></p>
<p>主要配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">记录类型</span>  <span class="string">解析线路(isp)</span>  <span class="string">记录值</span></span><br><span class="line"><span class="string">CNAME</span>    <span class="string">世界</span>           <span class="string">xu-song.github.io</span>  <span class="comment"># 海外线路采用github page</span></span><br><span class="line"><span class="string">CNAME</span>    <span class="string">默认</span>           <span class="string">xu-song.coding.me</span>  <span class="comment"># 国内线路采用coding page</span></span><br></pre></td></tr></table></figure>

<h2 id="在coding和github绑定自己的域名"><a href="#在coding和github绑定自己的域名" class="headerlink" title="在coding和github绑定自己的域名"></a>在coding和github绑定自己的域名</h2><h2 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h2><p>方式一：<span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9kbnMv">http://tool.chinaz.com/dns/<i class="fa fa-external-link-alt"></i></span><br>可测试 DNS 服务器的可用性和响应时间</p>
<p><img src="/images/raw/建站 - DNS双线部署 - 服务器测速.png"></img></p>
<p>美国、香港、台湾已经是解析的github的地址，国内的dns解析的是coding的地址。</p>
<p>方式二：<span class="exturl" data-url="aHR0cDovL2NlLmNsb3VkLjM2MC5jbi8=">http://ce.cloud.360.cn/<i class="fa fa-external-link-alt"></i></span></p>
<p>方式三：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://dns/</span><br><span class="line">查看DNS解析的地址</span><br><span class="line"></span><br><span class="line">chrome://net-internals/#dns</span><br><span class="line">更多功能请参考</span><br><span class="line"></span><br><span class="line">chrome://chrome-urls/</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>以上方式，github的</p>
<h1 id="双线部署方案"><a href="#双线部署方案" class="headerlink" title="双线部署方案"></a>双线部署方案</h1><p>方案列表：</p>
<ol>
<li>Github + Coding + DNS双线解析。简单，但github不能对独立域名配置HTTPS</li>
<li>Github + CloudFlare + Coding + DNS双线解析。实现双线部署，双线HTTPS</li>
</ol>
<h2 id="如何对js-image等资源设置多线CDN？"><a href="#如何对js-image等资源设置多线CDN？" class="headerlink" title="如何对js image等资源设置多线CDN？"></a>如何对js image等资源设置多线CDN？</h2><p>比如有些google的js国内访问不到，需要采用国内的镜像CDN资源。</p>
<p>另外，图片、js、css等静态文件可以使用CDN加速，一些公共的js、css可以使用一些公共CDN，比如百度CDN，其余资源可以上传到七牛云来加速。</p>
<h2 id="如何在html页面动态显示连接线路？"><a href="#如何在html页面动态显示连接线路？" class="headerlink" title="如何在html页面动态显示连接线路？"></a>如何在html页面动态显示连接线路？</h2><p>根据访问的路线，动态显示Hosted by Coding Pages 或者 Github Pages。</p>
<p>dns解析过程在页面解析之前。。前端无法获取到这个信息。</p>
<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>为了双线部署，且启用 SSL 。当前版本采用了</p>
<ul>
<li>国内线路：万网NDS +  Coding_Pages(提供Lets’ Encrypt免费SSL证书)</li>
<li>境外线路：万网DNS + CloudFlare_Name_Server(提供CDN+CloudFlare免费SSL证书) + Github_Pages</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>blog</tag>
        <tag>pages</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>为静态网站提供动态服务之 统计模块</title>
    <url>/pub/995f103a/</url>
    <content><![CDATA[<h1 id="汇总-对比"><a href="#汇总-对比" class="headerlink" title="汇总  对比"></a>汇总  对比</h1><p>site_uv 是指访问的用户个数，一个IP记一次，多次访问不累加<br>site_pv 是网站访问次数，多次访问累加<br>page_pv 是文章点击次数，多次访问累加</p>
<table>
<thead>
<tr>
<th></th>
<th>google统计</th>
<th>百度统计</th>
<th>Leancloud.cn</th>
<th>不蒜子</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td></td>
<td></td>
<td>功能繁杂</td>
<td>轻量级，无需注册，两行代码</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>要注册</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>功能</td>
<td></td>
<td></td>
<td></td>
<td>pv uv</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="速度-对比"><a href="#速度-对比" class="headerlink" title="速度 对比"></a>速度 对比</h2><p>不蒜子的js放在七牛，速度应该不慢，如果说速度慢，可能是七牛的原因，</p>
<h2 id="初始化首次数据"><a href="#初始化首次数据" class="headerlink" title="初始化首次数据"></a>初始化首次数据</h2><p>初始化首次数据无非就两种方式</p>
<ol>
<li>修改服务器的数据库数据 (多数不提供该服务，因为随意篡改数据就失去了数据权威性)</li>
<li>仅更改本网站的显示 (so easy，也可以理解成自己欺骗自己)</li>
</ol>
<p>首先看方式二：以不蒜子为例</p>
<p>在html中引入以下js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修正不蒜子计数初始值 --&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> &gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> int = <span class="built_in">setInterval</span>(fixCount, <span class="number">50</span>);  <span class="comment">// 50ms周期检测函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> countOffset = <span class="number">20000</span>;  <span class="comment">// 初始化首次数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">           <span class="function"><span class="keyword">function</span> <span class="title">fixCount</span>(<span class="params"></span>) </span>&#123;                   </span></span></span><br><span class="line"><span class="javascript"><span class="xml">             <span class="keyword">if</span> ($(<span class="string">&quot;#busuanzi_container_site_pv&quot;</span>).css(<span class="string">&quot;display&quot;</span>) != <span class="string">&quot;none&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  $(<span class="string">&quot;#busuanzi_value_site_pv&quot;</span>).html(<span class="built_in">parseInt</span>($(<span class="string">&quot;#busuanzi_value_site_pv&quot;</span>).html()) + countOffset); <span class="comment">// 加上初始数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  <span class="built_in">clearInterval</span>(int); <span class="comment">// 停止检测</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">             &#125;  </span></span></span><br><span class="line"><span class="javascript"><span class="xml">         &#125;           </span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<p>这里的方法是改给自己看，并未改动busuanzi的数据库。</p>
<p>方式一，看各家提供的接口咯</p>
<h3 id="不蒜子的方式"><a href="#不蒜子的方式" class="headerlink" title="不蒜子的方式"></a>不蒜子的方式</h3><blockquote>
<p>“不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许您初始化首次数据。<br>请先注册登录，自行修改阅读次数。<br>— 来自不蒜子官网</p>
</blockquote>
<p>然而，至今不蒜子尚未提供注册服务(2018年3月)，也就是不蒜子暂时也不提供 <code>修改统计数据的接口</code>。</p>
<p>实际上并未改初始化首次数据的方式。因为</p>
<h1 id="单独介绍"><a href="#单独介绍" class="headerlink" title="单独介绍"></a>单独介绍</h1><h2 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h2><p>“不蒜子”是通过页面url（或者主机名神马的）来标识一个计数值，而像localhost、index.html这样的名字早已经被像我们一样的广大程序猿在测试时用烂了，自然就累计了好多次</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>plugin-for-static-site</category>
      </categories>
      <tags>
        <tag>静态网站</tag>
        <tag>插件</tag>
        <tag>动态服务</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题</title>
    <url>/pub/51a8c99e/</url>
    <content><![CDATA[<h2 id="现状-amp-原因"><a href="#现状-amp-原因" class="headerlink" title="现状 &amp; 原因"></a>现状 &amp; 原因</h2><h3 id="github做了什么。"><a href="#github做了什么。" class="headerlink" title="github做了什么。"></a>github做了什么。</h3><ul>
<li><code>robots.txt</code> 中屏蔽了baidu</li>
<li>即使百度爬虫无视robots协议强抓github，github也会通过<code>检查UA</code>，返回<code>403 forbidden</code>，即<code>拒绝访问</code>。(当然如果要想强抓是拦不住的，伪装一下UA即可)</li>
</ul>
<h3 id="造成的现状"><a href="#造成的现状" class="headerlink" title="造成的现状"></a>造成的现状</h3><ul>
<li>robots.txt 失效</li>
<li>sitemap 失效</li>
</ul>
<blockquote>
<p>原因：github在robots.txt中屏蔽了百度，百度默认不抓取github的内容。</p>
</blockquote>
<ul>
<li>主动提交失效</li>
<li>自动提交失效</li>
<li>手动提交失效</li>
</ul>
<blockquote>
<p>Github是通过 UA 来判定百度爬虫并返回 403 Forbidden 的</p>
</blockquote>
<blockquote>
<p>而百度爬虫的UA一般固定为 Mozilla/5.0 (compatible; Baiduspider/2.0; +<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20vc2VhcmNoL3NwaWRlci5odG1s">http://www.baidu.com/search/spider.html<i class="fa fa-external-link-alt"></i></span>)</p>
</blockquote>
<blockquote>
<p>即使向百度提交了页面，github服务器一看UA是百度爬虫，就直接拒绝访问</p>
</blockquote>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ol>
<li>换其他host服务器，比如coding.net</li>
<li>CDN<ul>
<li>百度爬虫不要直接向 Github 的服务器发送请求，而是通过 CDN 边缘服务器的缓存来抓取网站的内容。边缘服务器本身是不会关心 UA 的，所以问题就迎刃而解了。</li>
<li><span class="exturl" data-url="aHR0cDovL2plcnJ5em91LmNvbS9wb3N0cy9mZWFzaWJpbGl0eS1vZi1hbGxvd2luZy1iYWlkdVNwaWRlci1mb3ItR2l0aHViLVBhZ2VzLw==">也不靠谱<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZG96ZXIuY2MvMjAxNS8wNi9naXRodWItcGFnZXMtYW5kLWNkbi5odG1s">https://www.dozer.cc/2015/06/github-pages-and-cdn.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwODk4MzI2">https://www.zhihu.com/question/30898326<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>seo</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>搜索引擎</tag>
        <tag>robots协议</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止搜索引擎收录的方法</title>
    <url>/pub/c429c70d/</url>
    <content><![CDATA[<h1 id="什么是robots协议"><a href="#什么是robots协议" class="headerlink" title="什么是robots协议"></a>什么是robots协议</h1><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。搜索引擎抓取网站内容前会先抓取robots.txt，据此“自觉地”抓取或者不抓取该网页内容，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。</p>
<p>需要注意的是robots协议并非是规范，只是行业内一个约定俗成的协议。什么意思呢?Robots协议不是什么技术壁垒，而只是一种互相尊重的协议，好比私家花园的门口挂着“闲人免进”，尊重者绕道而行，不尊重者依然可以推门而入，比如说360。</p>
<p>如果网站有数据需要保密，必需采取技术措施，比如说：用户验证，加密，ip拦截，访问频率控制等。</p>
<h1 id="为什么要禁止搜索引擎收录"><a href="#为什么要禁止搜索引擎收录" class="headerlink" title="为什么要禁止搜索引擎收录"></a>为什么要禁止搜索引擎收录</h1><ol>
<li>某些路径下是个人隐私或者网站管理使用，不想被搜索引擎抓取</li>
<li>不喜欢某个搜索引擎，不愿意被他抓取，最有名的就是之前淘宝不希望被百度抓取</li>
<li>流量有限或者需要付费，希望搜索引擎抓的温柔点。</li>
<li>阻止竞争抓取自己的网站内容，比如搜索引擎之间相互屏蔽，360</li>
</ol>
<h1 id="robots的屏蔽恩怨历史"><a href="#robots的屏蔽恩怨历史" class="headerlink" title="robots的屏蔽恩怨历史"></a>robots的屏蔽恩怨历史</h1><p>汇总</p>
<table>
<thead>
<tr>
<th></th>
<th>百度</th>
<th>google</th>
<th>bing</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>淘宝</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>不屏蔽google，因为google不做淘宝的竞价排名。另外还能作为淘宝流量入口</td>
</tr>
<tr>
<td>京东</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>微信公众平台</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>社交网络–开放空间</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>weibo</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>facebook</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>twitter</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>社交网络–隐私空间</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qq空间</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>微信朋友圈</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>baidu、google</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>搜索引擎，屏蔽一切搜索引擎爬虫</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="github-屏蔽百度、搜狗、360等"><a href="#github-屏蔽百度、搜狗、360等" class="headerlink" title="github - 屏蔽百度、搜狗、360等"></a>github - 屏蔽百度、搜狗、360等</h2><h3 id="为什么屏蔽百度"><a href="#为什么屏蔽百度" class="headerlink" title="为什么屏蔽百度"></a>为什么屏蔽百度</h3><blockquote>
<p>We are currently blocking the Baidu user agent from crawling GitHub Pages sites in response to this user agent being responsible for an excessive amount of requests, which was causing availability issues for other GitHub customers.</p>
</blockquote>
<blockquote>
<p>This is unlikely to change any time soon, so if you need the Baidu user agent to be able to crawl your site you will need to host it elsewhere.</p>
</blockquote>
<blockquote>
<p>– by <span class="exturl" data-url="aHR0cDovL2plcnJ5em91LmNvbS9wb3N0cy9mZWFzaWJpbGl0eS1vZi1hbGxvd2luZy1iYWlkdVNwaWRlci1mb3ItR2l0aHViLVBhZ2VzLw==">Github Support<i class="fa fa-external-link-alt"></i></span> Jerry’s blog</p>
</blockquote>
<p>即百度爬虫爬得太猛烈，已经对很多 Github 用户造成了可用性的问题了，而禁用百度爬虫这一举措可能会一直持续下去。</p>
<p>白名单中竟然有 EtaoSpider。why？<br>为什么百度中搜索<code>site:github.io</code>有结果？</p>
<p><code>www.github.com</code>中的<a href="www.github.com/robots.txt">robots.txt</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Googlebot</span>   <span class="comment"># google yandex等都在白名单。</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/*/*/tree/master</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/*/*/blob/master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span>   </span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/humans.txt</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>      <span class="comment"># 百度不在白名单，即整个站点屏蔽百度</span></span><br></pre></td></tr></table></figure>

<p>除设置了robots.txt之外，github后台服务器还会检查HTTP请求的UA，如果是百度就返回403 forbidden。</p>
<p><strong>更新</strong> 2020.11 github不再屏蔽百度</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you would like to crawl GitHub contact us via https://support.github.com/</span></span><br><span class="line"><span class="comment"># We also provide an extensive API: https://developer.github.com/</span></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">baidu</span>   <span class="comment"># 这是开放了百度的抓取，只不过限制频率？</span></span><br><span class="line"><span class="attr">crawl-delay:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/*/pulse</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/*/tree/</span></span><br></pre></td></tr></table></figure>


<h2 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h2><h3 id="淘宝-屏蔽百度"><a href="#淘宝-屏蔽百度" class="headerlink" title="淘宝 - 屏蔽百度"></a>淘宝 - 屏蔽百度</h3><ul>
<li>争夺流量入口</li>
<li></li>
<li>.</li>
</ul>
<p>2008年淘宝屏蔽了百度搜索引擎，自此用户再也无法从百度直接搜索到关于淘宝的信息。</p>
<p>淘宝网站曾经屏蔽百度搜索爬虫，禁止百度搜索引擎抓取淘宝网站的网页内容，淘宝官方的解释是“杜绝不良商家欺诈”。</p>
<p>首先，在08年9月淘宝先屏蔽了百度搜索，使得当我们在百度搜索淘宝产品名时，百度返回不到有效信息。导致普通网民在进行网上购物行为时，会直接选择登陆淘宝网，用站内搜索进行，从上网入口上讲，淘宝这样就让网民一步到位了，而不是单单记住百度这个工具，淘宝的流量肯定会水涨船高，带来的好处也不言而明。</p>
<p>如果当初淘宝没有屏蔽百度，不多说：最起码30%的购物搜索会来自百度。淘宝屏蔽百度以后，淘宝真正的成为了购物的第一入口。</p>
<p>淘宝主页<code>www.taobao.com</code>的<a href="www.taobao.com/robots.txt">robots.txt</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Baiduspider</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/article</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oshtml</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/product/</span>  <span class="comment"># 禁止百度抓取www.taobao.com/product/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>          <span class="comment"># 屏蔽网站其他路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Googlebot</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/article</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oshtml</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/product</span>   <span class="comment"># 对google很宽松，即开放google入口，</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/spu</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/dianpu</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oversea</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/list</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>
<p>淘宝商品页面<code>item.taobao.com</code>的<span class="exturl" data-url="aHR0cHM6Ly9pdGVtLnRhb2Jhby5jb20vcm9ib3RzLnR4dA==">robot.txt<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Baiduspider</span>   <span class="comment"># 百度，你被完全屏蔽了</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Googlebot</span>     <span class="comment"># 对google和bing开放</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/item.htm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">Bingbot</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/item.htm</span></span><br></pre></td></tr></table></figure>

<p>搜索示例：</p>
<ol>
<li>关键词搜索 - 百度</li>
</ol>
<ul>
<li><code>洗面奶 淘宝</code> 搜不到淘宝的商品。</li>
<li><code>洗面奶 京东</code> 能搜到京东的商品。</li>
</ul>
<ol start="2">
<li>站点搜索 - 百度</li>
</ol>
<ul>
<li><code>site:www.taobao.com 洗面奶</code> 竟然能搜索<code>www.taobao.com/product/</code>中的页面，点进去是无效商品链接</li>
<li><code>site:www.jd.com 洗面奶</code> 能搜到京东的商品</li>
</ul>
<h3 id="京东-屏蔽一淘-阿里-惠惠-网易"><a href="#京东-屏蔽一淘-阿里-惠惠-网易" class="headerlink" title="京东 - 屏蔽一淘(阿里) 惠惠(网易)"></a>京东 - 屏蔽一淘(阿里) 惠惠(网易)</h3><p>京东和阿里向来水火不容，京东不准用户使用支付宝支付，也因为新浪和阿里的关系不准用户用新浪微博登录。2011年10月，京东和当年淘宝屏蔽百度一样，毅然屏蔽了一淘搜索。失去京东这么大的一个电商平台，一淘可谓流年不顺。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/?*</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/pop/*.html</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/pinpai/*.html?*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">EtaoSpider</span>  <span class="comment"># 屏蔽一淘</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">HuihuiSpider</span> <span class="comment"># 屏蔽惠惠购物助手</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<p>阿里旗下自家的比价产品一淘网曾因抓取京东的商品数据而被京东通过代码进行干扰，刘强东亦亲自出来抨击一淘网，但是嘴仗一时痛快，最终的结果却是一淘至今仍然可以索引京东，而京东的抗争只能是停止与支付宝的合作。</p>
<p>为什么taobao不屏蔽惠惠购物助手？</p>
<p>这是阿里抛出的交易筹码，即如果比价软件想要全年抓取天猫淘宝等站的数据，作为与我这边发放通行证的交换，比价软件需要遵从的是在“双十一”期间主动阉割，否则就会尝到终身制的闭门羹。</p>
<p>参考–<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM3MzY5OTk2">如何看待惠惠购物助手被迫在双十一期间停止比价功能？<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="amazon"><a href="#amazon" class="headerlink" title="amazon"></a>amazon</h3><h2 id="社交网络-媒体"><a href="#社交网络-媒体" class="headerlink" title="社交网络/媒体"></a>社交网络/媒体</h2><h3 id="QQ空间"><a href="#QQ空间" class="headerlink" title="QQ空间"></a>QQ空间</h3><p>QQ空间自05年诞生时就没有开放给百度与谷歌，和Facebook一样封闭。QQ的逻辑是要将QQ空间打造成一个巨大的闭环，唯一的搜索只能是旗下的搜搜。</p>
<p>2012年的时候，QQ空间也终于向百度与谷歌开放。</p>
<p>现在网友多数将自己的空间设置的为加密空间、非好友不能访问，所以里面的日志是没办法搜索；</p>
<h3 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h3><h3 id="微信公众平台-屏蔽所有"><a href="#微信公众平台-屏蔽所有" class="headerlink" title="微信公众平台 - 屏蔽所有"></a>微信公众平台 - 屏蔽所有</h3><p>微信做了公众账号后，积累了大量高质量的作者和文章。为了对这种优质数据进行独家保护，微信利用robot协议，不允许所有搜索引擎进行内容抓取。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-Agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/$</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/debug/</span>   <span class="comment"># 微信公众平台接口调试工具</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/qa/</span>  </span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/wiki/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/cgi-bin/loginpage</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>     <span class="comment"># 公众号文章</span></span><br></pre></td></tr></table></figure>

<p>后来，腾讯投资搜狗，开放微信数据供搜狗搜索独家使用，<span class="exturl" data-url="aHR0cDovL3dlaXhpbi5zb2dvdS5jb20v">搜狗 微信搜素<i class="fa fa-external-link-alt"></i></span>，将微信的公众号文章嵌入了搜狗搜索中。</p>
<h2 id="Facebook-屏蔽谷歌搜索"><a href="#Facebook-屏蔽谷歌搜索" class="headerlink" title="Facebook -  屏蔽谷歌搜索"></a>Facebook -  屏蔽谷歌搜索</h2><p>Facebook屏蔽谷歌的原因也很简单，用户在Facebook上产生的内容势必会有能够带来商业价值的数据并且同时也涉及到用户隐私，所以Facebook也同样不会将这些数据轻易交付给第三方的。facebook至今仍然屏蔽谷歌搜索。</p>
<h2 id="新闻站点"><a href="#新闻站点" class="headerlink" title="新闻站点"></a>新闻站点</h2><h3 id="默多克旗下新闻-屏蔽谷歌搜索，后来又开放"><a href="#默多克旗下新闻-屏蔽谷歌搜索，后来又开放" class="headerlink" title="默多克旗下新闻 - 屏蔽谷歌搜索，后来又开放"></a>默多克旗下新闻 - 屏蔽谷歌搜索，后来又开放</h3><p>从传统媒体起家的默多克，对于搜索引擎的态度相当不友善，默多克曾说<code>搜索引擎是“网络寄生虫”</code>。</p>
<p>默多克原话“他们是Google,他们是微软,他们是Ask.com,他们不应该免费获得内容,我想我们一直睡着了.”而默多克在09年开始展开计划，对谷歌等搜索引擎展开行动，对旗下多家新闻网站屏蔽搜索爬虫。</p>
<p>谷歌的回应也很简单明了”如果贵站不想在谷歌上出现，请修改贵站的robots文件即可“。不过到了2012年，默多克就投降了，<code>默多克向谷歌认输，重新允许搜索抓取报纸网站</code>。其实默多克的想法还是停留在传统的付费阅读的思维上，缺少对网络的深刻洞察。</p>
<h2 id="搜索引擎-互相屏蔽-偷抓"><a href="#搜索引擎-互相屏蔽-偷抓" class="headerlink" title="搜索引擎 - 互相屏蔽 - 偷抓"></a>搜索引擎 - 互相屏蔽 - 偷抓</h2><p>sogou、baidu、360、google</p>
<p><span class="exturl" data-url="aHR0cDovL3RlY2guMTYzLmNvbS8xNC8wODA3LzEyL0EzMVVKUzVQMDAwOTE1QkQuaHRtbA==">百度诉360违反Robots协议 一审判360赔偿70万<i class="fa fa-external-link-alt"></i></span><br>360方面认为，Robots协议并不具有任何法律效力，而是百度利用了Robots协议自设白名单，谷歌、微软必应、雅虎、搜狗、SOSO等搜索引擎均可以抓取这些内容，唯独禁止360搜索抓取，属于打压竞争对手，涉嫌违反《反垄断法》。</p>
<p><span class="exturl" data-url="aHR0cDovL2x1c29uZ3NvbmcuY29tL2Jsb2cvcG9zdC8xNDcyLmh0bWw=">网曝百度不顾robots协议擅自抓取微信内容<i class="fa fa-external-link-alt"></i></span> baidu通过大量抓取<a href="weixin.sogou.com">搜狗中的微信数据</a>，将其放入搜索结果中，用于提升自己的搜索体验。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM4OTM3NzE2">百度违反 Robots 协议抓搜狗数据，有图有真相有撕逼 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
<p>搜狗与360曾互诉对方不正当竞争，并提出千万级别的索赔。</p>
<p>sogou偷爬baidu，baidu偷爬搜狗</p>
<p><span class="exturl" data-url="aHR0cDovL3dlaXhpbi5zb2dvdS5jb20v">http://weixin.sogou.com<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2x1c29uZ3NvbmcuY29tL3JlZWQvNzMyLmh0bWw=">2013年，百度诉奇虎360违反“Robots协议”抓取、复制其网站内容的不正当竞争行为一案，索赔金额高达一亿元<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHV4aXUuY29tL2FydGljbGUvMjE2OTYuaHRtbA==">虎嗅-盘点那些robots的屏蔽恩怨历史<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="如果搜索引擎不遵守robot协议呢？"><a href="#如果搜索引擎不遵守robot协议呢？" class="headerlink" title="如果搜索引擎不遵守robot协议呢？"></a>如果搜索引擎不遵守robot协议呢？</h1><p>搜索引擎不遵守robot协议，对网站都抓，会违法吗？</p>
<p>robot协议是规定还是法律，不遵守robot协议是道德问题还是法律问题？<br>robots.txt 协议不是法律法规，也不是行业规范。但是一个搜索引擎声称自己遵守 robots.txt 协议那就有道德责任遵守。</p>
<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><h1 id="如何在技术上反爬虫"><a href="#如何在技术上反爬虫" class="headerlink" title="如何在技术上反爬虫"></a>如何在技术上反爬虫</h1><p>检查UA</p>
<h1 id="s"><a href="#s" class="headerlink" title="s"></a>s</h1>]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>seo</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>搜索引擎</tag>
        <tag>域名</tag>
        <tag>robot协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo中的SEO技巧</title>
    <url>/pub/8b29356c/</url>
    <content><![CDATA[<h2 id="关于keywords"><a href="#关于keywords" class="headerlink" title="关于keywords"></a>关于keywords</h2><p>为每个post添加tag，因为tag会被放入页面的<code>keywords</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% if page.keywords %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&#123;&#123; page.keywords &#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">&#123;% elif page.tags and page.tags.length %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>


<p>每个页面 keywords 的选择顺序，是按照如下优先顺序进行</p>
<ol>
<li>page 中定义的 keywords</li>
<li>page 中定义的 tags</li>
<li>_config.yml 中定义的 keywords (hexo中定义的keyword，不是theme的config)</li>
</ol>
<p>源码<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2Jsb2IvbWFzdGVyL2xpYi9wbHVnaW5zL2hlbHBlci9vcGVuX2dyYXBoLmpz">https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/open_graph.js<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2xheW91dC9fcGFydGlhbHMvaGVhZC9oZWFkLXVuaXF1ZS5zd2ln">https://github.com/theme-next/hexo-theme-next/blob/master/layout/_partials/head/head-unique.swig<i class="fa fa-external-link-alt"></i></span></p>
<p>建议tags标签和keywords标签都加。由于keywords在页面不会展示，因此添加更自由，添加面向SEO的标签。</p>
<h2 id="关于robots-txt-和-sitemap-xml"><a href="#关于robots-txt-和-sitemap-xml" class="headerlink" title="关于robots.txt 和 sitemap.xml"></a>关于robots.txt 和 sitemap.xml</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5yZXN0cmFuLm5ldC8yMDE3LzA1LzAyL2hleG8tY3VzdG9tLWh0bWwtbWV0YS1rZXl3b3Jkcy8=">http://www.restran.net/2017/05/02/hexo-custom-html-meta-keywords/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>seo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>domain</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>微信网页版 聊天原理</title>
    <url>/pub/855d5922/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>微信网页版聊天，未采用websocket，而是基于long polling(长轮询)。</p>
<h2 id="客户端消息发送"><a href="#客户端消息发送" class="headerlink" title="客户端消息发送"></a>客户端消息发送</h2><h2 id="客户端消息接收（伪服务端推送）"><a href="#客户端消息接收（伪服务端推送）" class="headerlink" title="客户端消息接收（伪服务端推送）"></a>客户端消息接收（伪服务端推送）</h2><ol>
<li>客户端间隔性发送http请求sync（每隔）<span class="exturl" data-url="aHR0cHM6Ly9yZXMud3gucXEuY29tL2Evd3hfZmVkL3dlYnd4L3Jlcy9zdGF0aWMvanMvaW5kZXhfY2EzNjBmZi5qcw==">源码<i class="fa fa-external-link-alt"></i></span>; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvd3gucXEuY29tL2Jsb2IvbWFzdGVyL3Jlcy53eC5xcS5jb20vYS93eF9mZWQvd2Vid3gvcmVzL3N0YXRpYy9qcy9pbmRleF9jYTM2MGZmLmpz">beauty后的源码<i class="fa fa-external-link-alt"></i></span></li>
<li>服务端对该请求延时返回，强制建立长连接</li>
<li>当服务端有需要推送的消息，即时在已建立的长连接中返回http response</li>
<li>客户端收到response后，立即发送一个新的http request</li>
<li>goto 2</li>
</ol>
<h3 id="客户端发送http-request"><a href="#客户端发送http-request" class="headerlink" title="客户端发送http request"></a>客户端发送http request</h3><p>客户端间隔性发送ajax请求</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Request URL:</span> <span class="string">https://webpush.wx.qq.com/cgi-bin/mmwebwx-bin/synccheck?</span></span><br><span class="line"><span class="attr">Referrer Policy:</span> <span class="literal">no</span><span class="string">-referrer-when-downgrade</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Query String Parameters</span></span><br><span class="line"><span class="attr">r:</span> <span class="number">151</span><span class="string">**</span></span><br><span class="line"><span class="attr">skey:</span> <span class="string">@crypt_d8e**</span></span><br><span class="line"><span class="attr">sid:</span> <span class="string">a5ne**</span></span><br><span class="line"><span class="attr">uin:</span> <span class="number">1709</span><span class="string">**</span></span><br><span class="line"><span class="attr">deviceid:</span> <span class="string">e2387***</span></span><br><span class="line"><span class="attr">synckey:</span> <span class="string">1_677803136|2_677803**</span></span><br><span class="line"><span class="attr">_:</span> <span class="number">1517</span><span class="string">**</span></span><br></pre></td></tr></table></figure>
<p>这是一个服务器端强制保持的长连接。</p>
<h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2VsZWN0cm9uaWMtd2VjaGF0">网页微信的封装，直接在 Electron 里加载微信的网页版，并向其中注入一些代码<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL2VsZWN0cm9uaWMtd2VjaGF0L2lzc3Vlcy8y">网页版微信抓包+注入实现表情贴纸显示<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGVXZWNoYXQvd2VjaGF0NHU=">微信网页版的 JavaScript 实现，兼容Node和浏览器，微信机器人<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VyaW54L1dlaXhpbkJvdA==">微信网页版的 Python 实现，包含终端版微信及微信机器人<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZWVlZWVlZWVrL1dlQ2hhdEx1Y2t5TW9uZXk=">微信抢红包插件–基于安卓<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzY2NTU0ODE1">微信聊天功能使用了什么协议？<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p> 原理 教程</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlTW9iaWxlRGV2L2FydGljbGUvYmxvYi9tYXN0ZXIvJUU1JTlGJUJBJUU0JUJBJThFVExTMS4zJUU3JTlBJTg0JUU1JUJFJUFFJUU0JUJGJUExJUU1JUFFJTg5JUU1JTg1JUE4JUU5JTgwJTlBJUU0JUJGJUExJUU1JThEJThGJUU4JUFFJUFFbW10bHMlRTQlQkIlOEIlRTclQkIlOEQubWQ=">基于TLS1.3的微信安全通信协议mmtls介绍.—by 微信员工<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="为什么不采用websocket"><a href="#为什么不采用websocket" class="headerlink" title="为什么不采用websocket?"></a>为什么不采用websocket?</h3><p>websocket占用资源多？不安全？socket连接数限制？低端浏览器不支持？手机浏览器不支持？<br>知乎说，是因为懒</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>服务器推送</category>
        <category>非websocket的例子</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title>【读图识政治】图解 党和国家机构改革2018</title>
    <url>/pub/6637281/</url>
    <content><![CDATA[<!--
有些知乎内容写明不让转载，可临时在网页看看，后面关掉该页面。
-->

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2018年两会刚刚闭幕，中共中央周三（3月21日）公布《深化党和国家机构改革方案》，进一步<code>加强党对政府的领导</code>。</p>
<p>一、统一职权，消除政出多头</p>
<p>一位要求匿名的内地政治学者对BBC中文表示：“此次改革强化了党的集中、统一和<code>全面领导</code>，具体部署是从中共执政安全角度考虑，在一些比较重要的、事关执政安全的领域强化了党的领导，如意识形态、社会控制、干部监督管理等。</p>
<h1 id="机构改革"><a href="#机构改革" class="headerlink" title="机构改革"></a>机构改革</h1><h2 id="国务院"><a href="#国务院" class="headerlink" title="国务院"></a>国务院</h2><p>学者们认为，此次党的机构改革进一步强化了共产党的领导，<strong>削弱了国务院的权力</strong>。</p>
<p>多个国务院机构被撤销，如监察部、国家预防腐败局、国家公务员局和国务院侨务办公室。许多新组建的委员会和小组将设于国务院部门内，比如中央全面依法治国委员会办公室设在司法部，中央审计委员会办公室设在审计署，中央教育工作领导小组秘书组设在教育部。</p>
<p>方案称，此次改革，<strong>“着眼于健全加强党的全面领导的制度”</strong>，“确保党的领导全覆盖，确保党的领导更加坚强有力”。</p>
<p>国务院正部级机构减少8个，副部级机构减少7个，除国务院办公厅外，国务院设置组成部门26个。</p>
<p>改革后的国务院组成部门为19个，相较过去的25个为少，其中民政部、 教育部、 民族事务委员会、文化部、水利部、农业部、卫生和计划生育部、 科学技术部、国家安全部、监察部、审计署、住房和城乡建设部，都有调整合并，而民政部、国家安全部、审计署等则被取消，相关职能被合并到其他的部委中。</p>
<h2 id="财政-审计"><a href="#财政-审计" class="headerlink" title="财政 审计"></a>财政 审计</h2><img width="50%" alt="审计署" src="/images/raw/Politics - 党和国家机构改革 - 审计署 - 人民日报.gif">

<h2 id="意识形态领域"><a href="#意识形态领域" class="headerlink" title="意识形态领域"></a>意识形态领域</h2><p><strong>让中宣部统一管理新闻出版和电影</strong>，意味着“今后大陆人能够读什么看什么听什么全部由中宣部来统一口径”；</p>
<p>国家新闻出版广电总局原本就是国家广电总局和新闻出版署合并组建的，这次改革又恢复了国家广电总局，兜了一大圈又回到原地。而且方案中没有明确新闻出版管理职能归谁，，还有待进一步明确。()</p>
<img width="50%" alt="新闻出版广电总局" src="/images/raw/Politics - 党和国家机构改革 - 新闻出版广电总局 - 人民日报.gif">

<img width="50%" alt="新闻出版广电总局" src="/images/raw/Politics - 党和国家机构改革 - 国家广播电视总局 - 人民日报.gif">

<p>为何拆分<code>国家新闻出版广电总局</code>？为何把新闻出版可能会划给中宣部？</p>
<p>中宣部原有职责是？</p>
<p>中国共产党中央委员会宣传部（通称中共中央宣传部，简称中央宣传部、中宣部），是中共中央直属机构。主要职能是管理中国大陆出版审查体系、中共中央宣传工作以及监管中国大陆媒体和社会舆情舆论工作。<br>中宣部的主要职能是管控意识形态、新闻出版甚至教育方针。</p>
<blockquote>
<p>“报刊是党的宣传工具，党的喉舌。”“不许一切反革命分子有言论自由，而只允许人民内部有这种自由……禁止一切反革命分子用言论自由达到他们的反革命目的。”<br>–维基百科<br>wikipedia这样写会不会被查水表。</p>
</blockquote>
<p>1998年朱镕基总理视察中央电视台，破例题写16个大字：“舆论监督，群众喉舌，政府镜鉴，改革尖兵。” 短短16个字，尽显真正的共产党、真正的共产党员，为人民服务，坚守人民立场的本色！</p>
<p>以前记得课本上有这个，现在看来写这几个字很需要勇气啊。<br>一个电视台，本来是中央喉舌，是政府管理下的部门，你让他成为政府镜鉴，这不是本末倒置吗？</p>
<p>新闻出版广电总局</p>
<p>中宣部是党机构 - Marx Yong<br>so?听过党政合署的消息吗，知道顺德改革吗？ - 清新脱俗财神爷<br>党政合属但两个牌子 - Marx Yong<br>中宣部是共产党的中央宣传部啊，不是政府机构 - 微小de工作</p>
<h2 id="社会控制方面"><a href="#社会控制方面" class="headerlink" title="社会控制方面"></a>社会控制方面</h2><p>不再设立中央社会治安综合治理委员会及办公室，职责交由中央政法委承担；</p>
<h2 id="干部监督方面"><a href="#干部监督方面" class="headerlink" title="干部监督方面"></a>干部监督方面</h2><p>成立国家监察委。中国通过国家监察法 “双规”办案走向合法。<br>国家监察委将与纪委合署办公。由于针对的还是以公权力犯罪为主的案子，检察院的反贪污贿赂、反渎职侵权以及预防职务犯罪三个部门的职能及大部分人员都将被剥离出来，转移至新成立的监察部门。</p>
<p>去年10月，习近平在中共十九大报告中明确提出，监察人员将用留置取代“两规”措施。留置是指留置在特定场所交代问题。</p>
<h3 id="“两规”是什么？为何引发争议？"><a href="#“两规”是什么？为何引发争议？" class="headerlink" title="“两规”是什么？为何引发争议？"></a>“两规”是什么？为何引发争议？</h3><p>“两规”又称“双规”，是中共党纪检监察机关查办案件的一种特殊措施，要求有关人员在规定的时间、地点就案件所涉及的问题作出说明。这种措施长期以来一直遭到外界批评。</p>
<p>中国人民大学法学院教授韩大元曾撰文指出，从监察委的三个试点地区看，监察委员会与纪委虽属于两个机构，但由于主任是纪委书记担任，副主任由副书记兼任，实质上可能导致机构合一，成为党政高度合一的机关。</p>
<p>姜明安则称，党政合一以后可以提高效率，是国家治理能力的现代化。</p>
<p>至于监察委权力过大引发的谁来监督监察委的问题，姜明安对此比较乐观，他认为人大、监察委自身、检察院、公安都能从行动上对监察委进行监督。但上述要求匿名的律师认为，在现实中，人大不可能去审查监察委，<strong>“监察委只能靠自我监督”</strong>。</p>
<p>参考 <span class="exturl" data-url="aHR0cDovL3d3dy5iYmMuY29tL3pob25nd2VuL3NpbXAvY2hpbmVzZS1uZXdzLTQzNDUxODAy">http://www.bbc.com/zhongwen/simp/chinese-news-43451802<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="国家移民管理局"><a href="#国家移民管理局" class="headerlink" title="国家移民管理局"></a>国家移民管理局</h2><p>针对出入境人口越来越多的局面，组建国家移民管理局。将公安部的出入境管理、边防检查职责整合，建立健全签证管理协调机制，组建国家移民管理局，由公安部管理。</p>
<img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 国家移民管理局 - 人民日报.gif">

<h2 id="退役军人事务部"><a href="#退役军人事务部" class="headerlink" title="退役军人事务部"></a>退役军人事务部</h2><p>组建退役部不是为了向美国看齐，这几年来发生了些不让报道的非访事件（大规模），引起了大佬们的重视，原来那么多老士官退役后都得不到合理的安置。 - 赵十六</p>
<img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 退役军人事务部 - 人民日报.gif">


<h2 id="税"><a href="#税" class="headerlink" title="税"></a>税</h2><p>将省级和省级以下国税地税机构合并，具体承担所辖区城内各项税收、非税收入征管等职责。国税地税机构合并后，实行以国家税务总局为主与省（区、市）人民政府双重领导管理体制。这意味着分税制实施二十多年后，又重回了之前国税地部合一的局面，这一改革对地方的深远影响，尚待观察</p>
<img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 国税地税征管体制 - 人民日报.gif">



<h2 id="水利部"><a href="#水利部" class="headerlink" title="水利部"></a>水利部</h2><p>水利部多了三峡工程和南水北调的管理权。</p>
<p>但三峡和南水北调都修建的差不多了，水利部很多权力都被分配到其他部委了，基本被瓜分</p>
<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>当局将国安部、国家保密局、国家密码管理局合并，组建“国家安全保密总局”（加挂中央国家安全保密委牌子）。各省设国安保密局、地市设立分局、县设办事处；各级国安保密部门实行省以下垂直管理，同时接受各级政府协调。换言之，国安部被取消。</p>
<h2 id="科技部"><a href="#科技部" class="headerlink" title="科技部"></a>科技部</h2><img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 科技部 - 人民日报.gif">

<h1 id="哪些部门被加强或削弱了？"><a href="#哪些部门被加强或削弱了？" class="headerlink" title="哪些部门被加强或削弱了？"></a>哪些部门被加强或削弱了？</h1><p>加强：</p>
<ul>
<li>审计署，将国家发展和改革委员会的重大项目稽查、财政部的中央预算执行情况和其他财政收支情况的监督检查、国务院国有资产监督管理委员会的国有企业领导干部经济责任审计和国有重点大型企业监事会的职责划入审计署。</li>
<li>科学技术部，吸收了国家外国专家局的职能</li>
<li>司法部，吸收了国务院法制办的职能</li>
</ul>
<p>削弱</p>
<ul>
<li>民政部，民政部的老龄工作、退役军人安置工作、优抚工作、救灾、医疗救助等重要职能均被划出</li>
<li>国家发改委，组织编制主体功能区规划职责划入自然资源部，应对气候变化和减排职责划入生态环境部，农业投资项目划入农业农村部，重大项目稽查划入审计署，价格监督检查与反垄断执法职责划入市场监管总局，药品和医疗服务价格管理职责划入国家医保局。但这些职责多为国家层面的职能，对地方发改委、发改局的职能，影响不大。</li>
<li>住房和城乡建设部，划出了城乡规划管理和风景名胜区管理职能</li>
<li>人力资源和社会保障部划出了城镇职工和城镇居民基本医疗保险、生育保险职责</li>
<li>商务部划出了经营者集中反垄断执法等职责，且基本上没有新增职责，都可以看成改革中的“输家”。</li>
<li>发改委没裁，但是被划掉了很多职能，算是不小的削弱</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUI3JUIxJUU1JThDJTk2JUU1JTg1JTlBJUU1JTkyJThDJUU1JTlCJUJEJUU1JUFFJUI2JUU2JTlDJUJBJUU2JTlFJTg0JUU2JTk0JUI5JUU5JTlEJUE5">深化党和国家机构改革 - 维基百科<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1Nak01TWpBeE5ETTRNQT09Jm1pZD0yNjY2MTkxMTQ0JmlkeD0xJnNuPThkNmFhZDIwNzJjOGQ3MjJhZjcyYmRhZWZjYjAyNGVmJmNoa3NtPWJkYjJiMDZiOGFjNTM5N2QxMWUwNjY2MmIwYTRlYzg4YjgwYjgzMzE0YWQ4YzgxYWUwZmM4MTFhZGE0NDQwMGM1ODJkNGJkZDg4MzImbXBzaGFyZT0xJnNjZW5lPTIzJnNyY2lkPTAzMjVnVXhXQTRONlMwd1BMbHU4NWV4TiNyZA==">深化党和国家机构改革方案动态图 - 人民日报<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwODM4Mjg1">如何评价2013年国务院机构改革 - 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2ODY3ODA2OS9hbnN3ZXIvMzQwMzQ2Njk3">如何评价2018《国务院机构改革方案》？ - 知乎<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
        <category>国家机构</category>
      </categories>
      <tags>
        <tag>国家机构</tag>
        <tag>国家机构改革</tag>
        <tag>国务院</tag>
      </tags>
  </entry>
  <entry>
    <title>【读图识政治】中国最高领导人</title>
    <url>/pub/75bd2e9b/</url>
    <content><![CDATA[<h1 id="最高领导人"><a href="#最高领导人" class="headerlink" title="最高领导人"></a>最高领导人</h1><p><code>中华人民共和国最高领导人</code>是指中华人民共和国政治中具有最终决定和最高地位的政治领导人，是一个“非官方”的称谓。最高领导人在中国共产党和中华人民共和国的权力机构中<strong>不一定拥有最高职衔</strong>，但<strong>均曾担任中共中央军委主席</strong>，能有效控制其三大党政军机构——中国共产党、政府和解放军等武装力量。</p>
<p>目前中国官方称呼毛泽东、邓小平、江泽民、习近平为第一、二、三、五代中央领导集体的核心，称呼第四代胡锦涛为以他为总书记的党中央。党主席兼总理华国锋则是<code>过渡时期</code>的领导人。</p>
<p>2017年中共十九大之后，中共中央政治局全体委员和常委都被规定要向总书记述职，形成<strong>“总书记绝对领导制”</strong>，习近平作为总书记不再只是集体领导的一员，其权威已经达到毛泽东时期中央委员会主席的程度，成为全党全国的最高领袖。</p>
<h1 id="历代领导人"><a href="#历代领导人" class="headerlink" title="历代领导人"></a>历代领导人</h1><table>
<thead>
<tr>
<th>代</th>
<th>姓名</th>
<th>肖像</th>
<th>党职</th>
<th>时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>毛泽东</td>
<td><img alt="Mao_Zedong_portrait.jpg" src="https://upload.wikimedia.org/wikipedia/commons/e/e8/Mao_Zedong_portrait.jpg" width="100" height="120"></td>
<td>中共中央委员会主席<br>中共中央军事委员会主席</td>
<td>1949-1976</td>
<td>党主席，一直都是最高领导人</td>
</tr>
<tr>
<td></td>
<td>华国锋</td>
<td><img alt="Hua Guofeng-1.jpg" src="https://upload.wikimedia.org/wikipedia/commons/0/09/Hua_Guofeng-1.jpg" width="100" height="132"></td>
<td>中共中央委员会主席<br>中共中央军事委员会主席</td>
<td>1976-1978</td>
<td>毛泽东钦点的接班人，党内斗争失势后退休</td>
</tr>
<tr>
<td>2</td>
<td>邓小平</td>
<td><img alt="Deng Xiaoping.jpg" src="https://upload.wikimedia.org/wikipedia/commons/1/1c/Deng_Xiaoping.jpg" width="100" height="120"></td>
<td>中共顾问委员会主任<br>中共中央军事委员会主席</td>
<td>1978-1992</td>
<td>1978年复出做<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU1JTg1JUIxJUU1JTg1JUFCJUU1JUE0JUE3JUU1JTg1JTgzJUU4JTgwJTgx">元老<i class="fa fa-external-link-alt"></i></span>代表，主持改革开放政策</td>
</tr>
<tr>
<td>3</td>
<td>江泽民</td>
<td><img alt="Jiang Zemin St. Petersburg2002.jpg" src="https://upload.wikimedia.org/wikipedia/commons/0/09/Jiang_Zemin_St._Petersburg2002.jpg" width="100" height="120"></td>
<td>中共中央总书记<br>中共中央军事委员会主席</td>
<td>1992-2002</td>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFEJUU1JTlCJTlCJUU2JUI4JTg1JUU1JTlDJUJB">六四事件<i class="fa fa-external-link-alt"></i></span>之后取代赵紫阳做中共中央总书记</td>
</tr>
<tr>
<td>4</td>
<td>胡锦涛</td>
<td><img alt="Hu Jintao Cannes2011.jpg" src="https://upload.wikimedia.org/wikipedia/commons/5/59/Hu_Jintao_Cannes2011.jpg" width="100" height="120"></td>
<td>中共中央总书记<br>中共中央军事委员会主席</td>
<td>2002-2012</td>
<td>邓小平于1992年就已经隔代钦点的接班人</td>
</tr>
<tr>
<td>5</td>
<td>习近平</td>
<td><img alt="Xi Jinping Sept. 19, 2012.jpg" src="https://upload.wikimedia.org/wikipedia/commons/2/28/Xi_Jinping_Sept._19%2C_2012.jpg" width="100" height="120"></td>
<td>中共中央总书记<br>中共中央军事委员会主席</td>
<td>2012-</td>
<td>革命元老习仲勋儿子，中共党内协商产生</td>
</tr>
</tbody></table>
<h1 id="领导班子"><a href="#领导班子" class="headerlink" title="领导班子"></a>领导班子</h1><script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script><script type="text/javascript">google.charts.load("current",{packages:["timeline"]}); google.charts.setOnLoadCallback(drawChart); function drawChart(){var container=document.getElementById('timeline-china'); var chart=new google.visualization.Timeline(container); var dataTable=new google.visualization.DataTable(); dataTable.addColumn({type: 'string', id: 'Position'}); dataTable.addColumn({type: 'string', id: 'Name'}); dataTable.addColumn({type: 'date', id: 'Start'}); dataTable.addColumn({type: 'date', id: 'End'}); dataTable.addRows([ [ '国家主席', '毛泽东', new Date(1949, 10, 1), new Date(1959, 4, 27)], [ '国家主席', '刘少奇', new Date(1959, 4, 27), new Date(1968, 10, 31)], [ '国家主席', '宋庆龄、董必武(代理)', new Date(1968, 10, 31), new Date(1972, 2, 24)], [ '国家主席', '董必武(代理)', new Date(1972, 2, 24), new Date(1975, 1, 17)], [ '国家主席', '宋庆龄', new Date(1981, 5, 16), new Date(1981, 5, 29)], [ '国家主席', '李先念(名誉主席)', new Date(1983, 6, 18), new Date(1988, 4, 8)], [ '国家主席', '杨尚昆', new Date(1988, 4, 8), new Date(1993, 3, 27)], [ '国家主席', '江泽民', new Date(1993, 3, 27), new Date(2003, 3, 15)], [ '国家主席', '胡锦涛', new Date(2003, 3, 15), new Date(2013, 3, 14)], [ '国家主席', '习近平', new Date(2013, 3, 14), new Date()], [ '中共总书记', '毛泽东', new Date(1945, 6, 19), new Date(1976, 9, 9)], [ '中共总书记', '华国锋', new Date(1976, 10, 7), new Date(1981, 6, 28)], [ '中共总书记', '胡耀邦', new Date(1981, 6, 29), new Date(1987, 1, 16)], [ '中共总书记', '赵紫阳', new Date(1987, 1, 16), new Date(1989, 6, 2)], [ '中共总书记', '江泽民', new Date(1989, 6, 24), new Date(2002, 11, 14)], [ '中共总书记', '胡锦涛', new Date(2002, 11, 15), new Date(2012,11, 14)], [ '中共总书记', '习近平', new Date(2012, 11, 15), new Date()], [ '军委主席', '毛泽东', new Date(1949, 10, 1), new Date(1976, 8)], [ '军委主席', '华国锋', new Date(1976, 10, 7), new Date(1981, 6)], [ '军委主席', '邓小平', new Date(1981, 6), new Date(1989, 11)], [ '军委主席', '江泽民', new Date(1989, 11), new Date(2004, 9)], [ '军委主席', '胡锦涛', new Date(2004, 9), new Date(2012, 11)], [ '军委主席', '习近平', new Date(2012, 11), new Date()], [ '国务院总理', '周恩来', new Date(1949, 10, 1), new Date(1976, 1, 8)], [ '国务院总理', '华国锋', new Date(1976, 2, 2), new Date(1980, 9, 10)], [ '国务院总理', '赵紫阳', new Date(1980, 9, 10), new Date(1987, 11, 24)], [ '国务院总理', '李鹏', new Date(1987, 11, 24), new Date(1998, 3, 17)], [ '国务院总理', '朱镕基', new Date(1998, 3, 17), new Date(2003, 3, 16)], [ '国务院总理', '温家宝', new Date(2003, 3, 16), new Date(2013, 3, 15)], [ '国务院总理', '李克强', new Date(2013, 3, 15), new Date()]]); var options={'title':'中国最高领导人', 'height':220, 'language': 'ja'}; chart.draw(dataTable,options);}</script><div id="timeline-china" style="height: 200px;"></div>

<blockquote>
<p>邓小平一生未担任国家元首、政府首脑，或党内最高领导职务，但从1978年12月（中共十一届三中全会）至1989年11月辞去中共中央军委主席（中共十三届五中全会）一职前，普遍认为他是实际的最高领导人，并写入《中国共产党章程》予以确认。</p>
</blockquote>
<blockquote>
<p>1976-1981 华国锋任国家主席。1978年实权逐渐转移至邓小平。<br>1981-1982 胡耀邦任国家主席。由邓小平为首的中共元老掌握实权。<br>1982-1987 胡耀邦 总书记   在职期间由中共元老邓小平担任实际最高领导人。<br>1987-1989 赵紫阳 总书记   在职期间由中共元老邓小平担任实际最高领导人。</p>
</blockquote>
<h1 id="军委主席"><a href="#军委主席" class="headerlink" title="军委主席"></a>军委主席</h1><p>因此形式上存在<strong>两个中央军事委员会</strong>，即<code>中国共产党中央军事委员会</code>和<code>中华人民共和国中央军事委员会</code>，但是两个委员会的最高负责人（又分别称中共中央军委主席和国家军委主席）和副主席除了过渡时期外均为<strong>相同的人选</strong>。</p>
<h1 id="国家主席"><a href="#国家主席" class="headerlink" title="国家主席"></a>国家主席</h1><ul>
<li>邓小平指出：“还是要设国家主席，有国家主席代表国家比较好，但是对国家主席的职权可以规定得虚一点，不要管具体工作，不要干涉具体政务。”</li>
<li>1981年5月16日，第五届全国人民代表大会常务委员会第十八次会议决定，授予病危的宋庆龄“中华人民共和国名誉主席”荣誉称号。</li>
<li> 1983年开始，中华人民共和国“主席”的官方英文译名由“Chairman”（直译为“主席”）改为“President”（可译为“总统”）。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>维基百科</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
        <category>国家领袖</category>
      </categories>
      <tags>
        <tag>国家领导</tag>
        <tag>国家元首</tag>
        <tag>国家主席</tag>
        <tag>军委主席</tag>
        <tag>总书记</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow中的几种模型文件</title>
    <url>/pub/3da24a26/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TensorFlow 支持多种模型格式，但这些格式都有什么区别？</p>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvdmFyaWFibGVz">variable<i class="fa fa-external-link-alt"></i></span>: 变量</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvZ3JhcGhz">graph<i class="fa fa-external-link-alt"></i></span>: 计算图</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2d1aWRlcy9weXRob24vbWV0YV9ncmFwaCNXaGF0X3NfaW5fYV9NZXRhR3JhcGg=">MetaGraph<i class="fa fa-external-link-alt"></i></span><br>  包含Graph和metadata信息</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZXh0ZW5kL3Rvb2xfZGV2ZWxvcGVycy8jcHJvdG9jb2xfYnVmZmVycw==">protobuf<i class="fa fa-external-link-alt"></i></span><br>    全称Protocol Buffers，是Google开源的一个<strong>语言无关</strong>、<strong>平台无关</strong> 的序列化协议，用于不同应用或进程之间的通信。</p>
<ul>
<li>优势: 文本文件结构跟xml，json等文件结构类似。优点是体积更小、解析速度更快</li>
<li>格式: 支持binary、text两种格式</li>
</ul>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><!-- 来自
TensorFlow saves trained models in one of two ways: GraphDef and SavedModel; the TensorRT inference server supports both these formats. Once you have a trained model in TensorFlow you can save it as a GraphDef directly or convert it to a GraphDef by using a script like freeze_graph.py, or save it as a SavedModel using a SavedModelBuilder or tf.saved_model.simple_save. -->

<table>
<thead>
<tr>
<th></th>
<th>saved model</th>
<th>meta graph</th>
<th>graph</th>
<th>frozen graph</th>
<th>web model</th>
<th>ckp</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td></td>
<td></td>
<td></td>
<td>打包graph和checkpoint到一个文件，并优化，便于部署</td>
<td></td>
<td></td>
</tr>
<tr>
<td>类</td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvc2F2ZWRfbW9kZWwucHJvdG8=">SavedModel<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvbWV0YV9ncmFwaC5wcm90bw==">MetaGraphDef<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL2dyYXBoLnByb3Rv">GraphDef<i class="fa fa-external-link-alt"></i></span></td>
<td>GraphDef</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包含内容</td>
<td>meta graph</td>
<td>GraphDef, MetaInfoDef, SaverDef, CollectionDef</td>
<td>GraphDef</td>
<td>GraphDef + value - variable</td>
<td></td>
<td></td>
</tr>
<tr>
<td>序列化格式</td>
<td>protobuf</td>
<td>protobuf</td>
<td>protobuf</td>
<td>protobuf</td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件后缀</td>
<td>.pb .pbtxt</td>
<td>.meta .meta.txt</td>
<td>.pb .pbtxt</td>
<td>.pb .pbtxt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件示例</td>
<td><a href="">.pbtxt</a></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2NrcHQubWV0YS50eHQ=">.meta.txt<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2dyYXBoLnBidHh0">.pbtxt<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2Zyb3plbl9ncmFwaC5wYnR4dA==">.pbtxt<i class="fa fa-external-link-alt"></i></span></td>
<td></td>
<td></td>
</tr>
<tr>
<td>API-save</td>
<td>SavedModelBuilder.save</td>
<td>Saver.save或export_meta_graph</td>
<td>write_graph</td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi90b29scy9mcmVlemVfZ3JhcGgucHk=">freeze_graph.py<i class="fa fa-external-link-alt"></i></span></td>
<td></td>
<td></td>
</tr>
<tr>
<td>API-load</td>
<td>saved_model.loader.load</td>
<td>import_meta_graph</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>模型文件相关</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvY2hlY2twb2ludHM=">checkpoint (.ckpt)<i class="fa fa-external-link-alt"></i></span>:<ul>
<li><code>variable</code>的序列化存储，常用于保存和还原模型参数。保存方式是变量name–&gt;value的映射</li>
<li>缺陷：<strong>序列化内容与创建的代码相关</strong>，因此在跨语言时通常不采用这种格式</li>
</ul>
</li>
<li><a href="">SavedModel</a>: 同时包含<code>variable</code>、<code>graph</code>、graph’s metadata<ul>
<li><code>Checkpoints</code> is a format dependent on the code that created the model(是指和模型版本相关吗？还是语言种类？). 不包含graph</li>
<li><code>SavedModel</code> is a format independent of the code that created the model. 包含graph</li>
</ul>
</li>
<li><strong>meta graph</strong>:<ul>
<li>类: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvbWV0YV9ncmFwaC5wcm90byNMMzE=">MetaGraphDef <i class="fa fa-external-link-alt"></i></span>，包含<code>MetaInfoDef</code>、<code>GraphDef</code>、<code>SaverDef</code>、<code>CollectionDef</code></li>
<li>序列化存储格式: protobuf, <code>.meta</code>文件</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2NrcHQubWV0YS50eHQ=">示例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZXh0ZW5kL3Rvb2xfZGV2ZWxvcGVycy8jZ3JhcGhkZWY=">GraphDef (.pb)<i class="fa fa-external-link-alt"></i></span><ul>
<li>Graph对象的protobuf保存形式为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL2dyYXBoLnByb3Rv">GraphDef对象<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2dyYXBoLnBidHh0">示例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>frozen graph:<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi90b29scy9mcmVlemVfZ3JhcGgucHk=">freeze_graph.py<i class="fa fa-external-link-alt"></i></span>的操作: 将 GraphDef 中所有 Variable 节点转换为常量。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZXh0ZW5kL3Rvb2xfZGV2ZWxvcGVycy8jZnJlZXppbmc=">FrozenGraphDef<i class="fa fa-external-link-alt"></i></span>:<br>graph和variable分别存储在不同的文件，通常不利于部署到产品。<br>tensorflow提供<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi90b29scy9mcmVlemVfZ3JhcGgucHk=">freeze_graph.py<i class="fa fa-external-link-alt"></i></span>脚本将graph定义和checkpoint中的变量打包到一个文件。</li>
<li>序列化存储格式: protobuf,  文件<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvdGVuc29yZmxvd19tdWx0aV9sYW5ndWFnZS9ibG9iL21hc3Rlci80LiUyMEZyb3plbl9tb2RlbC9kZW1vX2Jhc2ljL21vZGVsL2Zyb3plbl9ncmFwaC5wYnR4dA==">示例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
<li>TensorFlow Lite model (.tflite): 轻量级模型格式 <code>*.lite</code>，和 FrozenGraphDef 十分类似</li>
</ul>
<p>部署在线服务（Serving）时官方推荐使用 SavedModel 格式，而部署到手机等移动端的模型一般使用 FrozenGraphDef 格式</p>
<h1 id="tensorflow常用的模型文件，save-amp-restore"><a href="#tensorflow常用的模型文件，save-amp-restore" class="headerlink" title="tensorflow常用的模型文件，save &amp; restore"></a>tensorflow常用的模型文件，save &amp; restore</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi9zYXZlZF9tb2RlbC9SRUFETUUubWQ=">SavedModel<i class="fa fa-external-link-alt"></i></span><ul>
<li>内容: variables, graph, graph’s metadata</li>
<li>用途: 常用与python接口</li>
<li>文件: 格式为</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assets/</span><br><span class="line">assets.extra/</span><br><span class="line">variables/</span><br><span class="line">    variables.data-?????-of-?????</span><br><span class="line">    variables.index</span><br><span class="line">saved_model.pb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-<span class="exturl" data-url="aHR0cHM6Ly9rZXJhcy5pby9nZXR0aW5nLXN0YXJ0ZWQvZmFxLyNob3ctY2FuLWktc2F2ZS1hLWtlcmFzLW1vZGVs">Keras h5<i class="fa fa-external-link-alt"></i></span> keras模型，格式为<code>.h5</code></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvbW9iaWxlL3ByZXBhcmVfbW9kZWxzI2hvd19kb195b3VfZ2V0X2FfbW9kZWxfeW91X2Nhbl91c2Vfb25fbW9iaWxl">Frozen Model<i class="fa fa-external-link-alt"></i></span><ul>
<li>用途: 常用于C++、Java的接口，移动端。</li>
<li>文件: <code>Frozen Model</code>包含一个<code>.pb</code>文件，其中包括了所有网络结构以及所有模型参数。</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXI=">tensorflowjs<i class="fa fa-external-link-alt"></i></span><ul>
<li>用途: web格式，</li>
<li>文件: <code>.pb</code> <code>.json</code>(方便web读取)，等格式</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvaHViLw==">Tensorflow Hub module<i class="fa fa-external-link-alt"></i></span> 实验阶段，尚未成熟<ul>
<li>用途: web-friendly format</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvbnRyaWIvc2Vzc2lvbl9idW5kbGUvUkVBRE1FLm1k">Session Bundle<i class="fa fa-external-link-alt"></i></span> 已弃用</li>
</ul>
<p>Tensorflow 保存模型的几种方式：</p>
<ul>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3RyYWluL1NhdmVy">tf.train.Saver-&gt;save<i class="fa fa-external-link-alt"></i></span></strong>:<ul>
<li>官方文档: save and restore variables to and from checkpoints</li>
<li>大白话: 保存变量(checkpoints)，但不保存graph，即<code>MetaGraphDef</code>。所以只给 checkpoint 模型不提供代码是无法重新构建计算图的，不能直接用于serving</li>
<li>restore: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3RyYWluL1NhdmVyI3Jlc3RvcmU=">saver.restore<i class="fa fa-external-link-alt"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3RyYWluL1NhdmVyI3JlY292ZXJfbGFzdF9jaGVja3BvaW50cw==">saver.recover_last_checkpoints<i class="fa fa-external-link-alt"></i></span></li>
<li>完整示例：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvc2F2ZWRfbW9kZWwjc2F2ZV9hbmRfcmVzdG9yZV92YXJpYWJsZXM=">save_and_restore_variables | tensorflow<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3RyYWluL2V4cG9ydF9tZXRhX2dyYXBo">tf.train.export_meta_graph与tf.train.Saver-&gt;export_meta_graph<i class="fa fa-external-link-alt"></i></span></strong><ul>
<li>官方文档: exports the graph, saver, and collection objects into <code>MetaGraphDef</code> protocol buffer</li>
<li>大白话:</li>
<li>restore: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3RyYWluL2ltcG9ydF9tZXRhX2dyYXBo">tf.train.import_meta_graph<i class="fa fa-external-link-alt"></i></span></li>
<li>完整示例: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2d1aWRlcy9weXRob24vbWV0YV9ncmFwaA==">Exporting and Importing a MetaGraph | tensorflow<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><strong><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3NhdmVkX21vZGVsL2J1aWxkZXIvU2F2ZWRNb2RlbEJ1aWxkZXI=">SavedModelBuilder<i class="fa fa-external-link-alt"></i></span></strong>: 用于serving<ul>
<li>官方文档: Builds the SavedModel protocol buffer. Meta graph must be saved with variables.</li>
<li>大白话: 保存<code>SavedModel</code>，同时包含graph和variable</li>
<li>restore: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL3NhdmVkX21vZGVsL2xvYWRlci9sb2Fk">tf.saved_model.loader.load<i class="fa fa-external-link-alt"></i></span> 根据tag加载<code>SavedModel</code></li>
</ul>
</li>
<li><strong>Exporter</strong>: 用于serving</li>
</ul>
<h1 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h1><p>典型的tensorflow模型包含4种文件</p>
<ul>
<li><strong>graph.pbtxt</strong>:</li>
<li><strong>model.ckpt.meta</strong>: 包含全部graph信息。这是一个序列化的MetaGraphDef protocol buffer，包含数据流、变量的annotations、input pipelines，以及其他相关信息</li>
<li><strong>model.ckpt.data-0000-of-00001</strong>: 包含所有变量的值(weights, biases, placeholders,gradients, hyper-parameters etc).</li>
<li><strong>model.ckpt.index</strong>: metadata. [ It’s an immutable table(tensoflow::table::Table). Each key is a name of a Tensor and it’s value is a serialized BundleEntryProto. Each BundleEntryProto describes the metadata of a Tensor]</li>
<li><strong>checkpoint</strong>: All checkpoint information</li>
</ul>
<p>疑问graph.pbtxt 与model.ckpt.meta的区别。答：基本是一样的，都包含</p>
<h1 id="SavedModel"><a href="#SavedModel" class="headerlink" title="SavedModel"></a>SavedModel</h1><p>SavedModel用于保存和加载模型(variables, graph, graph’s<br>metadata)。这是一种语言无关的、可复原的序列化格式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">|--save-model.pb</span><br><span class="line">|--variable</span><br><span class="line">|-- |--variables.data-00000-of-00001</span><br><span class="line">|-- |--variables.index</span><br></pre></td></tr></table></figure>

<p><code>.pb</code>与<code>.pbtxt</code>都是SavedModel的protobuf存储格式，区别是前者是二进制文件，后者是txt文件（方便阅读）。<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZXh0ZW5kL3Rvb2xfZGV2ZWxvcGVycy8jdGV4dF9vcl9iaW5hcnk=">来源<i class="fa fa-external-link-alt"></i></span></p>
<p>从 SavedModel 中可以提取 GraphDef 和 CheckPoint 对象。</p>
<p>GraphDef的缺陷是不包含graph，的缺陷是单靠graph无法还原整个模型计算</p>
<h2 id="save-amp-restore"><a href="#save-amp-restore" class="headerlink" title="save &amp; restore"></a>save &amp; restore</h2><p>常用的API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">builder = tf.saved_model.builder.SavedModelBuilder(export_dir)</span><br></pre></td></tr></table></figure>

<p>load graph using .meta file and restore weights inside a session). Convert the graph to graph_def.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">saver = tf.train.import_meta_graph(<span class="string">&#x27;./dogs-cats-model.meta&#x27;</span>, clear_devices=<span class="literal">True</span>)</span><br><span class="line">graph = tf.get_default_graph()</span><br><span class="line">input_graph_def = graph.as_graph_def()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">saver.restore(sess, <span class="string">&quot;./dogs-cats-model&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>参考: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvc2F2ZWRfbW9kZWwjc2F2ZV9hbmRfcmVzdG9yZV9tb2RlbHM=">https://www.tensorflow.org/guide/saved_model#save_and_restore_models<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="Frozen-Model-Graph"><a href="#Frozen-Model-Graph" class="headerlink" title="Frozen Model/Graph"></a>Frozen Model/Graph</h1><p>TensorFlow 一些例程中用到 *.pb 文件作为预训练模型，这和上面 GraphDef 格式稍有不同，<br>属于冻结（Frozen）后的 GraphDef 文件，简称 FrozenGraphDef 格式。这种文件格式不包含 Variables 节点。<br>将 GraphDef 中所有 Variable 节点转换为常量（其值从 checkpoint 获取），就变为 FrozenGraphDef 格式。代码可以参考 tensorflow/python/tools/freeze_graph.py</p>
<h2 id="什么是Frozen-Model-Graph？为什么要Freeze？"><a href="#什么是Frozen-Model-Graph？为什么要Freeze？" class="headerlink" title="什么是Frozen Model/Graph？为什么要Freeze？"></a>什么是Frozen Model/Graph？为什么要Freeze？</h2><p>Tensorflow的<code>SavedModel</code>文件包含graph、模型参数、梯度信息(用于训练时的BP)等。然而，在部署环境下一般用不到梯度信息，也就<strong>没必要加载所有的SavedModel文件</strong>。</p>
<p><code>Freezing</code>过程会对<code>SavedModel</code>进行<strong>过滤</strong>，只包含必要的信息(graph, weights etc) ，并<strong>打包到一个文件</strong>便于应用。</p>
<!-- encapsulate all in a single file  -->

<p><code>Freezing</code>过程通常会去除掉<code>SavedModel</code>中不必要的meta-data、梯度，以及不必要的训练参数，并打包为<code>.pb</code>文件。这个文件就叫做<br><code>Frozen Model/Graph</code></p>
<h2 id="怎样Freeze？"><a href="#怎样Freeze？" class="headerlink" title="怎样Freeze？"></a>怎样Freeze？</h2><p>有两种方式：</p>
<h1 id="Keras-h5"><a href="#Keras-h5" class="headerlink" title="Keras h5"></a>Keras h5</h1><h1 id="Tensorflow-Hub-module"><a href="#Tensorflow-Hub-module" class="headerlink" title="Tensorflow Hub module"></a>Tensorflow Hub module</h1><h1 id="tensorflowjs"><a href="#tensorflowjs" class="headerlink" title="tensorflowjs"></a>tensorflowjs</h1><h1 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvbW9iaWxlL3RmbGl0ZS9kZXZndWlkZSMyX2NvbnZlcnRfdGhlX21vZGVsX2Zvcm1hdA==">https://www.tensorflow.org/mobile/tflite/devguide#2_convert_the_model_format<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy90cmVlL21hc3Rlci90ZW5zb3JmbG93L3Rvb2xzL2dyYXBoX3RyYW5zZm9ybXM=">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/tools/graph_transforms<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="saver文件"><a href="#saver文件" class="headerlink" title="saver文件"></a>saver文件</h2><p>load the checkpoints</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">saver = tf.train.import_meta_graph(<span class="string">&#x27;model-number.meta&#x27;</span>)</span><br><span class="line">saver.restore(sess, tf.train.latest_checkpoint(<span class="string">&#x27;./&#x27;</span>))</span><br></pre></td></tr></table></figure>





<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><h2 id="模型文件相关"><a href="#模型文件相关" class="headerlink" title="模型文件相关"></a>模型文件相关</h2><p><strong>frozen-model相关</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jdi10cmlja3MuY29tL2hvdy10by9mcmVlemUtdGVuc29yZmxvdy1tb2RlbHMv">Freeze Tensorflow models and serve on web<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><strong>SavedModelBuilder相关</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvc2VydmluZy9zZXJ2aW5nX2Jhc2lj">Serving a TensorFlow Model<i class="fa fa-external-link-alt"></i></span></li>
<li></li>
</ul>
<p><strong>tensorflowjs相关</strong></p>
<p>tfjs-converter</p>
<h2 id="跨语言相关"><a href="#跨语言相关" class="headerlink" title="跨语言相关"></a>跨语言相关</h2><h2 id="ic"><a href="#ic" class="headerlink" title="ic)"></a>ic)</h2><p><strong>tensorflowjs相关</strong></p>
<p>tfjs-converter</p>
<h2 id="跨语言相关-1"><a href="#跨语言相关-1" class="headerlink" title="跨语言相关"></a>跨语言相关</h2>]]></content>
      <categories>
        <category>深度学习</category>
        <category>toolbox</category>
        <category>tensorflow</category>
        <category>graph-checkpoint</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>graph</tag>
        <tag>serving</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言理解</title>
    <url>/pub/de32aa0/</url>
    <content><![CDATA[<h1 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是NLU？怎样才算理解了语言？</p>
<p>自然语言理解，也就是人或机器理解人类语言，有两种不同定义：一种<strong>基于表征</strong>，另一种<strong>基于行为</strong>。<br>基于表征（representation），就是系统根据输入的语言产生相应的内部表征，这个过程也称为语义<br>接地（semantic grounding）。比如，有人说「哈利波特」，在大脑里联系到哈利波特的概念就意<br>味着理解了对方的语言。基于行为，就是系统根据输入的语言采取相应的动作。比如，有人说「给我<br>拿一杯茶」，机器人按照命令做了，就认为它理解了人的语言。这两个定义在一定程度上互为补充，<br>前者从语义角度，后者从语用角度界定这个问题。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>李航</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>0.框架-综述</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理 - 从规则到统计</title>
    <url>/pub/cd9c7906/</url>
    <content><![CDATA[<h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><p>字母(或者中文的笔画)、文字和数字实际上是信息编码的不同单元。任何一种语言都是一种编码的方式，而<strong>语言的语法规则是编解码的算法</strong>。</p>
<p>我们把一个要表达的意思，通过某种语言的一句话表达出来，就是用这种语言的编码方式对头脑中的信息做了一次<strong>编码</strong>，编码的结果就是一串文字。而如果对方懂得这门语言，他就可以用这门语言的<strong>解码方法</strong>获得说话人要表达的信息。这就是语言的数学本质。</p>
<!-- -->

<h2 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h2><ul>
<li>文法、语法 Grammer</li>
<li>文法包括词法和句法</li>
<li>词法主要研究词的内部结构，包括变形、构词法。又称形态学(Morphologic)</li>
<li>句法研究句子结构成分的相关关系</li>
</ul>
<ul>
<li>上下文无关文法 (Context Independent Grammar)，比如程序设计语言。计算复杂度大约是句子长度的2次方</li>
<li>上下文有关文法 (Context dependency Grammar)，比如自然语言。计算复杂度大约是语句长度的6次方。</li>
</ul>
<h1 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h1><ul>
<li>人是怎样理解语言的？</li>
<li>机器能否像人一样理解语言？</li>
</ul>
<p>今天，机器翻译和语音识别已经做得不错，但大部分这个领域之外的人依然错误地认为这两个应用是靠计算机理解了自然语言而完成的。事实上，它们全都靠得是数学，更准确地说是<strong>靠统计</strong>。</p>
<h2 id="门派"><a href="#门派" class="headerlink" title="门派"></a>门派</h2><ul>
<li>基于规则的：专家根据自己的经验 人工撰写规则。<ul>
<li>背景：</li>
<li>优点：设计规则，简单有效。</li>
<li>缺点：费时费力；规则不能覆盖各种语言现象</li>
</ul>
</li>
<li>基于统计的：<ul>
<li>背景：上个世纪80年代后期，机器学习算法被引入到自然语言处理中，这要归功于不断提高的计算能力。</li>
<li>优点：相对基于规则的方法，更鲁棒</li>
<li>缺点/局限性：data-driven，强烈依赖数据，需要大规模的训练语料。计算能力</li>
</ul>
</li>
</ul>
<p>基于统计的方法代替传统的方法，需要等原有的一批语言学家退休。</p>
<p>今天几乎不再有科学家宣称自己是基于规则方法的捍卫者。而自然语言处理的研究也<strong>从单纯的句法分析和语义理解，变成了非常贴近应用的机器翻译、语音识别、文本到数据库自动生成、数据挖掘和知识的获取等等。</strong></p>
<blockquote>
<p>上面是什么意思？从无监督学习变成了有监督学习？贬低语义理解？</p>
</blockquote>
<h3 id="门派斗争"><a href="#门派斗争" class="headerlink" title="门派斗争"></a>门派斗争</h3><ul>
<li>基于统计的方法只能处理浅层的自然语言处理问题，无法进入生层次的研究</li>
</ul>
<h2 id="基于规则的自然语言处理"><a href="#基于规则的自然语言处理" class="headerlink" title="基于规则的自然语言处理"></a>基于规则的自然语言处理</h2><p><code>语法规则</code>(Gramar Rules)、<code>词性</code>(Part of Speech)、<code>构词法</code>(Morphologic)等，这些规则是人类学习语言(尤其是外语)的好工具。而恰恰这些语法规则又很容易用计算机的算法描述，这就更坚定了大家对基于规则的自然语言处理的信心。</p>
<p>语法树太复杂</p>
<h2 id="基于统计的自然语言处理"><a href="#基于统计的自然语言处理" class="headerlink" title="基于统计的自然语言处理"></a>基于统计的自然语言处理</h2><p><strong>由于计算量十分庞大，在20世纪70年代，基于规则的句法分析很快走到了尽头</strong>。</p>
<p>1970年以后统计语言学的出现使得自然语言处理重获新生。<br>当时，基于统计的方法核心模型是通信系统加<code>隐马尔科夫模型</code>。<strong>这个系统的输入和输出都是一维的符号序列，而且保持原有的次序</strong>(即sequence labeling问题)。最早获得成功的是语音识别，接下来是磁性分析。</p>
<p>但是在句法分析中，输入时一维的句子，输出是二维的分析树。在机器翻译中，<strong>输出的次序会有很大的变化</strong>（翻译不再是sequence labeling问题）。HMM就不太管用了。1988年，IBM的Peter Brown等人提出了基于统计的机器翻译方法，框架是对的，但是效果很差，因为当时既没有足够的数据，也没有足够强大的模型来解决不同语言<strong>语序颠倒的问题</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《数学之美》 | 吴军</li>
<li>《》</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>0.框架-综述</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>rule</tag>
      </tags>
  </entry>
  <entry>
    <title>分词</title>
    <url>/pub/a388e785/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>分句</th>
<th>用户词典</th>
<th>NER</th>
<th>新词识别</th>
<th>模型/算法</th>
<th>开源</th>
</tr>
</thead>
<tbody><tr>
<td>结巴分词</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z4c2p5L2ppZWJh">开源<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>哈工大LTP</td>
<td></td>
<td>根据中文标点里的句号、问号、感叹号、分号、省略号。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hJVC1TQ0lSL2x0cA==">C++<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>中科院NLPIR</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算所ICTCLAS</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>CHMM(层叠形马尔可夫模型)。进行原子切分,然后在此基础上进行N-最短路径粗切分,找出前N个最符合的切分结果,生成二元分词表,然后生成分词结果,接着进行词性标注并完成主要分词步骤</td>
<td><a href="">C/C++</a></td>
</tr>
<tr>
<td>IKAnalyzer</td>
<td>轻量级</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>结合词典分词和文法分析算法</td>
<td><a href="">java</a></td>
</tr>
</tbody></table>
<p>参考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NTc4Njg3">https://www.zhihu.com/question/19578687<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>分词</category>
      </categories>
  </entry>
  <entry>
    <title>文本分类 - 综述</title>
    <url>/pub/eae469b0/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul>
<li>短文本分类</li>
<li>长文本分类</li>
<li>超短文本(一个word)分类</li>
</ul>
<p>特定领域的文本分类</p>
<ul>
<li>aspect-level classification</li>
<li>ss</li>
</ul>
<h2 id="methods"><a href="#methods" class="headerlink" title="methods:"></a>methods:</h2><ul>
<li><p>word-level</p>
<ul>
<li>tfidf + svm/lr</li>
<li>fastText facebook (只是作为baseline而已)</li>
<li>lstm bilstm</li>
<li>lstm + attention</li>
<li><a href="TextCNN">cnn</a>  <a href="TextCNN-code">code1</a> <a href="TextCNN-code">code2</a></li>
<li>gated cnn</li>
<li><a href="RNN+CNN">rcnn</a></li>
</ul>
</li>
<li><p>char-level</p>
<ul>
<li>char的作用？ 见NLP.md</li>
<li>char cnn  (Zhang and LeCun, 2015)</li>
<li>char rnn</li>
<li>char-CRNN (Xiao and Cho, 2016)</li>
<li>char-rnn + word rnn (Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation)  </li>
<li>char-cnn + word rnn</li>
</ul>
</li>
<li><p>Hierarchical:</p>
<ul>
<li>char + word:</li>
<li>word + sentence: <a href="%5BRNN+Attention%5D">Hierarchical Attention</a></li>
<li>char + word + sentence:</li>
</ul>
</li>
</ul>
<h2 id="datasets-amp"><a href="#datasets-amp" class="headerlink" title="datasets &amp;"></a>datasets &amp;</h2><h2 id="paper-amp-implementation"><a href="#paper-amp-implementation" class="headerlink" title="paper &amp; implementation"></a>paper &amp; implementation</h2><p>[TextCNN]: Convolutional Neural Networks for Sentence Classification<br>[TextCNN-code]: <span class="exturl" data-url="aHR0cHM6Ly9yaWNobGlhby5naXRodWIuaW8vc3VwZXJ2aXNlZC9jbGFzc2lmaWNhdGlvbi8yMDE2LzExLzI2L3RleHRjbGFzc2lmaWVyLWNvbnZvbHV0aW9uYWwv">https://richliao.github.io/supervised/classification/2016/11/26/textclassifier-convolutional/<i class="fa fa-external-link-alt"></i></span></p>
<p>[TextRNN]: Recurrent Neural Network for Text Classification with Multi-Task Learning<br>[TextRNN-code]:</p>
<p>[RNN+Attention]: Hierarchical Attention Networks for Document Classification<br><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzRmYmM0OTM5NTA5Zg==">http://www.jianshu.com/p/4fbc4939509f<i class="fa fa-external-link-alt"></i></span><br>[RNN+Attention-code]: <span class="exturl" data-url="aHR0cHM6Ly9yaWNobGlhby5naXRodWIuaW8vc3VwZXJ2aXNlZC9jbGFzc2lmaWNhdGlvbi8yMDE2LzEyLzI2L3RleHRjbGFzc2lmaWVyLVJOTi8=">https://richliao.github.io/supervised/classification/2016/12/26/textclassifier-RNN/<i class="fa fa-external-link-alt"></i></span></p>
<p>[RNN+CNN]: Recurrent Convolutional Neural Networks for Text Classification. AAAI. 2015.<br>[RNN+CNN-code]: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tub2svcmNubi10ZXh0LWNsYXNzaWZpY2F0aW9u">https://github.com/knok/rcnn-text-classification<i class="fa fa-external-link-alt"></i></span></p>
<p>[fastText]:</p>
<ul>
<li>three papers.  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvZmFzdFRleHQ=">https://github.com/facebookresearch/fastText<i class="fa fa-external-link-alt"></i></span>  in C++<ul>
<li>[1] P. Bojanowski*, E. Grave*, A. Joulin, T. Mikolov, Enriching Word Vectors with Subword Information</li>
<li>[2] A. Joulin, E. Grave, P. Bojanowski, T. Mikolov, Bag of Tricks for Efficient Text Classification</li>
<li>[3] A. Joulin, E. Grave, P. Bojanowski, M. Douze, H. Jégou, T. Mikolov, FastText.zip: Compressing text classification models</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGFybWNoaS9jaGFyLWxldmVsLWNubi10Zg==">https://github.com/scharmchi/char-level-cnn-tf<i class="fa fa-external-link-alt"></i></span></li>
<li>!!!!!! char-level deep learning  <span class="exturl" data-url="aHR0cHM6Ly9vZmZiaXQuZ2l0aHViLmlvL2hvdy10by1yZWFkLw==">https://offbit.github.io/how-to-read/<i class="fa fa-external-link-alt"></i></span>    <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29mZmJpdC9jaGFyLW1vZGVscw==">https://github.com/offbit/char-models<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="tutorial-amp-survey-amp-blog"><a href="#tutorial-amp-survey-amp-blog" class="headerlink" title="tutorial &amp; survey &amp; blog"></a>tutorial &amp; survey &amp; blog</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5qZXl6aGFuZy5jb20vY25uLWFwcGx5LW9uLW1vZGVsbGluZy1zZW50ZW5jZS5odG1s">http://www.jeyzhang.com/cnn-apply-on-modelling-sentence.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNTkyODU1MQ==">https://zhuanlan.zhihu.com/p/25928551<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="web-service"><a href="#web-service" class="headerlink" title="web service"></a>web service</h2><pre><code>1. watson NLC: https://www.ibm.com/watson/developercloud/natural-language-classifier/api/v1
2. songfang NLC
</code></pre>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul>
<li>模型汇总 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyaWdodG1hcnQvdGV4dF9jbGFzc2lmaWNhdGlvbg==">https://github.com/brightmart/text_classification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>text_classification</category>
      </categories>
  </entry>
  <entry>
    <title>非局部连接网络 Non-local Neural Network</title>
    <url>/pub/4716970e/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>dependencies between <strong>spatial</strong> or <strong>temporal</strong> <strong>local</strong> regions.</p>
</blockquote>
<p>通常利用卷积(滤波器)等操作，可以实现局部依赖，但是如何获取图像/视频中的长距离依赖？self-attention给我们提供了一个很好的思路，它能捕获<strong>任意距离</strong>的依赖。</p>
<!-- directly modeling the correlation between any two positions in the feature maps -->


<h1 id="空间Attention"><a href="#空间Attention" class="headerlink" title="空间Attention"></a>空间Attention</h1><blockquote>
<p>dependencies between <strong>any</strong> <strong>spatial</strong> pixels</p>
</blockquote>
<p>通常的<code>space attention</code>，需要构建<code>H*W</code>的attention mask，实现空间维度的长依赖。</p>
<h1 id="时空Attention"><a href="#时空Attention" class="headerlink" title="时空Attention"></a>时空Attention</h1><blockquote>
<p>dependencies between <strong>any</strong> <strong>spatial</strong> pixels and <strong>temporal</strong> frames</p>
</blockquote>
<img title="spacetime non-local block, 即spacetime的self-attention" src="/images/raw/NN - Self Attention - spacetime - non local NN.png">

<p>整体架构类似transformer中的设计，仍然采用了bottleneck思想。即先用<code>1*1*1</code>卷积对channel进行降维，然后进行3D-Attention，再升维。</p>
<p>对于<code>3D-Attention</code>，即<code>spacetime attention</code>，是在2-D上的扩展。它需要构造<br><code>T*H*W</code>大小的attention mask，实现跨任意空间、任意时间维度的长依赖。</p>
<h1 id="时空-Channel-Attention"><a href="#时空-Channel-Attention" class="headerlink" title="时空+Channel Attention"></a>时空+Channel Attention</h1><blockquote>
<p>dependencies between <strong>any</strong> <strong>spatial</strong> pixels, <strong>temporal</strong> frames, and <strong>channels</strong></p>
</blockquote>
<p><code>时空Attention</code>仅通过合并信道来考虑全局时空相关性。它可能会错过一些重要的<strong>跨通道</strong>信息。例如，身体、球及其相互作用都是描述踢球动作所必需的，而<code>non-local</code>侧重于学习身体部位的关系，而忽略了通常对应于输入特征的身体与球<strong>不同通道的相互作用</strong>。</p>
<blockquote>
<p>感觉motivation有些牵强，或者我还没领会channel attention的必要性。channel 思想来自SENet</p>
</blockquote>
<!-- only considers the global spatio-temporal correlation by merging channels -->


<h1 id="rethink"><a href="#rethink" class="headerlink" title="rethink"></a>rethink</h1><ul>
<li><strong>Factorization</strong>: 这个是spacetime的同时attention，计算量比较大，有没有做分解的？即先space attention，再time attention。</li>
<li><strong>计算量</strong>: T比较大的情况下怎么办？以及HW</li>
<li><strong>非关键帧</strong>: 这里并未考虑非关键帧的信息，如何兼顾非关键帧。光流…</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Non-local Neural Network</li>
<li>CGNL: Compact Generalized Non-local Network</li>
<li>SENet: Squeeze-and-Excitation Networks</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>self-attention-in-cv</category>
      </categories>
      <tags>
        <tag>self-attention</tag>
        <tag>context</tag>
        <tag>long dependency</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉--常用数据库</title>
    <url>/pub/84080d8a/</url>
    <content><![CDATA[<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><table>
<thead>
<tr>
<th>dataset</th>
<th align="right">im_size</th>
<th align="right">class*num</th>
<th align="right">download</th>
<th align="right">task</th>
<th align="center">example code</th>
<th>pretrained_model</th>
<th>state of art</th>
<th>实例图片</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>mnist</td>
<td align="right">28*28</td>
<td align="right">70000</td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudG9yb250by5lZHUvfmtyaXovY2lmYXIuaHRtbA==">CIFAR-10<i class="fa fa-external-link-alt"></i></span></td>
<td align="right">32x32x3</td>
<td align="right">10*6000</td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td><img src="https://www.cs.toronto.edu/~kriz/cifar-10-sample/automobile5.png" alt="d" title="汽车"></td>
<td>Alex,Hinton发布，超小图片</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudG9yb250by5lZHUvfmtyaXovY2lmYXIuaHRtbA==">CIFAR-100<i class="fa fa-external-link-alt"></i></span></td>
<td align="right">32x32 170M</td>
<td align="right">100*600</td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cDovL2hvc3Qucm9ib3RzLm94LmFjLnVrL3Bhc2NhbC9WT0Mv">Pascal VOC<i class="fa fa-external-link-alt"></i></span> (05-12)</td>
<td align="right">2GB</td>
<td align="right"></td>
<td align="right"><span class="exturl" data-url="aHR0cDovL2hvc3Qucm9ib3RzLm94LmFjLnVrL3Bhc2NhbC9WT0Mvdm9jMjAxMi9WT0N0cmFpbnZhbF8xMS1NYXktMjAxMi50YXI=">voc2012<i class="fa fa-external-link-alt"></i></span></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cDovL21zY29jby5vcmcv">coco<i class="fa fa-external-link-alt"></i></span></td>
<td align="right"></td>
<td align="right"></td>
<td align="right">40GB</td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cDovL2ltYWdlLW5ldC5vcmcvY2hhbGxlbmdlcy9MU1ZSQy8yMDEyL2luZGV4">imagenet2012<i class="fa fa-external-link-alt"></i></span></td>
<td align="right">尺寸不固定，但多数比较清晰</td>
<td align="right"><span class="exturl" data-url="aHR0cDovL2ltYWdlLW5ldC5vcmcvY2hhbGxlbmdlcy9MU1ZSQy8yMDEyL2Jyb3dzZS1zeW5zZXRz">1000类<i class="fa fa-external-link-alt"></i></span>，训练集1.2m，验证集50k,测试集100k</td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td>层级标签。 评价指标，top5的label包含正确label就算正确</td>
<td>AlexNet</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5pbWFnZS1uZXQub3JnL2Fib3V0LXN0YXRz">imagenet2016<i class="fa fa-external-link-alt"></i></span></td>
<td align="right"></td>
<td align="right">1400多万幅图片，涵盖2万多个类别 1TB</td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>places</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>12306</td>
<td align="right">约80*80</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
<td></td>
<td>12306图片比cifar数据库大多了</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cDovL3JvZHJpZ29iLmdpdGh1Yi5pby9hcmVfd2VfdGhlcmVfeWV0L2J1aWxkL2NsYXNzaWZpY2F0aW9uX2RhdGFzZXRzX3Jlc3VsdHMuaHRtbA==">分类结果汇总<i class="fa fa-external-link-alt"></i></span></p>
<p>task_code:</p>
<ol>
<li>图像分类（image classification）</li>
<li>目标检测（object detection）</li>
<li>目标识别（object recognition）</li>
<li>语义分割（semantic segmentation）</li>
<li>实例分割（instance segmentation）</li>
</ol>
<h2 id="来自pytorch-vision的data"><a href="#来自pytorch-vision的data" class="headerlink" title="来自pytorch vision的data"></a>来自pytorch vision的data</h2><ul>
<li>LSUN <span class="exturl" data-url="aHR0cDovL2xzdW4uY3MucHJpbmNldG9uLmVkdS8=">http://lsun.cs.princeton.edu<i class="fa fa-external-link-alt"></i></span>`_ dataset</li>
<li>Local Image Descriptors Data <span class="exturl" data-url="aHR0cDovL3Bob3RvdG91ci5jcy53YXNoaW5ndG9uLmVkdS9wYXRjaGVzL2RlZmF1bHQuaHRt">http://phototour.cs.washington.edu/patches/default.htm<i class="fa fa-external-link-alt"></i></span>`_ Dataset.</li>
<li>SEMEION <span class="exturl" data-url="aHR0cDovL2FyY2hpdmUuaWNzLnVjaS5lZHUvbWwvZGF0YXNldHMvc2VtZWlvbitoYW5kd3JpdHRlbitkaWdpdA==">http://archive.ics.uci.edu/ml/datasets/semeion+handwritten+digit<i class="fa fa-external-link-alt"></i></span>`_ Dataset.</li>
<li>STL10 <span class="exturl" data-url="aHR0cHM6Ly9jcy5zdGFuZm9yZC5lZHUvfmFjb2F0ZXMvc3RsMTAv">https://cs.stanford.edu/~acoates/stl10/<i class="fa fa-external-link-alt"></i></span>`_ Dataset.</li>
<li>SVHN <span class="exturl" data-url="aHR0cDovL3VmbGRsLnN0YW5mb3JkLmVkdS9ob3VzZW51bWJlcnMv">http://ufldl.stanford.edu/housenumbers/<i class="fa fa-external-link-alt"></i></span>`_ Dataset.</li>
</ul>
<h2 id="来自tensorflow的data"><a href="#来自tensorflow的data" class="headerlink" title="来自tensorflow的data"></a>来自tensorflow的data</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>dataset</category>
      </categories>
      <tags>
        <tag>dataset</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS解析之“记录类型”</title>
    <url>/pub/87420f16/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type）。</p>
<p>资源记录(RR: Resource Record)：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlGJTlGJUU1JTkwJThEJUU0JUJDJUJBJUU2JTlDJThEJUU1JTk5JUE4JUU4JUE4JTk4JUU5JThDJTg0JUU5JUExJTlFJUU1JTlFJThCJUU1JTg4JTk3JUU4JUExJUE4">域名服务器记录类型列表 - 维基百科<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="常见的DNS记录类型"><a href="#常见的DNS记录类型" class="headerlink" title="常见的DNS记录类型"></a>常见的DNS记录类型</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTgwNzcuaHRt">参考<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">A:</span>      <span class="string">将域名指向一个IPV4地址</span>  <span class="comment">#</span></span><br><span class="line"><span class="attr">CNAME:</span>  <span class="string">将域名指向另外一个域名</span>  <span class="comment"># 将域名指向另一个域名，再由另一个域名提供IP地址</span></span><br><span class="line"><span class="attr">AAAA:</span>   <span class="string">将域名指向一个IPV6地址</span>  <span class="comment"># 当您希望访问者通过IPv6地址访问您的域名时，可以使用AAAA记录。</span></span><br><span class="line"><span class="attr">NS:</span>     <span class="string">将子域名指向其他DNS服务器解析</span> <span class="comment"># 如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。</span></span><br><span class="line"><span class="attr">MX:</span>     <span class="string">将域名指向邮件服务器地址</span>  <span class="comment"># 如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。</span></span><br><span class="line"><span class="attr">SRV:</span>    <span class="string">记录提供特定服务的服务器</span></span><br><span class="line"><span class="string">显性URL:</span> <span class="string">将域名302重定向到另外一个地址</span></span><br><span class="line"><span class="string">隐性URL:</span> <span class="string">与显性URL类似，但是会隐藏真实目标地址</span></span><br><span class="line"><span class="string">SOA记录:</span> <span class="string">Start</span> <span class="string">of</span> <span class="string">Authority，始授权机构记录。NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器。SOA</span> <span class="string">资源记录表明此</span> <span class="string">DNS</span> <span class="string">名称服务器是为该</span> <span class="string">DNS</span> <span class="string">域中的数据的信息的最佳来源。</span></span><br><span class="line"><span class="attr">PTR:</span> <span class="string">逆向查询记录（Pointer</span> <span class="string">Record），只用于从IP地址查询域名，</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>


<h4 id="万网域名解析为什么没有301重定向？"><a href="#万网域名解析为什么没有301重定向？" class="headerlink" title="万网域名解析为什么没有301重定向？"></a>万网域名解析为什么没有301重定向？</h4><p>URL 重定向服务实际并非DNS 服务，它们在 HTTP 级别运行，而非 DNS 级别。使用URL转发的客户基本都是免费DNS的用户，当前业务暂不会投入支持。</p>
<p><strong>优先级</strong></p>
<ul>
<li>单独设置的域名解析优先级高于泛域名解析</li>
<li>NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</li>
<li>A记录优先于CNAME记录。即如果一个主机地址同时存在A记录和CNAME记录，则CNAME记录不生效</li>
<li>MX记录可以通过设置优先级实现主辅服务器设置，“优先级”中的数字越小表示级别越高。也可以使用相同优先级达到负载均衡的目的</li>
</ul>
<h3 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h3><p>主机记录就是域名前缀，常见用法有：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">www:</span> <span class="string">解析后的域名为www.aliyun.com。</span></span><br><span class="line"><span class="string">@:</span> <span class="string">直接解析主域名</span> <span class="string">aliyun.com。</span></span><br><span class="line"><span class="string">*:</span> <span class="string">泛解析，匹配其他所有域名</span> <span class="string">*.aliyun.com。</span></span><br><span class="line"><span class="attr">mail:</span> <span class="string">将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</span></span><br><span class="line"><span class="string">二级域名:</span> <span class="string">如：abc.aliyun.com，填写abc。</span></span><br><span class="line"><span class="string">手机网站:</span> <span class="string">如：m.aliyun.com，填写m。</span></span><br><span class="line"><span class="string">显性URL:</span> <span class="string">不支持泛解析（泛解析：将所有子域名解析到同一地址）</span></span><br></pre></td></tr></table></figure>


<ol>
<li>@和WWW是两个主机名，可以指向不同的IP(A记录)或域名(CNAME记录)</li>
<li>可以为一个主机添加多个A记录 (1. 实现<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNjAxODIuaHRt">负载均衡<i class="fa fa-external-link-alt"></i></span>，2. 可配合解析路线进行<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTgxNDIuaHRt">智能解析<i class="fa fa-external-link-alt"></i></span>)</li>
<li>一个主机配置了CNAME记录，就不能再为该主机配置其他任何记录 (为啥呢？) 见 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTg0NTYuaHRt">记录冲突判断规则<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p> 负载均衡的实现：负载均衡(Server Load Balancing，SLB)是指在一系列资源上面动态地分布网络负载。负载均衡可以减少网络拥塞，提高整体网络性能，提高自愈性， 并确保企业关键性应用的可用性。当相同子域名有多个目标地址时，表示轮循，可以达到负载均衡的目的，但需要虚拟主机服务商支持。</p>
<h3 id="解析路线"><a href="#解析路线" class="headerlink" title="解析路线"></a>解析路线</h3><p>如果多个IP，<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTgxNDcuaHRt">搜索引擎线路<i class="fa fa-external-link-alt"></i></span></p>
<p>如果只有一个IP地址或CNAME域名，请务必选择【默认】。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">默认:</span> <span class="string">必填！未匹配到智能解析线路时，返回【默认】线路设置结果。</span></span><br><span class="line"><span class="string">世界:</span> <span class="string">向除中国大陆以外的其他国家和地区，返回设置的记录值。</span> <span class="comment"># 可用于双线部署，</span></span><br><span class="line"><span class="string">搜索引擎:</span> <span class="string">向搜索引擎爬虫的DNS，返回设置的记录值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>（Time to live 的缩写</p>
<p>TTL为缓存时间，数值越小，修改记录各地生效时间越快。万网DNS的默认值为600，表示600秒之内不用重新查询。</p>
<h2 id="查看解析是否生效"><a href="#查看解析是否生效" class="headerlink" title="查看解析是否生效"></a>查看解析是否生效</h2><p>怎样查看解析是否生效？</p>
<h3 id="Windows-用户测试"><a href="#Windows-用户测试" class="headerlink" title="Windows 用户测试"></a>Windows 用户测试</h3><p>修改域名解析，实际上是在域名解析服务商处修改域名解析记录。修改的解析记录是否在用户端生效，既受运营商递归 DNS 服务器的直接影响，也受域名解析服务商提供的权威 DNS 服务器的间接影响。</p>
<p>测试本地运营商递归 DNS 服务器是否生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nslookup eson.org</span><br><span class="line">服务器: ...  <span class="comment"># 一般返回的是最近的DNS服务器，</span></span><br><span class="line">Address: ...</span><br></pre></td></tr></table></figure>
<!--
服务器: crl-ns1.crl.ibm.com
Address: 9.186.88.5
-->

<p>测试域名解析服务商的权威 DNS 服务器是否生效。测试方法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nslookup eson.org dns25.hichina.com</span><br></pre></td></tr></table></figure>
<h3 id="Linux测试"><a href="#Linux测试" class="headerlink" title="Linux测试"></a>Linux测试</h3><p><code>dig 要检测的域名 @dns服务器地址</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ dig eson.org</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:  <span class="comment"># 为什么0个answer？</span></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 8309</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;eson.org.                      IN      A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:   # 不应该啊，我已经改回阿里的name server了</span></span><br><span class="line"><span class="string">eson.org.               3592    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com. 2027227883 10000 2400 604800 3600</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 112 msec</span></span><br><span class="line"><span class="string">;; SERVER: 9.0.146.50#53(9.0.146.50)</span></span><br><span class="line"><span class="string">;; WHEN: Sun Mar 11 18:04:06 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 99</span></span><br></pre></td></tr></table></figure>
<p>以上部分是不是延迟问题，明天再试试。</p>
<p>(Update: 第二天测试，果然解析到了<code>xu-song.coding.me</code>. ANSWER: 15, AUTHORITY: 0,)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ dig eson.org vip1.alidns.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org vip1.alidns.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 23319</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 15, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;eson.org.                      IN      A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:  # 这个就对了。我采用的双线部署。国内走coding.net</span></span><br><span class="line"><span class="string">eson.org.               600     IN      CNAME   xu-song.coding.me.</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.72.147.211</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.72.145.7</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       23.91.101.50</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.218.240.147</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       36.255.221.66</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       107.150.121.91</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       107.150.121.231</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.72.147.89</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.14.35.185</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.72.146.177</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       36.255.220.102</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       23.91.96.142</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       23.91.97.251</span></span><br><span class="line"><span class="string">xu-song.coding.me.      60      IN      A       103.218.241.74</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 682 msec</span></span><br><span class="line"><span class="string">;; SERVER: 9.0.146.50#53(9.0.146.50)</span></span><br><span class="line"><span class="string">;; WHEN: Sun Mar 11 18:05:55 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 292</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Got answer:  # 为什么又有一个query &amp; answer？</span></span><br><span class="line"><span class="string">;; -&gt;&gt;HEADER&lt;&lt;- opcode</span>: QUERY, status: NOERROR, id: 52301</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 9, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;vip1.alidns.com.               IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:   <span class="comment"># 这是什么鬼？</span></span><br><span class="line">vip1.alidns.com.        600     IN      A       14.1.112.11</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.29.113</span><br><span class="line">vip1.alidns.com.        600     IN      A       106.11.30.113</span><br><span class="line">vip1.alidns.com.        600     IN      A       116.211.173.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       106.11.41.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.1.1</span><br><span class="line">vip1.alidns.com.        600     IN      A       121.29.51.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.228.51</span><br><span class="line">vip1.alidns.com.        600     IN      A       47.88.44.151</span><br><span class="line"></span><br><span class="line">;; Query time: 389 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:05:56 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 188</span><br></pre></td></tr></table></figure>
<p>以上命令，第二天竟然变回了cloudflare的name server。why？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line">...</span><br><span class="line">AUTHORITY SECTION:</span><br><span class="line">eson.org.               3600    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com.</span><br></pre></td></tr></table></figure>
<p>过几天又变回来了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ dig eson.org dns25.hichina.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org dns25.hichina.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 18683</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;eson.org.                      IN      A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:   # 这个也有延迟啊。什么情况？dns25.hichina.com与vip1.alidns.com什么区别？是不是有个根节点?</span></span><br><span class="line"><span class="string">eson.org.               3404    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com. 2027227883 10000 2400 604800 3600</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 115 msec</span></span><br><span class="line"><span class="string">;; SERVER: 9.0.146.50#53(9.0.146.50)</span></span><br><span class="line"><span class="string">;; WHEN: Sun Mar 11 18:07:14 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 99</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Got answer:</span></span><br><span class="line"><span class="string">;; -&gt;&gt;HEADER&lt;&lt;- opcode</span>: QUERY, status: NOERROR, id: 31080</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 8, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;dns25.hichina.com.             IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.211.69</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.211.59</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.141.129</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.141.119</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.41.29</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.41.19</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.81.29</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.81.19</span><br><span class="line"></span><br><span class="line">;; Query time: 114 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:07:14 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 174</span><br></pre></td></tr></table></figure>
<p>以上这个部分，第二天测试竟然不变。为什么会采用cloudflare的DNS服务器呢？</p>
<p>过几天又变回了coding.me线路。</p>
<h3 id="测试结果分析"><a href="#测试结果分析" class="headerlink" title="测试结果分析"></a>测试结果分析</h3><p>如果递归 DNS 服务器和权威 DNS 服务器都未生效，表明域名确实没有添加成功。</p>
<p>如果递归 DNS 服务器未生效，权威 DNS 服务器已生效，表明域名刚添加不久，全球的递归 DNS 服务器未完全同步，需要等待域名配置的 <code>TTL 时间后再次检测</code>是否生效。如果某些个别的运营商递归 DNS 服务器依然未生效，很可能是你遇到了域名劫持或者 DNS 缓存投毒事件。</p>
<p>参考: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTg0NTguaHRtbA==">https://www.alibabacloud.com/help/zh/doc-detail/58458.html<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="修改过-DNS-服务器，多长时间解析可以生效？"><a href="#修改过-DNS-服务器，多长时间解析可以生效？" class="headerlink" title="修改过 DNS 服务器，多长时间解析可以生效？"></a>修改过 DNS 服务器，多长时间解析可以生效？</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpYmFiYWNsb3VkLmNvbS9oZWxwL3poL2RvYy1kZXRhaWwvNTg0NTguaHRt"> 多长时间解析可以生效<i class="fa fa-external-link-alt"></i></span><br>要全球解析生效，得等上一会了，也可以先ping一下自己的设置对不对。阿里云域名服务的工作原理是，在你更新了域名解析之后，首先是阿里的万网云解析，然后传播到各大运营商的DNS服务器，刷新DNS缓存，至此你的域名可以被访问。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
        <category>1. 第七层 应用层</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>domain</tag>
        <tag>建站</tag>
        <tag>blog</tag>
        <tag>pages</tag>
        <tag>DNS</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>反演 百度DNS解析规则</title>
    <url>/pub/b7c755c3/</url>
    <content><![CDATA[<!--
反函数：inverse function (or anti-function[1]) is a function that "reverses" another function
反编译：

DNS解析：host--ip，，DNS的逆应该是ip--host.
ARP（地址解析协议） RARP（逆地址解析协议），DNS中是不是也有逆？

正向 ：DNS解析规则 -- 解析结果。逆向：解析结果--解析规则
-->

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>域名系统（DNS）是一种用于 TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。</p>
<p>通常情况下，我们是先设定DNS解析规则，然后ISP(供应商)依据指定的解析规则进行DNS解析。同样，我们通过测试解析结果，也可以反推DNS解析规则。本文以百度首页为例，分析其DNS解析规则。</p>
<p>DNS地址解析器的核心功能能</p>
<ul>
<li>gethostbyname  主机名–&gt;ip   </li>
<li>gethostbyaddr  ip–主机名</li>
</ul>
<p><strong>分析方式一：</strong><br>通过抓包，分析DNS查询和响应报文。每个响应报文对应一条DNS解析规则，通过一条或者多条记录才能完成DNS解析。</p>
<p><strong>分析方式二：</strong><br>一堆命令，见参考博客。</p>
<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9hc2xpYnJhLmNvbS9ibG9nL3Bvc3QvdXNlX2RpZ19kbnNfY2hlY2sucGhw">https://aslibra.com/blog/post/use_dig_dns_check.php<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83MWY2MTY1MmVjMjM=">通过dig命令理解DNS<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3JvY2xpbnV4LmNuLz9wPTI0NDk=">dig挖出DNS的秘密<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="百度DNS解析规则"><a href="#百度DNS解析规则" class="headerlink" title="百度DNS解析规则"></a>百度DNS解析规则</h2><table>
<thead>
<tr>
<th>编号</th>
<th>主机记录</th>
<th>记录类型</th>
<th>解析线路(isp)</th>
<th>记录值</th>
<th>TTL值(不定)</th>
<th>备注</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v">www.baidu.com<i class="fa fa-external-link-alt"></i></span></td>
<td>CNAME</td>
<td>–</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb20v">www.a.shifen.com<i class="fa fa-external-link-alt"></i></span></td>
<td>268</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb20v">www.a.shifen.com<i class="fa fa-external-link-alt"></i></span></td>
<td>CNAME</td>
<td>–</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy53c2hpZmVuLmNvbS8=">www.wshifen.com<i class="fa fa-external-link-alt"></i></span></td>
<td>271</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy53c2hpZmVuLmNvbS8=">www.wshifen.com<i class="fa fa-external-link-alt"></i></span></td>
<td>A</td>
<td>新加坡 百度</td>
<td>45.113.192.101</td>
<td>160</td>
<td>“1-2-[3</td>
<td>4]”</td>
</tr>
<tr>
<td>4</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy53c2hpZmVuLmNvbS8=">www.wshifen.com<i class="fa fa-external-link-alt"></i></span></td>
<td>A</td>
<td>北京电信</td>
<td>220.181.111.188</td>
<td>160</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>wshifen.com</td>
<td>NS</td>
<td>–</td>
<td>ns1.wshifen.com</td>
<td>163</td>
<td>很多name server</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>baidu.com</td>
<td>A</td>
<td>北京移动</td>
<td>111.13.101.208</td>
<td></td>
<td>见解析方式二</td>
<td></td>
</tr>
<tr>
<td></td>
<td>baidu.com</td>
<td>A</td>
<td>北京联通…</td>
<td>123.125.114.144</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>baidu.com</td>
<td>SOA</td>
<td>–</td>
<td>dns.baidu.com</td>
<td>900</td>
<td>见解析方式四</td>
<td></td>
</tr>
<tr>
<td></td>
<td>baidu.com</td>
<td>NS</td>
<td>–</td>
<td>ns1.baidu.com</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>baidu.com</td>
<td>NS</td>
<td>–</td>
<td>ns2.baidu.com</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>dns.baidu.com</td>
<td>A</td>
<td></td>
<td>202.108.22.220</td>
<td>67498</td>
<td>这里只有一个A记录吗？为什么TTL这么高？</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ns1.baidu.com</td>
<td>A</td>
<td></td>
<td>202.108.22.220</td>
<td>27780</td>
<td>为什么和上个记录同IP？</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ns2.baidu.com</td>
<td>A</td>
<td></td>
<td>61.135.165.235</td>
<td>86400</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>shifen.com.</td>
<td>NS</td>
<td></td>
<td>ns1.baidu.com</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>shifen.com.</td>
<td>A</td>
<td></td>
<td>202.108.250.218</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>shifen.com</td>
<td>SOA</td>
<td></td>
<td>dns.shifen.com</td>
<td></td>
<td>dig shifen.com soa</td>
<td></td>
</tr>
<tr>
<td></td>
<td>dns.shifen.com</td>
<td>A</td>
<td></td>
<td>202.108.250.228</td>
<td></td>
<td>dig dns.shifen.com</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>a.shifen.com</td>
<td>NS</td>
<td>–</td>
<td>ns1.a.shifen.com</td>
<td>397</td>
<td>见解析方式五</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ns1.a.shifen.com</td>
<td>A</td>
<td></td>
<td>61.135.165.224</td>
<td>600</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注：所有解析路线由ip.cn提供。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53c2hpZmVuLmNvbS8=">www.wshifen.com<i class="fa fa-external-link-alt"></i></span>  没有NS记录，没有SOA记录。<br><code>dig www.wshifen.com ns</code>。没有answer，即没有ns记录<br><code>dig wshifen.com ns</code>，有answer</p>
<p>解析方式一: 1–&gt;2 （<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20s5p+l6K+i57G75Z6LYSzljbPmn6Xor6JpcHY05Zyw5Z2AKS8=">www.baidu.com，查询类型A，即查询IPv4地址）<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一会功夫变成102了</span></span><br><span class="line"><span class="comment"># DNS响应一般为多个ip，后续连接只用一个ip</span></span><br><span class="line">$ ping www.baidu.com</span><br><span class="line">PING www.wshifen.com (45.113.192.102) 56(84) bytes of data.</span><br><span class="line">64 bytes from 45.113.192.102: icmp_seq=1 ttl=43 time=87.3 ms</span><br><span class="line"></span><br><span class="line">$ wget www.baidu.com</span><br><span class="line">--2018-03-08 11:30:32--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 45.113.192.102, 45.113.192.101</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|45.113.192.102|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line"></span><br><span class="line">$ dig www.baidu.com</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.                 IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.          337     IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       191     IN      CNAME   www.wshifen.com.</span><br><span class="line">www.wshifen.com.        110     IN      A       45.113.192.102</span><br><span class="line">www.wshifen.com.        110     IN      A       45.113.192.101</span><br></pre></td></tr></table></figure>

<p>解析方式二：9  （baidu.com，查询类型A）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这种域名一般情况下是不能做cname解析的，只能用A记录</span></span><br><span class="line">$ ping baidu.com</span><br><span class="line">PING baidu.com (111.13.101.208) 56(84) bytes of data.</span><br><span class="line">64 bytes from 111.13.101.208: icmp_seq=1 ttl=45 time=13.8 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS中没有对baidu.com做CNAME记录，貌似。</span></span><br><span class="line"><span class="comment"># 为什么浏览器重定向到http://www.baidu.com/？ 后面章节会介绍</span></span><br><span class="line">$ wget baidu.com</span><br><span class="line">--2018-03-08 11:32:10--  http://baidu.com/</span><br><span class="line">Resolving baidu.com (baidu.com)... 111.13.101.208, 220.181.57.216</span><br><span class="line">Connecting to baidu.com (baidu.com)|111.13.101.208|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ dig baidu.com</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.                     IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              345     IN      A       111.13.101.208</span><br><span class="line">baidu.com.              345     IN      A       220.181.57.216</span><br></pre></td></tr></table></figure>




<p>解析方式三: 1–&gt;5–&gt;8  （<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20s5p+l6K+i57G75Z6LYWFhYSzljbPmn6Xor6JpcHY25Zyw5Z2AKS8=">www.baidu.com，查询类型AAAA，即查询IPv6地址）<i class="fa fa-external-link-alt"></i></span></p>
<p>请求路线：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v">www.baidu.com<i class="fa fa-external-link-alt"></i></span> 未找到AAAA记录，走CNAME记录1</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb20v">www.a.shifen.com<i class="fa fa-external-link-alt"></i></span> 未找到AAAA记录，走CNAME记录5</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53c2hpZmVuLmNvbS8=">www.wshifen.com<i class="fa fa-external-link-alt"></i></span> 找到NS记录，返回</li>
</ul>
<p>抓包内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目前使用IPv6的还是极少数，所以得不到AAAA记录的。</span></span><br><span class="line"><span class="comment"># DNS响应报文中的资源记录部分：回答字段、授权字段和附加信息字段，均采用一种称为资源记录RR（ Resource Record）的相同格式。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">Domain</span> <span class="string">Name</span> <span class="string">System</span> <span class="string">(response)</span></span><br><span class="line">    <span class="attr">Questions:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">Answer RRs:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">Authority RRs:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">Additional RRs:</span> <span class="number">0</span></span><br><span class="line">    <span class="string">Queries</span></span><br><span class="line">        <span class="attr">www.baidu.com:</span> <span class="string">type</span> <span class="string">AAAA,</span> <span class="string">class</span> <span class="string">IN</span></span><br><span class="line">    <span class="string">Answers</span> <span class="comment"># 回答字段</span></span><br><span class="line">        <span class="attr">www.baidu.com:</span> <span class="string">type</span> <span class="string">CNAME,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">cname</span> <span class="string">www.a.shifen.com</span></span><br><span class="line">            <span class="attr">Name:</span> <span class="string">www.baidu.com</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">CNAME</span> <span class="string">(Canonical</span> <span class="string">NAME</span> <span class="string">for</span> <span class="string">an</span> <span class="string">alias)</span> <span class="string">(5)</span></span><br><span class="line">            <span class="attr">CNAME:</span> <span class="string">www.a.shifen.com</span></span><br><span class="line">        <span class="attr">www.a.shifen.com:</span> <span class="string">type</span> <span class="string">CNAME,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">cname</span> <span class="string">www.wshifen.com</span></span><br><span class="line">            <span class="attr">Name:</span> <span class="string">www.a.shifen.com</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">CNAME</span> <span class="string">(Canonical</span> <span class="string">NAME</span> <span class="string">for</span> <span class="string">an</span> <span class="string">alias)</span> <span class="string">(5)</span></span><br><span class="line">            <span class="attr">Class:</span> <span class="string">IN</span> <span class="string">(0x0001)</span></span><br><span class="line">            <span class="attr">Time to live:</span> <span class="number">271</span></span><br><span class="line">            <span class="attr">Data length:</span> <span class="number">14</span></span><br><span class="line">            <span class="attr">CNAME:</span> <span class="string">www.wshifen.com</span></span><br><span class="line">    <span class="string">Authoritative</span> <span class="string">nameservers</span>  <span class="comment"># 授权字段</span></span><br><span class="line">        <span class="attr">wshifen.com:</span> <span class="string">type</span> <span class="string">SOA,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">mname</span> <span class="string">ns1.wshifen.com</span></span><br><span class="line">            <span class="attr">Name:</span> <span class="string">wshifen.com</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">SOA</span> <span class="string">(Start</span> <span class="string">Of</span> <span class="string">a</span> <span class="string">zone</span> <span class="string">of</span> <span class="string">Authority)</span> <span class="string">(6)</span></span><br><span class="line">            <span class="attr">Primary name server:</span> <span class="string">ns1.wshifen.com</span> <span class="string">baidu_dns_master.baidu.com</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dig 内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ dig www.baidu.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.                 IN      AAAA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.          4       IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       174     IN      CNAME   www.wshifen.com.</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">wshifen.com.            250     IN      SOA     ns1.wshifen.com. baidu_dns_master.baidu.com. 1803080001 60 30 2592000 3600</span><br></pre></td></tr></table></figure>


<p>解析方式四：11  （baidu.com，查询类型AAAA）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Domain Name System (response)</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 1</span><br><span class="line">    Queries</span><br><span class="line">        baidu.com: <span class="built_in">type</span> AAAA, class IN</span><br><span class="line">    Authoritative nameservers</span><br><span class="line">        baidu.com: <span class="built_in">type</span> SOA, class IN, mname dns.baidu.com</span><br><span class="line">            Name: baidu.com</span><br><span class="line">            Type: SOA (Start Of a zone of Authority) (6)</span><br><span class="line">            Primary name server: dns.baidu.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dig baidu.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.                     IN      AAAA</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">baidu.com.              4581    IN      SOA     dns.baidu.com. sa.baidu.com. 2012138564 300 300 2592000 7200</span><br></pre></td></tr></table></figure>

<p>解析方式五: 12  （<span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb20s5p+l6K+i57G75Z6LYWFhYSkv">www.a.shifen.com，查询类型AAAA）<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dig www.a.shifen.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.a.shifen.com.              IN      AAAA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.a.shifen.com.       34      IN      CNAME   www.wshifen.com.</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">wshifen.com.            235     IN      SOA     ns1.wshifen.com. baidu_dns_master.baidu.com. 1803080001 60 30 2592000 3600</span><br></pre></td></tr></table></figure>

<h2 id="疑问-amp-剖析"><a href="#疑问-amp-剖析" class="headerlink" title="疑问 &amp; 剖析"></a>疑问 &amp; 剖析</h2><h3 id="编号1中，别名www-a-shifen-com的作用"><a href="#编号1中，别名www-a-shifen-com的作用" class="headerlink" title="编号1中，别名www.a.shifen.com的作用"></a>编号1中，别名<span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb23nmoTkvZznlKgv">www.a.shifen.com的作用<i class="fa fa-external-link-alt"></i></span></h3><p>觉得没啥用啊。看看网上的说法：</p>
<ul>
<li>使用CNAME有个好处就是，我IP地址去做改动的时候不需要去DNS运营商上面做改动，只需要自己的服务器做改动就好，方便自己的域名与实际IP地址做对应。    –觉得没什么道理啊</li>
</ul>
<ul>
<li>百度弄的一个域名保护壳。？</li>
<li>CDN加速节点？</li>
</ul>
<p>逆向思维吧。如果没什么用，为什么要保留呢？是不是还有点作用？</p>
<h3 id="编号2-3中，多条A记录的作用"><a href="#编号2-3中，多条A记录的作用" class="headerlink" title="编号2,3中，多条A记录的作用"></a>编号2,3中，多条A记录的作用</h3><ul>
<li>可用于多线智能解析，为了每条线路（电信、联通/网通、移动等）上的用户都能最快访问站点</li>
<li>可用于简单的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzMwMi85MDY5">负载均衡<i class="fa fa-external-link-alt"></i></span>(dns轮询)</li>
<li>可HA(高可用)</li>
</ul>
<h3 id="关于返回主机-IP-的策略"><a href="#关于返回主机-IP-的策略" class="headerlink" title="关于返回主机(IP)的策略"></a>关于返回主机(IP)的策略</h3><p>考虑的因素有：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzMwMi84NjQz">智能解析线路<i class="fa fa-external-link-alt"></i></span> 用户所在网络的网络运行商类型、区域</li>
<li>距离–跳数</li>
</ul>
<p>当我一个IP到DNS上面请求DNS域名解析的时候，DNS系统会根据你的IP地址所到达的域名对应的IP地址中路由跳数最小的那个IP地址作为访问的IP地址，具体你可以用LINUX的NSLOOKUP来查看域名所对应的IP地址，然后用PC的TRACERT的功能把所有DNS解析出来的IP地址进行跳数记录，然后在访问该域名，查看具体是哪个地址解析给你的PC。</p>
<h3 id="为什么无法直接访问www-a-shifen-com"><a href="#为什么无法直接访问www-a-shifen-com" class="headerlink" title="为什么无法直接访问www.a.shifen.com"></a>为什么无法直接访问<span class="exturl" data-url="aHR0cDovL3d3dy5hLnNoaWZlbi5jb20v">www.a.shifen.com<i class="fa fa-external-link-alt"></i></span></h3><image src="/images/raw/HTTP%20-%20Wireshark%20-%20www.a.shifen.com.png">

<p>流程：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> [1,2,3,4] - DNS解析</li>
<li><input checked="" disabled="" type="checkbox"> [5,6,7] - 三次握手，建立TCP连接</li>
<li><input checked="" disabled="" type="checkbox"> [8] - 发送HTTP Get请求</li>
<li><input disabled="" type="checkbox"> [9] - 服务器返回RST复位信号，强制关闭TCP连接</li>
</ul>
<p>服务器成功收到了HTTP Get请求，后台逻辑认为这个连接不符合规范()。所谓baidu定义的规范那应该就是服务器检查host，非<code>baidu.com</code>或<code>s</code>就拒绝访问。</p>
<h3 id="抓包貌似看不到整个路由，是吗？如何分析整个路由？"><a href="#抓包貌似看不到整个路由，是吗？如何分析整个路由？" class="headerlink" title="抓包貌似看不到整个路由，是吗？如何分析整个路由？"></a>抓包貌似看不到整个路由，是吗？如何分析整个路由？</h3><p>。。</p>
<h3 id="为什么访问-baidu-com-会跳转到-www-baidu-com-？"><a href="#为什么访问-baidu-com-会跳转到-www-baidu-com-？" class="headerlink" title="为什么访问 baidu.com 会跳转到 www.baidu.com ？"></a>为什么访问 baidu.com 会跳转到 <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v">www.baidu.com<i class="fa fa-external-link-alt"></i></span> ？</h3><p><code>baidu.com</code>返回的页面如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=http://www.baidu.com/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表示0秒之后跳转到<code>www.baidu.com</code>主页。这种叫做<code>HTML redirections</code>。并非30X 重定向。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9SZWRpcmVjdGlvbnM=">参考<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM2ODkxNDcyL2Fuc3dlci82OTQ1NTM1Ng==">https://www.zhihu.com/question/36891472/answer/69455356<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3NreXJvdmVyLm1lLzIwMTcvMDIvMTkvQkFJRFUlRTclOUElODRETlMlRTglQTclQTMlRTYlOUUlOTAv">http://skyrover.me/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
        <category>1. 第七层 应用层</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS解析实例之 Coding Pages</title>
    <url>/pub/2902c89e/</url>
    <content><![CDATA[<h2 id="coding-page跳转至首页"><a href="#coding-page跳转至首页" class="headerlink" title="coding page跳转至首页"></a>coding page跳转至首页</h2><p>DNS配置<br><img src="/images/raw/建站 - DNS解析 - 配置.png"></p>
<p>coding.net域名配置<br><img src="/images/raw/建站 - Coding Pages - 域名配置.png"></p>
<p><code>首选</code>域名，一次到达</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget https://blog.eson.org</span><br><span class="line"><span class="comment"># 这个不需要重定向</span></span><br><span class="line">--2018-03-02 18:51:26--  https://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 107.150.121.91, 107.150.121.231, 103.72.147.89, ...</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|107.150.121.91|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html.1’</span><br></pre></td></tr></table></figure>
<p><code>跳转至首页</code>的域名，采用301跳转</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget xusong.vip</span><br><span class="line">--2018-03-02 17:35:28--  http://xusong.vip/</span><br><span class="line"><span class="comment"># dns解析xusong.vip，根据CNAME记录得到xu-song.coding.me。</span></span><br><span class="line"><span class="comment"># 然后解析xu-song.coding.me对应的服务器IP。</span></span><br><span class="line"><span class="comment"># 返回“301跳转到 http://blog.eson.org/”</span></span><br><span class="line">Resolving xusong.vip (xusong.vip)... 103.72.145.7, 23.91.101.50, 103.218.240.147, ...</span><br><span class="line">Connecting to xusong.vip (xusong.vip)|103.72.145.7|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: http://blog.eson.org/ [following]</span><br><span class="line"><span class="comment"># DNS解析http站点，返回“301跳转至https页面”</span></span><br><span class="line">--2018-03-02 17:35:29--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 103.72.147.211, 103.72.145.7, 23.91.101.50, ...</span><br><span class="line">Reusing existing connection to xusong.vip:80.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment"># DNS解析https站点，返回页面内容</span></span><br><span class="line">--2018-03-02 17:35:31--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|103.72.147.211|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不加https协议，会首先301跳转到https站点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget blog.eson.org</span><br><span class="line"><span class="comment"># 默认是访问 http://blog.eson.org，返回301重定向 https://blog.eson.org/</span></span><br><span class="line">--2018-03-02 18:50:27--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 36.255.221.66, 107.150.121.91, 107.150.121.231, ...</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|36.255.221.66|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:50:28--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|36.255.221.66|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>直接访问coding pages页面，要跳转2次，一次302，一次301</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget xu-song.coding.me</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:45--  http://xu-song.coding.me/</span><br><span class="line">Resolving xu-song.coding.me (xu-song.coding.me)... 23.91.97.251, 103.218.241.74, 103.72.147.211, ...</span><br><span class="line">Connecting to xu-song.coding.me (xu-song.coding.me)|23.91.97.251|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: http://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:46--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 103.72.147.211, 103.72.145.7, 23.91.101.50, ...</span><br><span class="line">Reusing existing connection to xu-song.coding.me:80.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:46--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|103.72.147.211|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html.3’</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>network</category>
        <category>网络协议-OSI七层模型</category>
        <category>1. 第七层 应用层</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/pub/c6654282/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是⼀种优雅的问题解决⽅法，<br>是一种分⽽治之(divide and conquer，D&amp;C)的⽅法。<br>递归，就是函数调⽤⾃⼰。</p>
<p>递归的<strong>核心思想</strong> 就是：把问题分解成规模更小，但和原问题有着相同解法的问题。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>编写递归函数时，必须告诉它何时停⽌递归。正因为如此，每个递归函数都有两部分：</p>
<ul>
<li>基线条件（base case）: 函数调⽤⾃⼰的条件</li>
<li>递归条件（recursive case）: 函数不再调⽤⾃⼰的条件，从⽽避免形成⽆限循环。</li>
</ul>
<p>其中有一个基础的编程概念 - 调⽤栈（call stack）。调⽤栈不仅对编程来说很重要，使⽤递归时也必须理解这个概念</p>
<h2 id="示例-求阶乘"><a href="#示例-求阶乘" class="headerlink" title="示例 - 求阶乘"></a>示例 - 求阶乘</h2><iframe width="800" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=def%20fact%28x%29%3A%0A%20%20%20%20if%20x%20%3D%3D1%3A%0A%20%20%20%20%20%20%20%20return%201%3B%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20x%20*%20fact%28x-1%29%0A%0Avalue%20%3D%20fact%283%29%0Aprint%28value%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=15&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

<ul>
<li><strong>压栈</strong>: <code>x==1</code>之前，压了三个函数栈，但一个都没调用结束</li>
<li><strong>出栈</strong>: <code>x==1</code>后，从<code>栈顶</code>开始<code>出栈</code></li>
</ul>
<p>使⽤栈虽然很⽅便，但是也要付出代价：存储详尽的信息可能占⽤⼤量的内存。每个函数调⽤都要占⽤⼀定的内存，如果栈很⾼，就意味着计算机存储了⼤量函数调⽤的信息。在这种情况下，你有两种选择。</p>
<ul>
<li>重新编写代码，转⽽使⽤循环。</li>
<li>使⽤尾递归。这是⼀个⾼级递归主题，不在本书的讨论范围内。另外，并⾮所有的语⾔都⽀持尾递归。</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>假设你编写了⼀个递归函数，但不⼩⼼导致它没完没了地运⾏。正如你看到的，对于每次函数<br>调⽤，计算机都将为其在栈中分配内存。递归函数没完没了地运⾏时，将给栈带来什么影响？</li>
</ul>
<h4 id="⼩结"><a href="#⼩结" class="headerlink" title="⼩结"></a>⼩结</h4><ul>
<li>递归指的是调⽤⾃⼰的函数。</li>
<li>每个递归函数都有两个条件：基线条件和递归条件。</li>
<li>栈有两种操作：压⼊和弹出。</li>
<li>所有函数调⽤都进⼊调⽤栈。</li>
<li>调⽤栈可能很长，这将占⽤⼤量的内存</li>
</ul>
<h1 id="递归转循环"><a href="#递归转循环" class="headerlink" title="递归转循环"></a>递归转循环</h1><h1 id="递归转尾递归"><a href="#递归转尾递归" class="headerlink" title="递归转尾递归"></a>递归转尾递归</h1><p>比如维特比算法+</p>
<p>有些简单的递归问题，可以不借助堆栈结构而改成循环的非递归问题。</p>
<h1 id="递归的应用"><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h1><h2 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h2><p>见 。。</p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>见 。。</p>
<h2 id="RNN、LSTM"><a href="#RNN、LSTM" class="headerlink" title="RNN、LSTM"></a>RNN、LSTM</h2><p>递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），另一种是结构递归神经网络（recursive neural network）。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM1MjU1MTEy">为什么说递归效率低？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmFrYXJpL3AvNTM0OTM4My5odG1s">漫谈递归转非递归 | cnblog<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>algorithm</category>
        <category>编程思想</category>
        <category>分而治之</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】导读</title>
    <url>/pub/eab986ce/</url>
    <content><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul>
<li>JCP:<br>JCP（Java Community Process）成立于1998年，是使有兴趣的各方参与定义Java的特征和未来版本的正式过程。</li>
<li></li>
</ul>
<h1 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h1><p>7是指jdk版本  7.0版本  u是update 更新的意思  45 是第45次更新</p>
<p>为什么要新建u开头的project？<span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvcHJvamVjdHMvamRrOHUvcWFuZGEuaHRtbA==">http://openjdk.java.net/projects/jdk8u/qanda.html<i class="fa fa-external-link-alt"></i></span></p>
<p>b07是不是发布JDK6u1时，JDK6作为开发分支的最后一个buid号？<br>每个release（无论是大版本的第一个release还是后面小版本的update release）在真的发布前都会经过很多次build。开发过程中通常是每周一build来做整合测试，临发布前会选择一个build作为候选版本跑更完整的测试，当这些测试都通过之后就发布。<br>所以6u18b07的意思就是针对JDK 6 update 18这个release，这是第07个build。<br>每个release的build number都是独立递增的，从1开始。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>OpenJDK 是一个自由开放源始码软件实现在Java Platform, Standard Edition (Java SE)。<br>在OpenJDK之前，许多各式各样不同的公司和组织推出好几个免费的Java实现。其中一个例子是Apache<br>Harmony。 IBM也有提供Java实现，而RedHat则是通过IcedTea项目提供它：一个用于OpenJDK的架构和集<br>成项目。</p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><table>
<thead>
<tr>
<th>版本</th>
<th>年份</th>
<th>new feature</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>JDK Beta</td>
<td>1994</td>
<td></td>
<td></td>
</tr>
<tr>
<td>JDK 1.0</td>
<td>1996</td>
<td></td>
<td>几百个类</td>
</tr>
<tr>
<td>JDK 1.1</td>
<td>1997</td>
<td>内部类、JDBC、RMI</td>
<td></td>
</tr>
<tr>
<td>J2SE 1.2</td>
<td>1998</td>
<td>collections框架 - 作者Joshua Bloch</td>
<td></td>
</tr>
<tr>
<td>J2SE 1.3</td>
<td>2000</td>
<td>HotSpot JVM</td>
<td></td>
</tr>
<tr>
<td>J2SE 1.4</td>
<td>2002</td>
<td>仿照perl的正则、NIO</td>
<td></td>
</tr>
<tr>
<td><strong>J2SE 5.0</strong></td>
<td>2005</td>
<td><strong>大量语法糖</strong>: 泛型、自动封装、枚举等</td>
<td>三千多个类</td>
</tr>
<tr>
<td>Java SE 6</td>
<td>2006</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Java SE 7</td>
<td>2011</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Java SE 8</strong></td>
<td>2014</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Java SE 9</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h1><h2 id="openJDK"><a href="#openJDK" class="headerlink" title="openJDK"></a>openJDK</h2><ul>
<li>官方源码：<span class="exturl" data-url="aHR0cDovL2hnLm9wZW5qZGsuamF2YS5uZXQv">http://hg.openjdk.java.net/<i class="fa fa-external-link-alt"></i></span>  采用<code>Mercurial(Hg)</code>管理，类似git</li>
<li><code>Github</code>镜像：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkaw==">https://github.com/dmlloyd/openjdk<i class="fa fa-external-link-alt"></i></span>  <ul>
<li>这是对<code>官方Git仓库</code>的实时同步。很赞。怎么做到的？用的github插件？</li>
</ul>
</li>
</ul>
<p>阅读笔记</p>
<ul>
<li>Jdk1.8源码解析 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d1cGVpeHVhbi9KREtTb3VyY2VDb2RlMS44">https://github.com/wupeixuan/JDKSourceCode1.8<i class="fa fa-external-link-alt"></i></span></li>
<li>JDK源码阅读笔记 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYXN3YWxrZXIvSkRL">https://github.com/seaswalker/JDK<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvZGVmb2xsb3dlci9PcGVuSkRLLVJlc2VhcmNo">https://github.com/codefollower/OpenJDK-Research<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvSkRLLTEuMC4yL2Jsb2IvbWFzdGVyL3NyYy8=">java 1.0.2 源码 - 第一个稳定版JDK<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="">java 1.4 源码</a>  对比1.5来看</li>
<li><a href="">java 1.5 源码</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazd1L2pkazd1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcw==">java 7 源码<i class="fa fa-external-link-alt"></i></span> 对比8来看</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazh1L2pkazh1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcw==">java 8 源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript与typescript的对比</title>
    <url>/pub/ad7baabf/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI1NDIxMTk2">https://www.zhihu.com/question/25421196<i class="fa fa-external-link-alt"></i></span></p>
<p>js做不到的事情指的是</p>
<p>1：搞面向对象巨方便</p>
<p>2：可选的强类型可以让你在程序运行之前多发现一些错误</p>
<p>3：为IDE给javascript弹智能提示打下了良好的基础</p>
<p>除了语法糖，ts最大的特点应该是静态类型， 包括ts里类的public protected private 也只是做静态类型检查用，</p>
<p> TypeScript 总体来讲最重要的在于 Scalable.如果只是写个两三千行的脚本 TypeScript 并不是那么重, 但如果是五六千行, 甚至是数万行, TypeScript 的优势就能发挥出来了.<br> 至于 TypeScript 是 Scalable 的原因, 其实也很简单, 静态类型检查, 代码重构和语言服务. 这些都是 JavaScript 的弱势. 项目大了, 很多时候自己的代码怎么用都记不清楚, 当然第三发的类库就不用说了. 用了 TypeScript, 可以看清楚每一个对象的属性, 方法的参数等, 便利很多.</p>
<p>TypeScript不是 语法上的ECMA6实现，而是以JavaScript为目标语言的，一种编译语言，并且提供向原生JavaScript转换的编译器；而Google的Traceur项目应该才算是ECMA6的语法上实现。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>js</category>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title>Gist 从入门到精通到放弃</title>
    <url>/pub/d051a027/</url>
    <content><![CDATA[<h1 id="gist简介"><a href="#gist简介" class="headerlink" title="gist简介"></a>gist简介</h1><h2 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h2><blockquote>
<p>Gists are a great way to share your work. You can share single files, parts of files, or full applications.</p>
</blockquote>
<p>关键词: <code>share</code>, <code>single</code>, <code>parts</code>。gist的定位就在这几个词里。</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><ul>
<li>为了强调<code>single</code>和<code>parts</code>，gist对git进行阉割，禁用了directory功能。(貌似还禁用了pull功能)</li>
<li>为了强调<code>share</code>，在原来<code>Clone</code>的基础上，额外引入了<code>Embed</code>和<code>Share</code>两个功能。其中<code>Embed</code>(嵌入)实现了仅通过一行JS就能分享到网站(share your work in your website)</li>
</ul>
<ul>
<li>既然要<code>share</code>，那就不能没有feedback，这就像作presentation有问答环节一样。于是加入了<code>comments</code>功能。</li>
</ul>
<h2 id="Gist背后的Git库"><a href="#Gist背后的Git库" class="headerlink" title="Gist背后的Git库"></a>Gist背后的Git库</h2><p>创建的每一个Gist的背后都对应着一个Git版本库</p>
<h1 id="gist-推荐用法"><a href="#gist-推荐用法" class="headerlink" title="gist 推荐用法"></a>gist 推荐用法</h1><p><strong>推荐用法</strong></p>
<ol>
<li>不宜用Gist<ul>
<li>含图片等文件的项目<br><br> 因为Gist不支持directory，file&amp;image最好放在其他地方。<br><br> 最省事的方法：1. 在comment里upload image  2. 在gist doc中引用 3. 删除1中的comment</li>
<li>多个文件的项目</li>
</ul>
</li>
<li>先在comments里写好doc<ul>
<li>主doc不支持markdown preview</li>
<li>主doc有提交慢。因为主doc具有版本管理功能，comments不需要。所以频繁改动状态的doc也最好在comments里写，成形后再放入repo。</li>
</ul>
</li>
<li>用embed js的方式<code>发布gist</code><ul>
<li>解决了多个blog的同步问题</li>
<li>节省blog服务器存储空间</li>
</ul>
</li>
<li>host站点不支持嵌入js怎么办？<ul>
<li>知乎、博客、github.io都不支持js</li>
</ul>
</li>
<li>存放<code>ipynb</code>文件<ul>
<li><code>ipynb</code>一般也是单文件程序(教程)，很适合用gist来管理</li>
</ul>
</li>
</ol>
<p><strong>禁忌用法</strong><br>两个终端同时修改同一个comment，会已最后提交的为准，有内容丢失的风险（不可逆）。</p>
<h1 id="gist-代码片段用法"><a href="#gist-代码片段用法" class="headerlink" title="gist 代码片段用法"></a>gist 代码片段用法</h1><p><strong>片段的优势体现在</strong>：</p>
<ul>
<li>embed。比如一篇博客里面，要贴个代码片段，可直接引用gist。</li>
<li>据说搜索也有优势</li>
</ul>
<h2 id="gistBox-cacher-用法"><a href="#gistBox-cacher-用法" class="headerlink" title="gistBox / cacher 用法"></a>gistBox / cacher 用法</h2><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><strong>文件排序</strong>： 根据文件名的ascii排序，数字&gt; 大写&gt; 小写<br><strong>快捷键</strong>：用Ctrl或者Cmd按着鼠标多处点击进行多选!用中键或者alt进行拖动实现拉选!</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>主doc不能preview</li>
<li>gist embed方式嵌入页面，样式固定，不能自适应网站主题。另外背景是白色，不能融入网站的主题背景。</li>
<li></li>
</ul>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p><strong>为什么要偏要对gist设置private和anonymous？git和wiki却没有，设计初衷是什么？</strong></p>
<p><strong>为什么gist不开放directory？</strong><br>阉割了这个功能，图片等raw文件就不适宜放在gist了</p>
<p><strong>gist不提供Pull Request功能？</strong></p>
<h1 id="类似组件"><a href="#类似组件" class="headerlink" title="类似组件"></a>类似组件</h1><p>bitbucket的Snippets。 不提供<code>embed</code>嵌入方式</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53b3JsZGhlbGxvLm5ldC9nb3RnaXRodWIvMDYtc2lkZS1wcm9qZWN0cy9naXN0Lmh0bWw=">http://www.worldhello.net/gotgithub/06-side-projects/gist.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>github中的git gist wiki区别</title>
    <url>/pub/ef977b92/</url>
    <content><![CDATA[<h2 id="git-gist-wiki-区别"><a href="#git-gist-wiki-区别" class="headerlink" title="git gist wiki 区别"></a>git gist wiki 区别</h2><ul>
<li>git: 这里指 github.com中的repo</li>
<li>gist: gist.github.com</li>
<li>wiki: github.com/ wiki</li>
</ul>
<p>三者都是repo，都记录历史。详细对比如下</p>
<table>
<thead>
<tr>
<th></th>
<th>github repo</th>
<th>gist</th>
<th>wiki</th>
<th>注解</th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9tYXJrdXAjbWFya3Vwcw==">markup支持<i class="fa fa-external-link-alt"></i></span></td>
<td>.md .textile .org .rst .wiki …</td>
<td>同上</td>
<td>同上</td>
<td></td>
</tr>
<tr>
<td>previw_所见即所得</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>可在gist的comment中preview</td>
</tr>
<tr>
<td>MathJax</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>gitpage支持</td>
</tr>
<tr>
<td>private space</td>
<td>收费</td>
<td>√</td>
<td></td>
<td>gist的private repo不能设置密码。不知道搜索引擎能不能搜到</td>
</tr>
<tr>
<td>anonymous</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>Gist提供匿名发布，有时候被用来议论政府，政府害怕所以给墙掉了(DNS污染)</td>
</tr>
<tr>
<td>directory</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>gist是平行文档(一般只一个page)，不支持子目录</td>
</tr>
<tr>
<td>fork &amp; clone</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>comments</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>issue可视为git和wiki的comments，</td>
</tr>
<tr>
<td>多人协作</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>直接用途、设计思想</td>
<td>代码版本管理、协作</td>
<td>分享代码片断</td>
<td>写文档</td>
<td>snippet什么用？</td>
</tr>
<tr>
<td>博客</td>
<td>github.io</td>
<td></td>
<td></td>
<td>gist的embed方式很适合博客，但是多数网站不支持嵌入js</td>
</tr>
<tr>
<td>搜索引擎友好性</td>
<td></td>
<td></td>
<td></td>
<td>gist 在google搜索的 rank较高(据说)</td>
</tr>
<tr>
<td>缺点</td>
<td></td>
<td>不易归类</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>其他特征</p>
<ul>
<li>gist_comment ≈ git_issue  (issue多支持了几种附件类型而已)</li>
<li>GitHub Pages. 这个除了展示静态的网页(网站)之外并没有什么神奇的功能。它对各种文本文档的渲染支持, 比如 .md, .rst, .org 等.</li>
</ul>
<h2 id="gitpage"><a href="#gitpage" class="headerlink" title="gitpage"></a>gitpage</h2><p>官方定义：</p>
<blockquote>
<p>GitHub Pages is deeply integrated with Jekyll, a popular static site generator designed for blogging and software documentation, but used for much more.</p>
</blockquote>
<ul>
<li>github markdown 不支持动态js。</li>
<li>gitpages 不支持动态语言，什么意思？不支持js？还是不支持restapi，数据库，不支持UGC(评论，在线写博客)</li>
</ul>
<p>注意区别这俩。markdown是连js都不支持。gitpage支持了js，但不支持backend</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>github issue</title>
    <url>/pub/3f25fe26/</url>
    <content><![CDATA[<p>每一次commit都可以选择性的与某个issue关联。比如在 <code>message</code>中添加<code>#n</code>，就可以与第n个 issue 进行关联。<br><code>commit message title, #1</code></p>
<p>官方doc：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ndWlkZXMuZ2l0aHViLmNvbS9mZWF0dXJlcy9pc3N1ZXMv">https://guides.github.com/features/issues/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvY2xvc2luZy1pc3N1ZXMtdXNpbmcta2V5d29yZHMv">https://help.github.com/articles/closing-issues-using-keywords/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>By prefacing your commits with:</p>
<ul>
<li><code>fix</code></li>
<li><code>fixes</code>: 例如提交messeage为<code>Fixes #45</code>，当commit被merge到master上时，会自动关闭<code>issue 45</code></li>
<li><code>fixed</code></li>
<li><code>close</code></li>
<li><code>closes</code></li>
<li><code>closed</code></li>
<li><code>resolve</code></li>
<li><code>resolves</code></li>
<li><code>resolved</code></li>
</ul>
<p>when the commit is merged into master, it will also automatically close the issue.</p>
<h2 id="同时操作多个issue"><a href="#同时操作多个issue" class="headerlink" title="同时操作多个issue"></a>同时操作多个issue</h2><p><code>This closes #34, closes #23, and closes example_user/example_repo#42</code></p>
<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><p>Labels，标签。包括 enhancement、bug、invalid 等，表示 issue 的类型，解决的方式。除了自带的以外，也可以去自定义。</p>
<p>Milestone，里程碑。几经修改后，它现在已经与git tag和Github release区分开来，仅仅作为issue的一个集合。通常用来表示项目的一个阶段，比如demo、release等，保护达成这些阶段需要解决的问题。有时候，也会与版本计划重合，比如v1.0、v2.0等。issue不能设置截止时间，但是milestone可以。</p>
<p>Assignee，责任人。指定这个 issue 由谁负责来解决。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>tools</category>
        <category>同步与版本管理</category>
        <category>git</category>
        <category>github</category>
      </categories>
  </entry>
  <entry>
    <title>【hexo源码系列】 入门</title>
    <url>/pub/70d0eddc/</url>
    <content><![CDATA[<h1 id="为什么要看源码"><a href="#为什么要看源码" class="headerlink" title="为什么要看源码"></a>为什么要看源码</h1><p>能够更便捷高效的管理博客，比如</p>
<ul>
<li><strong>更新Hexo</strong>: 需要了解<code>hexo init</code>的源码，因为该命令隐藏了<code>hexo-starter</code>项目 ()</li>
<li><strong>更新theme</strong>: 某些<code>bug-fix</code>以及<code>new feature</code>。可借助git的<code>submodule</code>来高效管理</li>
<li><strong>定制博客(个性化)</strong>: (比如添加edit button，添加URL哈希，个性化主题。需要了解模板原理</li>
</ul>
<p>源码不用细看，看个大概能满足自己的需求就够了。</p>
<p>本文仅介绍<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXN0YXJ0ZXI=">Hexo基础包<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3BsdWdpbnMv">扩展包<i class="fa fa-external-link-alt"></i></span>可参考【Hexo插件系列】博客。</p>
<h1 id="查看Hexo和Plugin版本"><a href="#查看Hexo和Plugin版本" class="headerlink" title="查看Hexo和Plugin版本"></a>查看Hexo和Plugin版本</h1><p>首先看一下自己的Hexo和Plugin版本，因为不同的版本是不同的实现。版本号是次要的，主要看是不是同一种包。比如<code>hexo-deployer-git</code>和<code>hexo-deployer-rsync</code>在执行<code>hexo d</code>命令时方式就不同。详见<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>查看<code>package.json</code>文件的依赖项。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;:</span> &#123;</span><br><span class="line">  <span class="attr">&quot;hexo&quot;:</span> <span class="string">&quot;^3.7.0&quot;</span>, <span class="comment"># https://github.com/hexojs/hexo/  hexo仅仅是一个module而已，用于...</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-archive&quot;:</span> <span class="string">&quot;^0.1.5&quot;</span>,  <span class="comment"># generator最复杂</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-category&quot;:</span> <span class="string">&quot;^0.1.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-index&quot;:</span> <span class="string">&quot;^0.2.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-tag&quot;:</span> <span class="string">&quot;^0.2.0&quot;</span>, <span class="comment"># nodejs的模板引擎，有EJS、Jade、Swig、Haml。theme-next采用的swig</span></span><br><span class="line">  <span class="attr">&quot;hexo-renderer-ejs&quot;:</span> <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-stylus&quot;:</span> <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-marked&quot;:</span> <span class="string">&quot;^0.3.2&quot;</span>,  <span class="comment"># markdown的render engine，即`.md`转`html`</span></span><br><span class="line">  <span class="attr">&quot;hexo-server&quot;:</span> <span class="string">&quot;^0.3.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可用以下命令查看版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm ls --depth 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更新各个模块，命令 npm update</p>
</blockquote>
<h1 id="回顾Hexo搭建流程"><a href="#回顾Hexo搭建流程" class="headerlink" title="回顾Hexo搭建流程"></a>回顾Hexo搭建流程</h1><p>以下来自<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2Jsb2IvbWFzdGVyL1JFQURNRS5tZA==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Installation</span></span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Setup your blog</span></span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Start the server</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create a new post</span></span><br><span class="line">$ hexo new <span class="string">&quot;Hello Hexo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Generate static files</span></span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>


<h1 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h1><h2 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h2><p>npm是nodejs的包管理器，管理javascript lib<br>hexo-cli是nodejs的一个包，用于运行hexo命令。(有cli难道还有server？)</p>
<p>npm list -g 能够看到安装路径。一般在/usr/lib/node_modules/ 或者/usr/local/lib/node_modules/</p>
<h2 id="2-hexo-init"><a href="#2-hexo-init" class="headerlink" title="2. hexo init"></a>2. hexo init</h2><p><code>hexo init</code>命令做了什么？</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p><code>hexo init</code>等价于以下两行shell命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Cloning hexo-starter to blog</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/hexojs/hexo-starter.git blog</span><br><span class="line"><span class="comment"># 2. Install dependencies</span></span><br><span class="line">$ npm install --production</span><br></pre></td></tr></table></figure>

<p>看到这里，就够用。如果自己的hexo项目是老版本的，可以在这个仓库pull更新(虽然更新很少)。<br>如果对追寻答案的过程感兴趣，可以继续往下看。</p>
<h3 id="追寻答案的旅程-optional"><a href="#追寻答案的旅程-optional" class="headerlink" title="追寻答案的旅程 - optional"></a>追寻答案的旅程 - optional</h3><p><strong>首先看一下hexo</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> hexo</span><br><span class="line">/usr/bin/hexo</span><br><span class="line"></span><br><span class="line">$ cat /usr/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">require(<span class="string">&#x27;../lib/hexo&#x27;</span>)();</span><br></pre></td></tr></table></figure>


<p>这里你会发现，hexo命令是nodejs脚本。 <code>../lib/hexo</code>对应的是<code>usr/lib/hexo</code>，然而没有path。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/hexo</span><br><span class="line"> /usr/bin/hexo -&gt; ../lib/node_modules/hexo-cli/bin/hexo</span><br></pre></td></tr></table></figure>

<p>原来<code>/usr/bin/hexo</code>是个符号链接，链接到nodejs的modules目录里。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat /usr/lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">require(<span class="string">&#x27;../lib/hexo&#x27;</span>)();</span><br></pre></td></tr></table></figure>

<p>即<code>hexo</code>命令对应的是<a href="https://github.com/hexojs/hexo-cli/blob/master/lib/hexo.js"><code>/usr/lib/node_modules/hexo-cli/lib/hexo.js</code></a>文件。</p>
<p>hexo找到了，init命令呢？讲道理应该是个package.json下的script。</p>
<p>原生<code>hexo-cli</code>提供了4个命令，都在<code>hexo-cli/lib/console</code>路径下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo help</span><br><span class="line">$ hexo init</span><br><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>扩展命令通过<code>hexo-cli/lib/extends.console.js</code>实现。</p>
<p><strong>hexo init 命令</strong></p>
<p><strong><code>init.js</code>核心代码</strong></p>
<p>路径<code>hexo-cli/lib/console/init.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> GIT_REPO_URL = <span class="string">&#x27;https://github.com/hexojs/hexo-starter.git&#x27;</span>;</span><br><span class="line"><span class="comment">// 1. git clone --recursive https://github.com/hexojs/hexo-starter.git blog</span></span><br><span class="line">log.info(<span class="string">&#x27;Cloning hexo-starter to&#x27;</span></span><br><span class="line">spawn(<span class="string">&#x27;git&#x27;</span>, [<span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--recursive&#x27;</span>, GIT_REPO_URL, target]);</span><br><span class="line">removeGitDir(target);</span><br><span class="line">removeGitModules(target);</span><br><span class="line"><span class="comment">// 2. npm install --production</span></span><br><span class="line">log.info(<span class="string">&#x27;Install dependencies&#x27;</span>);</span><br><span class="line">spawn(npmCommand, [<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--production&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>实际上吧，如果hexo的log打印出来<code>GIT_REPO_URL</code>就更清晰，非要藏起来等人挖掘。</p>
<p><strong>参考</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXN0YXJ0ZXI=">hexo-starter项目<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvaGV4by5qcw==">hexo.js源码 | hexo-cli 项目<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvY29uc29sZS9pbml0Lmpz">hexo init 命令源码 | hexo-cli 项目<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="3-hexo-server"><a href="#3-hexo-server" class="headerlink" title="3. hexo server"></a>3. hexo server</h2><p>这个不属于hexo-cli了。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXNlcnZlci9ibG9iL21hc3Rlci9saWIvc2VydmVyLmpz">hexo server命令源码<i class="fa fa-external-link-alt"></i></span></p>
<p>暂没兴趣，应该就是启了个nodejs HttpServer。待看</p>
<ul>
<li>额外的逻辑是，如果没generate，先调一下 hexo g</li>
</ul>
<p>但是偶尔出现的bug来源于<code>hexo s</code>，这里的逻辑还需要看一下。</p>
<h2 id="4-hexo-new"><a href="#4-hexo-new" class="headerlink" title="4. hexo new"></a>4. hexo new</h2><h2 id="5-hexo-generate"><a href="#5-hexo-generate" class="headerlink" title="5. hexo generate"></a>5. hexo generate</h2><p>生成器（Generator）<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9nZW5lcmF0b3IuaHRtbA==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>这个好麻烦，看不动了。这么多<code>generator</code>和<code>render</code>。</p>
<p>放个链接 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWdlbmVyYXRvci1pbmRleA==">https://github.com/hexojs/hexo-generator-index<i class="fa fa-external-link-alt"></i></span> ，貌似主要先看这个。</p>
<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>generates static files</p>
<p>这一步最慢。<br>常用的有hexo-renderer-marked<br>hexo-renderer-pandoc</p>
<h3 id="render-模板引擎"><a href="#render-模板引擎" class="headerlink" title="render 模板引擎"></a>render 模板引擎</h3><p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9yZW5kZXJlci5odG1s">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9yZW5kZXJpbmcuaHRtbA==">https://hexo.io/zh-cn/api/rendering.html<i class="fa fa-external-link-alt"></i></span></p>
<p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p>
<p>生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p>
<p>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</p>
<ul>
<li>.md解析成html</li>
<li>.swig渲染为html</li>
</ul>
<h3 id="数据的填充"><a href="#数据的填充" class="headerlink" title="数据的填充"></a>数据的填充</h3><p>数据的填充主要是 hexo -g 的时候将数据传递给 swig 模板，然后再由 swig 模板填充到 HTML 中。</p>
<h2 id="6-hexo-deploy"><a href="#6-hexo-deploy" class="headerlink" title="6. hexo deploy"></a>6. hexo deploy</h2><p>deploy到底干了什么？执行了git push？</p>
<p>deploy配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xu-song/xu-song.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p>
<p><strong>deploy.js核心源码</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWRlcGxveWVyLWdpdC9ibG9iL21hc3Rlci9saWIvZGVwbG95ZXIuanMjTDgz">https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js#L83<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git(<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;-A&#x27;</span>);  <span class="comment">// 对publc目录中执行add操作。</span></span><br><span class="line">git(<span class="string">&#x27;commit&#x27;</span>, <span class="string">&#x27;-m&#x27;</span>, message);</span><br><span class="line">git(<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;-u&#x27;</span>, repo.url, <span class="string">&#x27;HEAD:&#x27;</span> + repo.branch, <span class="string">&#x27;--force&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>即等价于以下几个命令(通常情况下)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ rm -rf .deploy_git  <span class="comment"># log.info(&#x27;Clearing .deploy_git folder...&#x27;);</span></span><br><span class="line">$ cp -rf public .deploy_git <span class="comment"># log.info(&#x27;Copying files from public folder...&#x27;);</span></span><br><span class="line">$ <span class="built_in">cd</span> .deploy_git</span><br><span class="line"></span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">&quot;Site updated: 2018-01-30 *:*:*&quot;</span> <span class="comment">#某时间</span></span><br><span class="line">$ git push -u origin HEAD:master --force</span><br></pre></td></tr></table></figure>

<p>上面命令使用–force选项，强制push到远程主机，会使远程主机更新的版本被覆盖。所以不要在deploy之后的仓库做提交，要在dev仓库提交。</p>
<p>实例：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hzdW5nL2Jsb2ctZGV2LyNzdWJtb2R1bGU=">Dev Repository<i class="fa fa-external-link-alt"></i></span> Main project for all submodules</li>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcveHUtc29uZy5naXRodWIuaW8v">Deployed Repository<i class="fa fa-external-link-alt"></i></span> is deployed by Hexo from <code>Dev Repository</code></li>
<li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cDovL3h1c29uZy52aXAv">Demo Site<i class="fa fa-external-link-alt"></i></span> hosts the <code>Deployed Repository</code></li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s">hexo deploy官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWRlcGxveWVyLWdpdC9ibG9iL21hc3Rlci9saWIvZGVwbG95ZXIuanM=">hexo deploy.js源码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NoZXJyeWJsb2cuc2l0ZS9oZXhvLTQuaHRtbA==">http://cherryblog.site/hexo-4.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NoZXJyeWJsb2cuc2l0ZS9oZXhvLTQuaHRtbA==">深入理解 Hexo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NvZGVydW50aGluZ3MuY29tLzIwMTcvMDgvMjAvaG93aGV4b3dvcmtzLw==">hexo是怎么工作的<i class="fa fa-external-link-alt"></i></span><h2 id="7-Hexo-的模板引擎"><a href="#7-Hexo-的模板引擎" class="headerlink" title="7. Hexo 的模板引擎"></a>7. Hexo 的模板引擎</h2>这个<code>render</code>讲道理应该是在<code>hexo g</code>的时候调用的。 待看</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
        <category>src</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>源码</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack简介</title>
    <url>/pub/53ff0523/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Webpack这个工具可以将你的所有代码和可选择地将依赖捆绑成一个单独<br>的 .js 文件。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装webpack</span></span><br><span class="line">$ npm install -g webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># webpack 已经将 webpack 命令行相关的内容都迁移到 webpack-cli，所以除了 webpack 外，我们还需要安装 webpack-cli：</span></span><br><span class="line">$ npm install webpack-cli -D -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">$ npx webpack --version</span><br></pre></td></tr></table></figure>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>根目录下新建<code>webpack.config.js</code></p>
<p>webpack</p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sh</span><br></pre></td></tr></table></figure>


<p> webpack 4 引入的，有俩种模式，development 与 production，默认为 production - 其实还有一个隐藏的 none 模式</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZW1kZW1vL2NoZW1kZW1vLmdpdGh1Yi5pby9pc3N1ZXMvMTM=">https://github.com/chemdemo/chemdemo.github.io/issues/13<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d3dWhhb2xpbi9ibG9nL2lzc3Vlcy8xMw==">Parcel Vs Webpack<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>front-end</category>
        <category>前端构建工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Coding Pages托管静态博客-原理浅析</title>
    <url>/pub/d2f02b9b/</url>
    <content><![CDATA[<p>参考 DNS解析实例-ESON</p>
<blockquote>
<p>github page不支持多个域名，因此不存在重定向</p>
</blockquote>
<h2 id="301，302-区别"><a href="#301，302-区别" class="headerlink" title="301，302 区别"></a>301，302 区别</h2><h3 id="对于用户"><a href="#对于用户" class="headerlink" title="对于用户"></a>对于用户</h3><p>301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。页面跳到了这个新的url指向的地方。</p>
<h3 id="对于引擎及站长"><a href="#对于引擎及站长" class="headerlink" title="对于引擎及站长"></a>对于引擎及站长</h3><h4 id="302-redirect-302-代表暂时性转移-Temporarily-Moved-临时跳转"><a href="#302-redirect-302-代表暂时性转移-Temporarily-Moved-临时跳转" class="headerlink" title="302 redirect: 302 代表暂时性转移(Temporarily Moved ) 临时跳转"></a>302 redirect: 302 代表暂时性转移(Temporarily Moved ) 临时跳转</h4><p>302转向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊。</p>
<p>302重定向和网址劫持（URL hijacking）有什么关系呢？这要从搜索引擎如何处理302转向说起。从定义来说，从网址A做一个302重定向到网址B时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。</p>
<p>实际上如果搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。</p>
<p>由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>
<p>DNS解析有一条 显性URL-将域名302重定向到另外一个地址。</p>
<h4 id="301-redirect-301-代表永久性转移-Permanently-Moved-，"><a href="#301-redirect-301-代表永久性转移-Permanently-Moved-，" class="headerlink" title="301 redirect: 301 代表永久性转移(Permanently Moved)，"></a>301 redirect: 301 代表永久性转移(Permanently Moved)，</h4><p>当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。<br>301的好处是:</p>
<ul>
<li>第一， 没有网址规范化问题。</li>
<li>第二， 也很重要的，网页A的PR网页级别会传到网页B。</li>
</ul>
<p>变更网站域名建议直接做301重定向，UEL跳转不利于SEO蜘蛛本身不喜欢，运气不好还会被判作弊<br>当网页A用301重定向到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。<br>好处是，第一没有网址规划问题；第二，网页A的PR网页级别会传到网页B。</p>
<h2 id="大家常用的301-302"><a href="#大家常用的301-302" class="headerlink" title="大家常用的301 302"></a>大家常用的301 302</h2><h3 id="301"><a href="#301" class="headerlink" title="301"></a>301</h3><p>t.cn<br>知乎跳转<br>dns解析跳转<br>coding page跳转主页</p>
<h2 id="如何实现转发"><a href="#如何实现转发" class="headerlink" title="如何实现转发"></a>如何实现转发</h2><ul>
<li>DNS可配置 302转发</li>
<li>apache / nginx 配置文件中写转发规则，rewrite xxx yyy 301</li>
<li>写一个 index.html 文件，里面写 meta refresh 跳转规则</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
        <category>coding-pages</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack原理</title>
    <url>/pub/6e75b89d/</url>
    <content><![CDATA[<p>webpack是一个js打包工具，不是一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。</p>
<h3 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h3><ul>
<li><code>entry</code> 一个可执行模块或库的入口文件。Webpack 执行构建的第一步将从 Entry 开始</li>
<li><code>Module</code>：模块，在 Webpack 里一切皆模块，一个模块对于着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li>
<li><code>chunk</code> 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk 这体现了webpack的打包机制。</li>
<li><code>loader</code> 文件转换器，例如把es6转换为es5，scss转换为css。</li>
<li><code>plugin</code> 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。</li>
</ul>
<p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。<br>每找到一个 Module 就会根据配置的 Loader 规则去找出对应的转换规则立即对 Module 进行转换后，再解析出当前 Module 依赖的 Module。<br>这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有的 Chunk 转换成文件输出。<br>在整个流程中 Webpack 会在恰当的时候执行 Plugin 里定义的逻辑。</p>
<h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><p>从启动webpack构建到输出结果经历了一系列过程，它们是：</p>
<ol>
<li>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。</li>
<li>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</li>
<li>从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</li>
<li>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</li>
<li>递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。</li>
<li>输出所有chunk到文件系统。</li>
</ol>
<p>需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如UglifyJsPlugin会在loader转换递归完后对结果再使用UglifyJs压缩覆盖之前的结果。</p>
<h2 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a>webpack原理</h2><ol>
<li>一切皆模块<br><br>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。</li>
<li>按需加载<br><br>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。</li>
</ol>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>示例文件 webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: <span class="doctag">@AngularClass</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look in ./config folder for webpack.dev.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.NODE_ENV) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;prod&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;production&#x27;</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">&#x27;./config/webpack.prod&#x27;</span>)(&#123;<span class="attr">env</span>: <span class="string">&#x27;production&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;testing&#x27;</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">&#x27;./config/webpack.test&#x27;</span>)(&#123;<span class="attr">env</span>: <span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;dev&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;development&#x27;</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">&#x27;./config/webpack.dev&#x27;</span>)(&#123;<span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tsconfig.webpack.json</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;:</span> <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;:</span> <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;:</span> <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;noEmit&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;noEmitHelpers&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lib&quot;:</span> [</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dom&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;:</span> <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;:</span> &#123;</span><br><span class="line">      <span class="string">&quot;@angular/*&quot;</span><span class="string">:</span> [<span class="string">&quot;node_modules/@angular/*&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;:</span> [</span><br><span class="line">      <span class="string">&quot;node_modules/@types&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;types&quot;:</span> [</span><br><span class="line">      <span class="string">&quot;hammerjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;node&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;exclude&quot;:</span> [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;client/dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;client/src/**/*.spec.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;client/src/**/*.e2e.ts&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;awesomeTypescriptLoaderOptions&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;forkChecker&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;useWebpackText&quot;:</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;angularCompilerOptions&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;genDir&quot;:</span> <span class="string">&quot;./compiled&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;skipMetadataEmit&quot;:</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;compileOnSave&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;buildOnSave&quot;:</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;atom&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;rewriteTsconfig&quot;:</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d3dWhhb2xpbi9ibG9nL2lzc3Vlcy80">https://github.com/gwuhaolin/blog/issues/4<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3dlYnBhY2sud3VoYW9saW4uY24v">深入浅出 Webpack<i class="fa fa-external-link-alt"></i></span></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>front-end</category>
        <category>前端构建工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages示例网站</title>
    <url>/pub/30663d8e/</url>
    <content><![CDATA[<h2 id="pytorch-org"><a href="#pytorch-org" class="headerlink" title="pytorch.org"></a>pytorch.org</h2><p><span class="exturl" data-url="aHR0cDovL3B5dG9yY2gub3JnLw==">http://pytorch.org<i class="fa fa-external-link-alt"></i></span> 搭建在github pages上。对应 pytorch.github.io</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig pytorch.org</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; pytorch.org</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 32725</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4000</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;pytorch.org.			IN	A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">pytorch.org.		3323	IN	A	185.199.108.153</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 82 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.16.101#53(192.168.16.101)</span></span><br><span class="line"><span class="string">;; WHEN: Tue Oct 23 13:34:25 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 56</span></span><br></pre></td></tr></table></figure>


<p><span class="exturl" data-url="aHR0cDovL3B5dG9yY2gub3JnL3R1dG9yaWFscw==">http://pytorch.org/tutorials<i class="fa fa-external-link-alt"></i></span> 站点对应 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvdHV0b3JpYWxz">https://github.com/pytorch/tutorials<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kaXNjdXNzLnB5dG9yY2gub3JnLw==">https://discuss.pytorch.org/<i class="fa fa-external-link-alt"></i></span> 则需要必须要借助后台服务器，因此是独立的主机名</p>
<p>国内测速，，都超时。<br>百度收录2个网页</p>
<p><span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9kbnMv">http://tool.chinaz.com/dns/<i class="fa fa-external-link-alt"></i></span> dns测速，都不通  测速有毛病吧，我手机都能连上</p>
<h2 id="hexo-io"><a href="#hexo-io" class="headerlink" title="hexo.io"></a>hexo.io</h2><p>hexo.io 采用的美国 CloudFlare公司CDN节点，外加CloudFlare的SSL证书</p>
<p>Issued by: Let’s Encrypt Authority X3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig hexo.io</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; hexo.io</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 12407</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4000</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;hexo.io.			IN	A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">hexo.io.		16	IN	A	206.189.89.118</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 108 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.16.101#53(192.168.16.101)</span></span><br><span class="line"><span class="string">;; WHEN: Tue Oct 23 13:36:21 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 52</span></span><br></pre></td></tr></table></figure>


<p>百度仅收录了 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==">https://hexo.io/zh-cn/<i class="fa fa-external-link-alt"></i></span> 目录。如何做到的</p>
<h2 id="scikit-image-org"><a href="#scikit-image-org" class="headerlink" title="scikit-image.org"></a>scikit-image.org</h2><div class="note info">
            <p> <strong>信息</strong></p><ul><li>等价站点: <span class="exturl" data-url="aHR0cHM6Ly9zY2lraXQtaW1hZ2UuZ2l0aHViLmlvLw==">https://scikit-image.github.io<i class="fa fa-external-link-alt"></i></span></li><li>github pages项目: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaWtpdC1pbWFnZS9zY2lraXQtaW1hZ2UuZ2l0aHViLmNvbQ==">https://github.com/scikit-image/scikit-image.github.com<i class="fa fa-external-link-alt"></i></span></li><li>网站源码: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaWtpdC1pbWFnZS9zY2lraXQtaW1hZ2Utd2Vi">https://github.com/scikit-image/scikit-image-web<i class="fa fa-external-link-alt"></i></span></li><li>https证书<ul><li>Issued by: Let’s Encrypt Authority X3</li><li>Signature Algorithm: SHA-256 with RSA Encryption ( 1.2.840.113549.1.1.11 )</li><li>Public Key Algorithm: RSA Encryption ( 1.2.840.113549.1.1.1 )</li></ul></li></ul>
          </div>

<p>采用的rst (ReStructuredText)格式</p>
<div class="note warning">
            <p> <strong>疑问</strong></p><ul><li>采用jekyll模板吗？</li><li>DNS解析为什么没有CNAME记录？</li></ul>
          </div>



<p>DNS分析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig scikit-image.org</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; scikit-image.org</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 44723</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4000</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;scikit-image.org.		IN	A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">scikit-image.org.	1678	IN	A	185.199.108.153</span></span><br><span class="line"><span class="string">scikit-image.org.	1678	IN	A	185.199.109.153</span></span><br><span class="line"><span class="string">scikit-image.org.	1678	IN	A	185.199.110.153</span></span><br><span class="line"><span class="string">scikit-image.org.	1678	IN	A	185.199.111.153</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 50 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.16.101#53(192.168.16.101)</span></span><br><span class="line"><span class="string">;; WHEN: Tue Oct 23 13:26:48 CST 2018</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 109</span></span><br></pre></td></tr></table></figure>

<h2 id="scrapy-org"><a href="#scrapy-org" class="headerlink" title="scrapy.org"></a>scrapy.org</h2><p>采用jekyll模板</p>
<p>网站源码: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjcmFweS9zY3JhcHkub3Jn">https://github.com/scrapy/scrapy.org<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
        <category>github-pages</category>
      </categories>
  </entry>
  <entry>
    <title>Github Pages托管静态博客-原理浅析</title>
    <url>/pub/bfc2ae40/</url>
    <content><![CDATA[<h2 id="关于github提供的http-server"><a href="#关于github提供的http-server" class="headerlink" title="关于github提供的http server"></a>关于github提供的http server</h2><h4 id="ping-几个不同账号的gitpage-比如colah-github-io-xu-song-github-io-，发现对应的是同一个ip。为什么返回的页面不同呢？"><a href="#ping-几个不同账号的gitpage-比如colah-github-io-xu-song-github-io-，发现对应的是同一个ip。为什么返回的页面不同呢？" class="headerlink" title="ping 几个不同账号的gitpage(比如colah.github.io,xu-song.github.io)，发现对应的是同一个ip。为什么返回的页面不同呢？"></a>ping 几个不同账号的gitpage(比如<code>colah.github.io</code>,<code>xu-song.github.io</code>)，发现对应的是同一个ip。为什么返回的页面不同呢？</h4><p>github pages 的 CNAME 是绑定 pages.github.io，不是${username}.github.io</p>
<p>coding.net 的 CNAME 是绑定 pages.coding.me</p>
<p>显然，Github肯定在后台做了处理。即github自身会维护一个映射，<code>host_name --&gt; www_path</code>，这样就可以根据不同的host信息返回不同的html了。</p>
<p>这样，在访问<code>xu-song.github.io</code>时github就找到了该返回的html。</p>
<h2 id="关于custom-domain"><a href="#关于custom-domain" class="headerlink" title="关于custom domain"></a>关于custom domain</h2><p>现在我们改用<code>custom domain</code>的方式访问gitpage主页。假设已经配置好了dns的A记录映射。<br>访问<code>xusong.vip</code>，dns解析得到ip地址。然而这次github服务器得到的host是<code>xusong.vip</code>。懵逼了，github不认识<code>xusong.vip</code>(host数据里没有该记录)，返回404页面</p>
<image src="https://user-images.githubusercontent.com/13825126/35623051-fc61df6c-06c4-11e8-89a7-6207bc430d85.PNG" style="width: 60%;">


<p><strong>怎么办呢？</strong></p>
<p>那就让github认识一下<code>xusong.vip</code>，也就是在github page里设置一下custom domain，或者添加CNAME文件，详见[用Github Pages搭建独立域名的个人博客](../利用Github Pages搭建独立域名的个人博客/)</p>
<ul>
<li><input disabled="" type="checkbox"> 如果DNS设置CNAME记录，是不是github page不用设置就能work？</li>
</ul>
<h2 id="那么上一篇中的重重疑点也就解开了"><a href="#那么上一篇中的重重疑点也就解开了" class="headerlink" title="那么上一篇中的重重疑点也就解开了"></a>那么上一篇中的重重疑点也就解开了</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 每个账号的gitpage都是独立的IP吗？github怎么这么多独立外网IP？还是不同账号共用IP？<ul>
<li>很多账号是同一个ip。</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 不同github page共享ip 正因为如此，才需要<code>步骤3</code>的设置。</li>
<li><input checked="" disabled="" type="checkbox"> 配置github pages的custom domain，其作用仅仅是<code>xu-song.github.io --&gt; xusong.vip (重定向)</code>吗？<ul>
<li>不是。1. 查dns解析是否通过 2. 部署到github服务器的相应目录（因为） 3. github page到domain的重定向</li>
</ul>
</li>
</ul>
<h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><h3 id="为什么Github-Pages不支持为自定义域名添加SSL证书？"><a href="#为什么Github-Pages不支持为自定义域名添加SSL证书？" class="headerlink" title="为什么Github Pages不支持为自定义域名添加SSL证书？"></a>为什么Github Pages不支持为自定义域名添加SSL证书？</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zdGVmZmFuLmNuLzIwMTcvMDMvMjIvdXNlLWNsb3VkZmxhcmUtdG8taW1wbGVtZW50LUhUVFBTLWZvci1HaXRodWJQYWdlcy13aXRoLWN1c3RvbS1kb21haW4tbmFtZXMv">https://steffan.cn/2017/03/22/use-cloudflare-to-implement-HTTPS-for-GithubPages-with-custom-domain-names/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="多个域名能否指向同一个-GitHub-Pages？"><a href="#多个域名能否指向同一个-GitHub-Pages？" class="headerlink" title="多个域名能否指向同一个 GitHub Pages？"></a>多个域名能否指向同一个 GitHub Pages？</h2><p>GitHub Pages 的官方文档，一个 username.github.io 只能支持一个域名。</p>
<p>coding page支持多个域名。</p>
<h2 id="一个账号能否见多个github-page？"><a href="#一个账号能否见多个github-page？" class="headerlink" title="一个账号能否见多个github page？"></a>一个账号能否见多个github page？</h2><p>可以建立多个， 个人账户page只能有一个， 项目page可以有多个</p>
<p>比如你的账号名为  username, 项目叫 project1    那你可以通过  username.github.io/project1 访问， 如果配置了个人域名就可以用自己的域名访问了</p>
<p>但是CNAME不能指向username.github.io/project1，怎么办？</p>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul>
<li><input disabled="" type="checkbox"> 如何解决md同步问题？<ul>
<li>git-repo源，gist源，git issue源，gitpage源。最优的方式就是同源 + 自动deploy。</li>
<li>方式一：以issue作源，要自己利用github api，读取issue，然后写到source目录(貌似也挺简单)。</li>
<li>方式二：以git-repo作源，貌似不错哎。单独把source目录单独作为repo</li>
<li>方式三：以gist作源：易集成(一行js即可)，但不易管理(不支持directory，文档多了很麻烦)</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 如何实现在线写blog，像wordpress那样<ul>
<li>用js调用github api，或者其他后台api即可</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
        <category>github-pages</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>pages</tag>
      </tags>
  </entry>
  <entry>
    <title>【读图识政治】国家机构中的新面孔 - 国家监察委员会</title>
    <url>/pub/65bf8f/</url>
    <content><![CDATA[<h1 id="这是标题"><a href="#这是标题" class="headerlink" title="这是标题"></a>这是标题</h1><img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革前 - 中纪委监委.jpg">

<p>afda</p>
<img alt="" src="/images/raw/Politics - 国家监察委员会 - 监察对象 - 中纪委监委.jpg">

<p>fad</p>
<img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革后1 - 中纪委监委.jpg">

<p>fad</p>
<img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革后2 - 中纪委监委.jpg">


<h3 id="监察委干嘛的，跟纪委有关系没？功能冲突不？"><a href="#监察委干嘛的，跟纪委有关系没？功能冲突不？" class="headerlink" title="监察委干嘛的，跟纪委有关系没？功能冲突不？"></a>监察委干嘛的，跟纪委有关系没？功能冲突不？</h3><p>国家监察委员会是中国特色的国家<code>反腐败机构</code>，这个机构将与中国国务院等机构并列为正国级单位。国家监察委员会或将与现在的中纪委<span class="exturl" data-url="aHR0cDovL3d3dy5jY2RpLmdvdi5jbi9zcGVjaWFsL3ptc2pkL3ptMTlkYV96bTE5ZGEvMjAxODAyL3QyMDE4MDIwMl8xNjMxNzYuaHRtbA==">合署办公<i class="fa fa-external-link-alt"></i></span>。</p>
<img alt="国家监察委员会--2018" src="/images/raw/Politics - 党和国家机构改革 - 国家监察委员会 - 人民日报.gif">


<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1NekF4TURVME1EWXdNUT09Jm1pZD0yNjUzMDA2NjExJmlkeD0yJnNuPWYxMWIyMDU0MWExYmJkOGYzMTU1ZDc4MzMzZGY3NWFmJmNoa3NtPTgwOWJjODQ1YjdlYzQxNTM5NjUyY2Y1OTY1MmQ5NTQxODViOWVmMzViNTY1NjY2MmU2ZmIzOWM3NzVjYmZiNDExNDQ1OTM1ZjdhNjYmbXBzaGFyZT0xJnNjZW5lPTIzJnNyY2lkPTAzMjVka2dsb05kenYxMmFYRmpDQ3V1RiNyZA==">监察委员会，国家机构中的新面孔｜长漫画 - 中央纪委国家监委网站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>others</category>
        <category>politics</category>
        <category>china</category>
        <category>国家机构</category>
        <category>国家监察机关</category>
      </categories>
      <tags>
        <tag>国家机构改革</tag>
        <tag>宪法</tag>
        <tag>国家监察委员会</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github Pages搭建独立域名的个人博客</title>
    <url>/pub/6c2187f/</url>
    <content><![CDATA[<h1 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h1><p><span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20v">阿里云-万网<i class="fa fa-external-link-alt"></i></span> 或其他供应商</p>
<p><a href="../8dcc3c99/">了解更多域名</a></p>
<h1 id="域名解析-xusong-vip-–-gt-xu-song-github-io"><a href="#域名解析-xusong-vip-–-gt-xu-song-github-io" class="headerlink" title="域名解析 (xusong.vip –&gt; xu-song.github.io)"></a>域名解析 (xusong.vip –&gt; xu-song.github.io)</h1><p>域名注册完成后首先需要做域名解析，域名解析就是把域名指向网站所在服务器的IP，让人们通过注册的域名可以访问到网站。</p>
<h2 id="配置DNS解析"><a href="#配置DNS解析" class="headerlink" title="配置DNS解析"></a>配置DNS解析</h2><p>进入你的<span class="exturl" data-url="aHR0cHM6Ly9ob21lLmNvbnNvbGUuYWxpeXVuLmNvbS8=">阿里云DNS解析<i class="fa fa-external-link-alt"></i></span>，选择你想要解析的域名，点击后面的解析。如下图所示：<br><img src="https://user-images.githubusercontent.com/13825126/35460092-a97a685a-031d-11e8-9cc6-1ce1b730a917.PNG" alt="dns"></p>
<blockquote>
<p>We recommend you change this to a CNAME record pointing at [YOUR USERNAME].github.io.<br>– <span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvc2V0dGluZy11cC1hLWN1c3RvbS1zdWJkb21haW4v">Github Help<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>Github建议采用CNAME记录，为什么？</strong></p>
<p>因为IP有可能会变动，导致A记录失效吗？不是，是因为所有Github Pages共用ip，Github后台是根据host定位www目录的。详见<a href="../bfc2ae40/">Github Pages原理</a></p>
<p><strong>阿里云建议采用A记录</strong></p>
<p>因为A记录限制最少，最灵活，多条不会冲突</p>
<p>参考<br><a href="../87420f16/">DNS解析-解析记录</a></p>
<h1 id="重定向-xu-song-github-io-–-gt-xusong-vip"><a href="#重定向-xu-song-github-io-–-gt-xusong-vip" class="headerlink" title="重定向(xu-song.github.io –&gt; xusong.vip)"></a>重定向(xu-song.github.io –&gt; xusong.vip)</h1><h2 id="配置github-pages的custom-domain"><a href="#配置github-pages的custom-domain" class="headerlink" title="配置github pages的custom domain"></a>配置github pages的custom domain</h2><p>进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/13825126/35460275-62ca64a4-031e-11e8-8e43-b15c8b2e1bcc.PNG" alt="default"></p>
<p>这里是对github.io做了重定向，会重定向到所配置的站点。也可以随便填写一个站点，比如<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20s5Lmf5Lya6YeN5a6a5ZCR6L+H5Y67Lw==">www.baidu.com，也会重定向过去<i class="fa fa-external-link-alt"></i></span></p>
<p>细心的同学会发现，配置custom domain后github仓库的根目录多了一个<code>CNAME</code>文件，里面正式刚刚配置的域名地址。</p>
<h3 id="重新deploy，你会发现github-page的domain设置又被改回去了，肿么办？"><a href="#重新deploy，你会发现github-page的domain设置又被改回去了，肿么办？" class="headerlink" title="重新deploy，你会发现github page的domain设置又被改回去了，肿么办？"></a>重新deploy，你会发现github page的domain设置又被改回去了，肿么办？</h3><p>原因是，hexo deploy时会采用<code>git push --force</code>。如果deploy版本没有<code>CNAME</code>文件，则会强制删除3.1中添加的CNAME文件，导致custom domain失效。</p>
<p>因此，最佳的方式是我们手动添加CNAME文件来设置domain。在source目录下新建CNAME文件，内容是<code>xusong.vip</code>。这样每次deploy会自动完成<code>步骤3.1</code>。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>为什么还要再github仓库中设置？dns解析不是已经做了重定向了吗。指向ip:80端口还不够吗？</li>
<li>每个账号的gitpage都是独立的IP吗？github怎么这么多独立外网IP？还是不同账号共用IP？</li>
<li>不同github page共享ip 正因为如此，才需要<code>步骤3</code>的设置。</li>
<li>配置github pages的custom domain，其作用仅仅是<code>xu-song.github.io --&gt; xusong.vip (重定向)</code>吗？</li>
</ul>
<p><a href="../bfc2ae40/">思考题 - 答疑</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>host</category>
        <category>github-pages</category>
      </categories>
      <tags>
        <tag>domain</tag>
        <tag>建站</tag>
        <tag>blog</tag>
        <tag>pages</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器翻译】字符级机器翻译 - BPE</title>
    <url>/pub/a8b3f785/</url>
    <content><![CDATA[<p>2016</p>
<p>Neural Machine Translation of Rare Words with Subword Units</p>
<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>OOV问题</p>
<p>中文也存在OOV问题。比如分词以后</p>
<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>其核心思想是语料库中的高频词作为整体出现的可能性大，因此不对其进行切分，而<strong>对低频词进行切分</strong>，由此增加稀疏词中子词的共现次数。</p>
<p>encoding rare and unknown words as sequences<br>of subword units.</p>
<p>本文讨论了subword的不同分割技巧：</p>
<ul>
<li>直接采用char，信息损失较多</li>
<li>character n-gram models</li>
<li>segmentation based on the byte pair encoding compression algorithm</li>
</ul>
<p>规避大词典。原来都是先把一个数据集中所有单词找出来，把最常用的一些（如90%）做成一个大词典，显然这是冗余的，words和word完全没必要区分。动不动就是50K的单词表，非常耗内存，在像Czech这类语言上更加不行。关键是冗余不优雅。很多研究者都注意到这个问题：</p>
<ul>
<li>subword，就是统计一下符号的频率，如“est”可能是一个符号，能组成“w est,b est”等词，因此称为subword。我觉得还是不够自然，而且效果并不是很好。</li>
<li>Hybrid Word-Character Models，相当于把未知的词训练成RNN小单元，据说华为很早就申请专利了。我表示，不能有word。</li>
<li>Junyoung Chung提出的不需要显式分隔的模型。提出bi-scale的RNN，我觉得很有意思，但我有个疑问，这跟base的RNN有什么区别？论文中也显示，确实差不多。我不知道为什么性能那么好。由于没有训练时间、训练所用内存等更多信息我无法作出判断。</li>
<li>还有Wang Ling提出的，但是完全不是NMT，需要借助IBM model来对齐和分层训练，而且效果不好。</li>
</ul>
<h1 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h1><ul>
<li>2016 年，Rico Sennrich 和 Barry Haddow 等人提出了 Byte Pair Encoding (BPE)的方法，将原有的单词拆解成了更小单元的高频词进行翻译。 BPE 方法在多大程度上解决了未登录词翻译的问题。对未登录词的翻译精准度达到了 45%左右，</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JzZW5ucmljaC9zdWJ3b3JkLW5tdA==">subword-nmt | github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>0.trick</category>
        <category>trick-nlp</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow高层API -- Estimator</title>
    <url>/pub/87ab1289/</url>
    <content><![CDATA[<p><strong>update:</strong> Estimator已经独立出tensorflow成为了一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvZXN0aW1hdG9yLw==">独立的项目<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通常的tensorflow编程流程是</p>
<ol>
<li>构造<code>graph</code>，并得到<code>loss节点</code></li>
<li>构造<code>optimizer</code></li>
<li>Session.run(graph, feed_dict)</li>
</ol>
<p>举个例子</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>流程简洁、清晰。但是…</p>
<p>Estimator是对以上流程的封装。</p>
<ul>
<li>对graph拆分，<ul>
<li><a href="">input_fn</a>，构造<code>input节点</code></li>
<li><a href="">model_fn</a>，构造<code>graph</code>，将<code>loss节点</code>和<code>optimizer</code>封装为<code>EstimatorSpec</code></li>
<li>注意: input_fn与model_fn连在一起，才是完整graph</li>
</ul>
</li>
<li>对session.run进行包装<ul>
<li><a href="(https://github.com/tensorflow/estimator/blob/75d63af79baf124c0b5bff427bd4536a7bd517f7/tensorflow_estimator/python/estimator/estimator.py#L1471)">MonitoredTrainingSession.run</a></li>
</ul>
</li>
<li>optimizer呢？</li>
<li>feeddict呢？用dataset</li>
</ul>
<h2 id="Estimator优势"><a href="#Estimator优势" class="headerlink" title="Estimator优势"></a>Estimator优势</h2><p>Estimator 具有下列优势：</p>
<ul>
<li>您可以在本地主机上或分布式多服务器环境中运行基于 Estimator 的模型，而无需更改模型。此外，您可以在 CPU、GPU 或 TPU 上运行基于 Estimator 的模型，而无需重新编码模型。</li>
<li>Estimator 简化了在模型开发者之间共享实现的过程。</li>
<li>您可以使用高级直观代码开发先进的模型。简言之，采用 Estimator 创建模型通常比采用低阶 TensorFlow API 更简单。</li>
<li>Estimator 本身在 tf.layers 之上构建而成（<span class="exturl" data-url="aHR0cHM6Ly90ZW5zb3JmbG93Lmdvb2dsZS5jbi9hcGlfZG9jcy9weXRob24vdGYvbGF5ZXJzP2hsPXpoLUNOJUVGJUJDJTg5JUVGJUJDJThDJUU1JThGJUFGJUU0JUJCJUE1JUU3JUFFJTgwJUU1JThDJTk2JUU4JTg3JUFBJUU1JUFFJTlBJUU0JUI5JTg5JUU4JUJGJTg3JUU3JUE4JThCJUUzJTgwJTgy">https://tensorflow.google.cn/api_docs/python/tf/layers?hl=zh-CN），可以简化自定义过程。<i class="fa fa-external-link-alt"></i></span></li>
<li>Estimator 会为您构建图。</li>
<li>Estimator 提供安全的分布式训练循环，可以控制如何以及何时：<ul>
<li>构建图</li>
<li>初始化变量</li>
<li>开始排队</li>
<li>处理异常</li>
<li>创建检查点文件并从故障中恢复</li>
<li>保存 TensorBoard 的摘要</li>
</ul>
</li>
</ul>
<p>使用 Estimator 编写应用时，您必须将数据输入管道从模型中分离出来。这种分离简化了不同数据集的实验流程。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><ol>
<li>定义model_fn，并实例化Estimator</li>
<li>定义input_fn</li>
<li>train_data、train_step</li>
<li>eval_data、eval_step</li>
</ol>
<blockquote>
<p>另外还可借助Hparams的封装传参</p>
</blockquote>
<h2 id="Estimator"><a href="#Estimator" class="headerlink" title="Estimator"></a>Estimator</h2><p><code>tf.estimator</code>是TensorFlow的高层API，是对底层API对以下方法进行了封装。</p>
<ul>
<li><strong>training</strong>: 对应 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9tb2RlbF9mbi5weSNMNTA=">ModeKeys<i class="fa fa-external-link-alt"></i></span>.TRAIN</li>
<li><strong>evaluation</strong>: ModeKeys.EVAL</li>
<li><strong>predict</strong>: ModeKeys.PREDICT</li>
<li>export for serving</li>
</ul>
<!--
predict, inference差不多一个意思，一般用于serving
eval意思则不同，用于模型效果的整体
-->



<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>有两种使用方式，都需要依赖<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9lc3RpbWF0b3IucHk=">tf.estimator.Estimator<i class="fa fa-external-link-alt"></i></span>这个类。</p>
<h3 id="预创建的-Estimator"><a href="#预创建的-Estimator" class="headerlink" title="预创建的 Estimator"></a>预创建的 Estimator</h3><!-- pre-made -->

<p>基于Estimator，官方预定义了一些常用的模型，比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9jYW5uZWQvZG5uLnB5I0wzMTk=">DNNClassifier<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9jYW5uZWQvZG5uLnB5I0w0OTQ=">DNNRegressor<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9jYW5uZWQvbGluZWFyLnB5I0wyMTk=">LinearClassifier<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9jYW5uZWQvYm9vc3RlZF90cmVlcy5weSNMMTI4NQ==">BoostedTreesClassifier<i class="fa fa-external-link-alt"></i></span>等。</p>
<p>以下是一个完整实例: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvbW9kZWxzL2Jsb2IvdjEuMTEvc2FtcGxlcy9jb3JlL2dldF9zdGFydGVkL3ByZW1hZGVfZXN0aW1hdG9yLnB5">利用DNNClassifier对花萼分类<i class="fa fa-external-link-alt"></i></span>，其核心代码就几行，充分展现了Estimator封装的<strong>简洁性</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">classifier = tf.estimator.DNNClassifier(features, labels, hidden_units, n_classes)  <span class="comment"># 实例化estimator</span></span><br><span class="line">classifier.train(input_fn_train, steps)  <span class="comment"># 送入训练数据，开始training</span></span><br><span class="line">eval_result = classifier.evaluate(input_fn_test)  <span class="comment"># 送入test data</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方这几个model也为我们使用Estimator提供了例子</p>
</blockquote>
<h3 id="自定义-Estimator"><a href="#自定义-Estimator" class="headerlink" title="自定义 Estimator"></a>自定义 Estimator</h3><!-- custom -->

<p>官方定义的模型不能够满足我们的需求，那就需要基于Estimator自定义模型</p>
<p>无论是pre-made，还是custom，其核心都是<code>model function</code>。<br>在该方法中需要构建graph，包含training, evaluation, and prediction。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>Estimator的封装，基本思想是让我们只需关心<code>模型</code>和<code>数据</code>，屏蔽硬件(是吗?)。</p>
<p>要实现这种封装，一种思路是<strong>抽象类(接口) + 继承 + 覆盖</strong>，另一种是<strong>完整类 + 传函数</strong>。Estimator显然更钟情于第二种方式(why?)。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9lc3RpbWF0b3IucHkjTDIyNg==">model_fn<i class="fa fa-external-link-alt"></i></span> 定义模型，即构建graph，主要要包含TRAIN、EVAL、PREDICT对应的op。</li>
</ul>
<h2 id="自己定义model-fn"><a href="#自己定义model-fn" class="headerlink" title="自己定义model_fn"></a>自己定义model_fn</h2><h2 id="model-fn传给Estimator"><a href="#model-fn传给Estimator" class="headerlink" title="model_fn传给Estimator"></a>model_fn传给Estimator</h2><p><code>model_fn</code>必须要以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9lc3RpbWF0b3IucHkjTDExNw==">Estimator构造函数的方式传递<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>pre-made</strong></p>
<p>DNNClassifier的实现</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DNNClassifier</span>(<span class="params">estimator.Estimator</span>):</span> <span class="comment"># 定义Estimator的封装，没必要</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">..  <span class="comment"># 重写init方法，仅仅是</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">def</span> _model_fn(<span class="params">.. <span class="comment"># 定义model_fn方法 (required)</span></span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="function">  <span class="comment"># 传递model_fn (关键)</span></span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="function">  <span class="built_in">super</span>(<span class="params">DNNClassifier, self</span>).__init__(<span class="params">model_fn=_model_fn,..</span>)</span></span></span></span><br></pre></td></tr></table></figure>



<p>这仅仅是对<code>Estimator</code>的一个封装，对外直接用<code>DNNClassifier</code>而无视<code>Estimator</code>的存在。</p>
<p><strong>自己的程序，没必要这样封装</strong>，屏蔽掉<code>Estimator</code>而定义一个新类，会让其他程序员看的摸不着头脑。</p>
<p>不建议采用继承的方式，还是开放<code>Estimator</code>比较好吧，即后面的<code>custom</code>方式</p>
<p><strong>custom</strong></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>Estimator对底层隔离，兼容CPU、GPU、TPU、多卡、多机多卡 <strong>666</strong></li>
<li>其他几个优点没看懂</li>
</ul>
<h1 id="Estimator-1"><a href="#Estimator-1" class="headerlink" title="Estimator"></a>Estimator</h1><img src="https://www.tensorflow.org/images/tensorflow_programming_environment.png">

<p>estimator与keras的关系，</p>
<h2 id="Datasets-for-Estimators-input-fn"><a href="#Datasets-for-Estimators-input-fn" class="headerlink" title="Datasets for Estimators - input_fn"></a>Datasets for Estimators - input_fn</h2><p>注意，上面定义的<code>model_fn</code>并非完整graph，因为其中并未构造input节点，而是input作为参数。</p>
<p>因此我们要定义<code>input_fn</code>，并构造input节点。然后传入<code>model_fn</code>，从而构造完整graph。</p>
<p>给Estimator传入数据，通常为train何eval分别定义一个input_fn函数，该函数有三个参数：</p>
<ul>
<li><strong>features</strong>：字典或<span class="exturl" data-url="aHR0cHM6Ly9wYW5kYXMucHlkYXRhLm9yZy9wYW5kYXMtZG9jcy9zdGFibGUvZ2VuZXJhdGVkL3BhbmRhcy5EYXRhRnJhbWUuaHRtbA==">DataFrame<i class="fa fa-external-link-alt"></i></span>类型，包含输入数据的特征，与Feature Columns对应</li>
<li><strong>labels</strong>：标签数组</li>
<li><strong>batch_size</strong>：batch size</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dataset = dataset.shuffle(<span class="number">1000</span>).repeat().batch(batch_size)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>repeat</strong> 要迭代数据集多个周期,例如，要创建一个将其输入重复 10 个周期的数据集repeat(10),无参表示无限次地重复输入。<br></li>
<li><strong>shuffle</strong> 随机重排输入数据，维持一个固定大小的缓冲区，并从该缓冲区统一地随机选择下一个元素。<br></li>
<li><strong>batch</strong> 每次取多少个数据</li>
</ul>
<h1 id="TrainSpec、EvalSpec"><a href="#TrainSpec、EvalSpec" class="headerlink" title="TrainSpec、EvalSpec"></a>TrainSpec、EvalSpec</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvZXN0aW1hdG9yL2Jsb2IvbWFzdGVyL3RlbnNvcmZsb3dfZXN0aW1hdG9yL3B5dGhvbi9lc3RpbWF0b3IvdHJhaW5pbmcucHkjTDEyMA==">TrainSpec<i class="fa fa-external-link-alt"></i></span>是对以下的封装</p>
<ul>
<li><code>input_fn</code>:</li>
<li><code>max_steps</code>:</li>
<li><code>hooks</code>:</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="run-config"><a href="#run-config" class="headerlink" title="run_config"></a>run_config</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvZXN0aW1hdG9yL2Jsb2IvbWFzdGVyL3RlbnNvcmZsb3dfZXN0aW1hdG9yL3B5dGhvbi9lc3RpbWF0b3IvcnVuX2NvbmZpZy5weSNMMzIw">tf.estimator.RunConfig<i class="fa fa-external-link-alt"></i></span><br>原</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L2NvbnRyaWIvdHJhaW5pbmcvcHl0aG9uL3RyYWluaW5nL2hwYXJhbS5weSNMMzcw">tf.training.HParams<i class="fa fa-external-link-alt"></i></span></p>
<p>原<code>tf.contrib.training.HParams</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">             model_dir=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             tf_random_seed=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             save_summary_steps=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             save_checkpoints_steps=_USE_DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">             save_checkpoints_secs=_USE_DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">             session_config=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             keep_checkpoint_max=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             keep_checkpoint_every_n_hours=<span class="number">10000</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             log_step_count_steps=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             train_distribute=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             device_fn=<span class="literal">None</span></span></span></span><br><span class="line"><span class="params"><span class="function">             ...</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="run-config-VS-hparams"><a href="#run-config-VS-hparams" class="headerlink" title="run_config VS hparams"></a>run_config VS hparams</h3><p>run_config 是个模板，session run需要用到的参数。</p>
<p>hparams是</p>
<h1 id="吐槽环节"><a href="#吐槽环节" class="headerlink" title="吐槽环节"></a>吐槽环节</h1><p>tensorflow跑一个程序，有n种方式。看了后想骂人。</p>
<p>传统方式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Custom training</span></span><br><span class="line"><span class="comment"># https://www.tensorflow.org/tutorials/eager/custom_training</span></span><br></pre></td></tr></table></figure>



<p>tensorflow keras</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tensorflow keras</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line"></span><br><span class="line">(x_train, y_train),(x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">  tf.keras.layers.Flatten(),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">512</span>, activation=tf.nn.relu),</span><br><span class="line">  tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">10</span>, activation=tf.nn.softmax)</span><br><span class="line">])</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>)</span><br><span class="line">model.evaluate(x_test, y_test)</span><br></pre></td></tr></table></figure>


<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol>
<li>stimator节省了哪些操作？<ul>
<li>与硬件底层的隔离，免去了写多机多卡的code。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9lc3RpbWF0b3IucHkjTDEyMDM=">源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>estimator能否与low-level API交叉使用？</li>
<li>Estimator中怎样打log？</li>
</ol>
<ul>
<li>Estimator封装了很多logging.info，一般不允许自己插入其他log吧</li>
</ul>
<ol>
<li>Estimator如何做多卡？多机并行？如何分配worker和ps？怎样的并行策略？ <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci9lc3RpbWF0b3IucHkjTDEyNDM=">源码<i class="fa fa-external-link-alt"></i></span></li>
<li>Estimator屏蔽硬件吗？在model定义时是否可以设置device？</li>
</ol>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvcHJlbWFkZV9lc3RpbWF0b3Jz">https://www.tensorflow.org/guide/premade_estimators<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveWdqM3BzWXpRU0NtZjg0OEtoRkU0dw==">Estimator介绍 | Tensorflow微信公众号<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL3IxLjEyL3RlbnNvcmZsb3cvcHl0aG9uL2VzdGltYXRvci8=">Estimator源码<i class="fa fa-external-link-alt"></i></span></li>
<li>实例:</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvbW9kZWxzL2Jsb2IvcjEuMTEvc2FtcGxlcy9jb3JlL2dldF9zdGFydGVkL3ByZW1hZGVfZXN0aW1hdG9yLnB5">pre-made estimator实例<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvbW9kZWxzL2Jsb2IvcjEuMTEvc2FtcGxlcy9jb3JlL2dldF9zdGFydGVkL2N1c3RvbV9lc3RpbWF0b3IucHk=">custom estimator实例<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>toolbox</category>
        <category>tensorflow</category>
        <category>high-level-api</category>
        <category>estimator</category>
      </categories>
  </entry>
  <entry>
    <title>【数据分析篇】SNLI数据集</title>
    <url>/pub/a1c27ad7/</url>
    <content><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css" />
<p>Stanford自然语言推理(SNLI)数据集，全称The Stanford Natural Language Inference (SNLI) Corpus。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ubHAuc3RhbmZvcmQuZWR1L3Byb2plY3RzL3NubGkv">https://nlp.stanford.edu/projects/snli/<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SNLI1.0包含570，000的人工手写英文句子对。<br>针对 <code>推理前提</code>(premise)与<code>推理假设</code>(hypothesis)之间是否存在逻辑关系，人工标注了以下三种标签：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Entailment_(linguistics)"><strong>entailment</strong></a> 蕴含、推理 \(p \Rightarrow h \)</li>
<li><a href="https://en.wikipedia.org/wiki/Contradiction"><strong>contradiction</strong></a> 矛盾、对立   \(p \bot h \)</li>
<li><strong>neutral</strong> 中立、无关 \(p \nLeftrightarrow h \)</li>
</ul>
<p>用于自然语言推理 (Natural language inference,NLI), 也称为 (recognizing textual entailment, RTE)。</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><table>
<thead>
<tr>
<th>Text</th>
<th>Judgments</th>
<th>Hypothesis</th>
</tr>
</thead>
<tbody><tr>
<td>A man inspects the uniform of a figure in some East Asian country.</td>
<td>contradiction<br>C C C C C</td>
<td>The man is sleeping</td>
</tr>
<tr>
<td>An older and younger man smiling.</td>
<td>neutral<br>N N E N N</td>
<td>Two men are smiling and laughing at the cats playing on the floor.</td>
</tr>
<tr>
<td>A black race car starts up in front of a crowd of people.</td>
<td>contradiction<br>C C C C C</td>
<td>A man is driving down a lonely road.</td>
</tr>
<tr>
<td>A soccer game with multiple males playing.</td>
<td>entailment<br>E E E E E</td>
<td>Some men are playing a sport.</td>
</tr>
<tr>
<td>A smiling costumed woman is holding an umbrella.</td>
<td>neutral<br>N N E C N</td>
<td>A happy woman in a fairy costume holds an umbrella.</td>
</tr>
</tbody></table>
<p><code>snli_1.0/snli_1.0_train.jsonl</code>的第一行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;annotator_labels&quot;</span>:[</span><br><span class="line">      <span class="string">&quot;neutral&quot;</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;captionID&quot;</span>:<span class="string">&quot;3416050480.jpg#4&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;gold_label&quot;</span>:<span class="string">&quot;neutral&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;pairID&quot;</span>:<span class="string">&quot;3416050480.jpg#4r1n&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence1&quot;</span>:<span class="string">&quot;A person on a horse jumps over a broken down airplane.&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence1_binary_parse&quot;</span>:<span class="string">&quot;( ( ( A person ) ( on ( a horse ) ) ) ( ( jumps ( over ( a ( broken ( down airplane ) ) ) ) ) . ) )&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence1_parse&quot;</span>:<span class="string">&quot;(ROOT (S (NP (NP (DT A) (NN person)) (PP (IN on) (NP (DT a) (NN horse)))) (VP (VBZ jumps) (PP (IN over) (NP (DT a) (JJ broken) (JJ down) (NN airplane)))) (. .)))&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence2&quot;</span>:<span class="string">&quot;A person is training his horse for a competition.&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence2_binary_parse&quot;</span>:<span class="string">&quot;( ( A person ) ( ( is ( ( training ( his horse ) ) ( for ( a competition ) ) ) ) . ) )&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sentence2_parse&quot;</span>:<span class="string">&quot;(ROOT (S (NP (DT A) (NN person)) (VP (VBZ is) (VP (VBG training) (NP (PRP$ his) (NN horse)) (PP (IN for) (NP (DT a) (NN competition))))) (. .)))&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>为什么有好几个judgement？</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>最终标签是综合了5个专家的意见，根据少数服从多数的原则得到的。</pre> </div> </div> </div>  </div> </div>  </div></div>

<p>还额外提供了句子的<strong>两种解析树</strong>表示。</p>
<p>自然语言推理（NLI）数据在构造的过程中存在一系列的人工模式，这种模式的直接后果是模型可以在不需要知道推理前提（premise）的条件下就可以以 67%的准确率判断推理假设（hypothesis）是否是蕴含（entailment）中立（neural）或对立（contradiction）</p>
<h1 id="数据统计-amp-分析"><a href="#数据统计-amp-分析" class="headerlink" title="数据统计 &amp;分析"></a>数据统计 &amp;分析</h1><table>
<thead>
<tr>
<th>premise</th>
<th>hypothesis</th>
<th>label</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>a person on a horse jumps over a broken down airplane.</td>
<td>a person is <strong>training</strong> his horse for a <strong>competition</strong>.</td>
<td>neutral</td>
<td>原句没有体现training和competition</td>
</tr>
<tr>
<td>a person on a horse <strong>jumps</strong> over a broken down airplane.</td>
<td>a person is <strong>at a diner</strong>, ordering an omelette.</td>
<td>contradiction</td>
<td>这种关系，是否要借助外界数据？</td>
</tr>
<tr>
<td>a person on a horse jumps over a broken down airplane.</td>
<td>a person is <strong>outdoors</strong>, on a horse.</td>
<td>entailment</td>
<td></td>
</tr>
<tr>
<td>children smiling and waving at camera</td>
<td>they are smiling at their <strong>parents</strong></td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>children smiling and waving at camera</td>
<td><strong>there are</strong> children present</td>
<td>entailment</td>
<td>there are属于stop word，最好。但是又要和there are not相反</td>
</tr>
<tr>
<td>children <strong>smiling</strong> and waving at camera</td>
<td>the kids are <strong>frowning</strong></td>
<td>contradiction</td>
<td></td>
</tr>
<tr>
<td>a boy is jumping <strong>on</strong> skateboard in the <strong>middle of a red bridge</strong>.</td>
<td>the boy skates <strong>down</strong> the sidewalk.</td>
<td>contradiction</td>
<td></td>
</tr>
<tr>
<td>a boy is jumping on skateboard in the middle of a red bridge.</td>
<td>the boy does a skateboarding trick.</td>
<td>entailment</td>
<td></td>
</tr>
<tr>
<td>a boy is jumping on skateboard in the middle of a red bridge.</td>
<td>the boy is wearing safety equipment.</td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td>
<td>an older man drinks his juice as he waits for his daughter to get off work.</td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td>
<td>a boy flips a burger.</td>
<td>contradiction</td>
<td></td>
</tr>
<tr>
<td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td>
<td>an elderly man sits in a small shop.</td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>two blond women are hugging one another.</td>
<td>some women are hugging on vacation.</td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>two blond women are hugging one another.</td>
<td>the women are sleeping.</td>
<td>contradiction</td>
<td></td>
</tr>
<tr>
<td>two blond women are hugging one another.</td>
<td>there are women showing affection.</td>
<td>entailment</td>
<td></td>
</tr>
<tr>
<td>a few people in a restaurant setting, one of them is drinking orange juice.</td>
<td>the people are eating omelettes.</td>
<td>neutral</td>
<td></td>
</tr>
<tr>
<td>a few people in a restaurant setting, one of them is drinking orange juice.</td>
<td>the people are sitting at desks in school.</td>
<td>contradiction</td>
<td></td>
</tr>
<tr>
<td>a few people in a restaurant setting, one of them is drinking orange juice.</td>
<td>the diners are at a restaurant.</td>
<td>entailment</td>
<td></td>
</tr>
<tr>
<td>an older man is drinking orange juice at a restaurant.</td>
<td>a man is drinking juice.</td>
<td>entailment</td>
<td></td>
</tr>
<tr>
<td>an older man is drinking orange juice at a restaurant.</td>
<td>two women are at a restaurant drinking wine.</td>
<td>contradiction</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>premis比较具体，hyposies 简洁，抽象(比如male抽象成man，苹果抽象成苹果)</li>
<li>contradiction通常有反义词，比如 up down</li>
</ul>
<h1 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h1>]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>entailment</category>
        <category>dataset</category>
      </categories>
      <tags>
        <tag>dataset</tag>
        <tag>数据分析</tag>
        <tag>entailment</tag>
        <tag>自然语言推理</tag>
        <tag>SNLI</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR</title>
    <url>/pub/dab63ff1/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMTkxNzI3">OCR文字识别用的是什么算法？–知乎<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>General OCR一般包含:</p>
<ol>
<li>detection–&gt;找到包含文字的区域(proposal);</li>
<li>接着利用radon hough变换 等方法 进行文本校正。</li>
<li>通过投影直方图分割出单行的文本的图片。</li>
<li>classification–&gt;识别区域中的文字。</li>
</ol>
<p>framework是: CNN + LSTM + CTC。这个framework加上residue network + stn可以把通用的数据集刷的非常高。</p>
<h2 id="detection"><a href="#detection" class="headerlink" title="detection"></a>detection</h2><p>先说detection models, 近两年比较热门的object detection model有 faster-rcnn(<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE1MDYuMDE0OTcucGRm">https://arxiv.org/pdf/1506.01497.pdf<i class="fa fa-external-link-alt"></i></span>) 和 yolo(<span class="exturl" data-url="aHR0cDovL3BqcmVkZGllLmNvbS9tZWRpYS9maWxlcy9wYXBlcnMveW9sby5wZGY=">http://pjreddie.com/media/files/papers/yolo.pdf<i class="fa fa-external-link-alt"></i></span>), 两个模型都是基于CNN给出proposed regions 同时对object region进行分类。 其中yolo比faster-rcnn的速度更快，但是在accuracy上有些损失。</p>
<p>比较著名的是Ian goodfellow在13年提出的multi-digit number classification</p>
<p>另一类比较常用的方法是RNN/LSTM/GRU + CTC,</p>
<h1 id="开源工具-amp-代码"><a href="#开源工具-amp-代码" class="headerlink" title="开源工具&amp;代码"></a>开源工具&amp;代码</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdDRqYXZhL2p0ZXNzZXJhY3Q=">https://github.com/tesseract4java/jtesseract<i class="fa fa-external-link-alt"></i></span></p>
<p>开源包: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdC1vY3IvdGVzc2VyYWN0">tesseract 很赞<i class="fa fa-external-link-alt"></i></span></p>
<p>最好的模型，竟然是lstm？<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdC1vY3IvdGVzc2RhdGFfYmVzdA==">https://github.com/tesseract-ocr/tessdata_best<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>app</category>
        <category>OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>图像风格迁移-Image Style Transfer</title>
    <url>/pub/9fa270bc/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>图片1中的内容 +  图片2中的风格 = 新图片</p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol>
<li>怎样提取出content信息？</li>
<li>怎样提取出style信息？</li>
<li>怎样融合content和style？</li>
</ol>
<p>大佬们围绕这几个点，绞尽脑汁，各显神通。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h1 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h1><p>我们先从简单问题的入手，问题1看上去好像比较简单。</p>
<h2 id="怎样提取出content信息？"><a href="#怎样提取出content信息？" class="headerlink" title="怎样提取出content信息？"></a>怎样提取出content信息？</h2><h2 id="怎样提取出style信息？"><a href="#怎样提取出style信息？" class="headerlink" title="怎样提取出style信息？"></a>怎样提取出style信息？</h2><p>这几年CNN挺火，据说CNN的不同层能学习到不同级别的特征。是不是也能学习到style信息呢？带着这个疑问，我们先来看看CNN学到的是什么。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kaXN0aWxsLnB1Yi8yMDE3L2ZlYXR1cmUtdmlzdWFsaXphdGlvbi8=">https://distill.pub/2017/feature-visualization/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>网络的<strong>高层特征一般是关于输入图像的物体和布局等信息</strong>，<strong>低层特征一般表达输入图像的像素信息</strong>。也就是说在提取content特征时，不同层的表达效果是不一样的，本文在后面提取图像的content特征时采用高层特征。</p>
<h1 id="参考文献-发展史"><a href="#参考文献-发展史" class="headerlink" title="参考文献 | 发展史"></a>参考文献 | 发展史</h1><p>2015  A Neural Algorithm of Artistic Style<br>2016年的CVPR  Image Style Transfer Using Convolutional Neural Networks</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>app</category>
        <category>style-transfer</category>
      </categories>
  </entry>
  <entry>
    <title>物体识别 - 综述</title>
    <url>/pub/44a82bb1/</url>
    <content><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li>detection: find all objects (bounding box)</li>
<li>classification: classify objects         </li>
<li>recognition: whether one is object          </li>
<li>segmentation: cut all objects (pixel wise)         </li>
<li>localization: find certain object (bounding box)</li>
</ul>
<!--
目标分割、物体分割、语义分割 区别？
-->


<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><img title="物体识别的主要任务" src="/images/raw/NN - object recognition - task.png">

<p>广义的识别（Object Recognition/visual recognition），包括</p>
<ol>
<li>图像分类/识别: 识别图片里是猫是狗  <!-- Image Classification --></li>
<li>物体定位/检测: 不仅可以告诉你分类，还可以告诉你目标物体的坐标(框)</li>
<li>目标识别</li>
<li>语义分割: 不仅需要把物体检测出来， 还要把它从图片中扣出来</li>
<li>实体分割</li>
<li>关键点检测</li>
</ol>
<p>其他任务：以图搜图、图像生成、 图像风格迁移</p>
<!--
目标跟踪（目标分割强化版）
人类视觉（目标跟踪强化版），从视频或者真实世界中认识到有哪些物体，物体真实轮廓，物体位置，物体种类。
目标分割、及物体分割
目标识别、即物体识别
目标检测（Object Detection）和目标跟踪  这几个放哪？
-->

<p>再细分</p>
<ul>
<li>Scene categorization</li>
<li>Image-level annotation: are there people?</li>
</ul>
<p>主要模型发展历史：</p>
<p>&lt;img “模型进化史，红色表示计算机视觉的基础模型，绿色表示目标检测的模型” src=”/images/raw/NN - object recognition - models.png”&gt;</p>
<p>&lt;img “目标检测模型汇总” src=”/images/raw/NN - object detection - models.jpg”&gt;</p>
<p>从最初2013年提出的R-CNN、OverFeat，到后面的Fast/Faster R-CNN，SSD，YOLO系列，再到2018年最近的Pelee。短短不到五年时间，基于深度学习的目标检测技术，在网络结构上，从two stage到one stage，从bottom-up only到Top-Down，从single scale network到feature pyramid network，从面向PC端到面向手机端，都涌现出许多好的算法技术，这些算法在开放目标检测数据集上的检测效果和性能都很出色。</p>
<p>物体检测发展主要集中在两个方向：</p>
<p><strong>two stage算法</strong></p>
<ul>
<li>R-CNN系列</li>
<li>FPN 最好的two-stage</li>
</ul>
<p><strong>one stage算法</strong></p>
<ul>
<li>YOLO</li>
<li>SSD</li>
<li>RetinaNet 是最好的one stage</li>
</ul>
<p>两者的主要区别在于two stage算法需要先生成proposal（一个有可能包含待检物体的预选框），然后进行细粒度的物体检测。而one stage算法会直接在网络中提取特征来预测物体分类和位置。</p>
<h2 id="two-stage"><a href="#two-stage" class="headerlink" title="two stage"></a>two stage</h2><p>Faster R-CNN网络包括两个步骤：</p>
<ol>
<li>使用RPN(region proposal network)提取proposal信息</li>
<li>使用R-CNN对候选框位置进行预测和物体类别识别。</li>
<li>Faster R‑CNN是首个利用CNN来完成proposals的预测的，之后的很多目标检测网络都是借助了<br>Faster R‑CNN的思想</li>
</ol>
<h2 id="one-stage"><a href="#one-stage" class="headerlink" title="one stage"></a>one stage</h2><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05pa2FzYTE4ODkvSGlzdG9yeU9iamVjdFJlY29nbml0aW9u">History of Object Recognition | github<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDA0Nzc2MA==">基于深度学习的目标检测算法综述 | 知乎专栏 - 美图<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>app</category>
        <category>Object Recognition</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】- Thread</title>
    <url>/pub/851507b3/</url>
    <content><![CDATA[<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？"><a href="#Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？" class="headerlink" title="Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？"></a>Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？</h3><p>java线程是映射到操作系统的内核线程上的</p>
<h2 id="跟踪Thread-start"><a href="#跟踪Thread-start" class="headerlink" title="跟踪Thread.start()"></a>跟踪Thread.start()</h2><p>java</p>
<pre><code>// Thread.java
public synchronized void start() &#123;
    group.add(this);
    ...
    start0();
    ...
&#125;

private native void start0();
</code></pre>
<p>native方法hotspot源码</p>
<pre><code>// openjdk\jdk\src\share\native\java\lang\Thread.c
static JNINativeMethod methods[] = &#123;
    &#123;&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread&#125;,
   ...
&#125;;


// openjdk\hotspot\src\share\vm\prims\jvm.cpp
JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
  JVMWrapper(&quot;JVM_StartThread&quot;);
  JavaThread *native_thread = NULL;
  ...
  native_thread = new JavaThread(&amp;thread_entry, sz); // 重点
  ...
  Thread::start(native_thread); // 重点
JVM_END



// openjdk\hotspot\src\share\vm\runtime\thread.cpp
JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :
  Thread() &#123;
   ...
   os::create_thread(this, thr_type, stack_sz);
   // 可以看出java线程是映射到操作系统的内核线程上的
   ...
&#125;

void Thread::start(Thread* thread) &#123;
    ...
    os::start_thread(thread);
  &#125;
&#125;


// 在hotspot\src\os目录下可以看到windows, linux, solaris和posix的实现，先检查linux\vm\os_linux.cpp

bool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) &#123;
  ...
  int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) java_start, thread);  // linux中调用的pthread，POSIX中的api
  ...
&#125;
</code></pre>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】Atomic</title>
    <url>/pub/89c32f49/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>原子量和普通变量相比，主要体现在读写的线程安全上。对原子量的是原子的(比如多线程下的共享变量i++就不是原子的)，由CAS操作保证原子性。对原子量的读可以读到最新值，由volatile关键字来保证可见性。</li>
<li>原子量多用于数据统计(如接口调用次数)、一些序列生成(多线程环境下)以及一些同步数据结构中</li>
</ul>
<ul>
<li>atomic是基于底层硬件的CAS做的</li>
<li>区别于HashTable等线程安全类，这里面没有锁</li>
</ul>
<h2 id="以AtomicLong为例"><a href="#以AtomicLong为例" class="headerlink" title="以AtomicLong为例"></a>以AtomicLong为例</h2><h3 id="java源码"><a href="#java源码" class="headerlink" title="java源码"></a>java源码</h3><pre><code>// 1. from AtomicLong.java (rt.jar:java.util.concurrent.atomic.AtomicLong)
public final boolean compareAndSet(long expect, long update) &#123;
    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
&#125;

// 2. from Unsafe.java (rt.jar:sun.misc.Unsafe)
public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x);
</code></pre>
<h3 id="native方法的C-实现"><a href="#native方法的C-实现" class="headerlink" title="native方法的C++实现"></a>native方法的C++实现</h3><pre><code>// 3. from hotspot/src/share/vm/prims/unsafe.cpp (openjdk)
static JNINativeMethod methods[] = &#123;
&#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,
...
&#125;
...
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapLong&quot;);
  Handle p (THREAD, JNIHandles::resolve(obj));
  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));
  if (VM_Version::supports_cx8())  
    return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;  // 主要实现
  else &#123; // 如果不支持cx8，那么就需要用到ObjectLocker锁
    jboolean success = false;
    ObjectLocker ol(p, THREAD);
    if (*addr == e) &#123; *addr = x; success = true; &#125;
    return success;
  &#125;
UNSAFE_END
</code></pre>
<p>It is a JNI wrapper for the CAS API, with memory barriers for IA64 architecture.</p>
<p>It is an atomic operation which means no other processor can change the value of dest whilst the operation executes.</p>
<p><strong>Atomic::cmpxchg(x, addr, e)</strong><br>CAS需要三个参数 address,old_value, new_value.<br>modern CPU is required for this process.</p>
<p>CAS has its weakness as ABA problem, so memory barrier is necessary here to ensure the CAS is still correct in multithread environment.</p>
<ul>
<li>native的实现</li>
</ul>
<h3 id="Atomic-cmpxchg方法的分支"><a href="#Atomic-cmpxchg方法的分支" class="headerlink" title="Atomic::cmpxchg方法的分支"></a>Atomic::cmpxchg方法的分支</h3><p>依赖于OS &amp; CPU &amp; 32bit/64bit. 所以JVM在这里产生了分支</p>
<pre><code>// 4. from  hotspot/src/share/vm/runtime/atomic.cpp
# include &quot;atomic_windows_x86.inline.hpp&quot;
# include &quot;atomic_linux_x86.inline.hpp&quot;     // x86生产商有Intel, AMD, IBM等
# include &quot;atomic_solaris_sparc.inline.hpp&quot; // Solaris系统，sparc处理器(都是sun的)
# include &quot;atomic_linux_sparc.inline.hpp&quot;   // linux系统，sparc处理器
...
</code></pre>
<p>linux_x86中：</p>
<pre><code>// from openjdk/hotspot/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp
#ifdef AMD64

inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) &#123;
  bool mp = os::is_MP();
  __asm__ __volatile__ (LOCK_IF_MP(%4) &quot;cmpxchgq %1,(%3)&quot;
                        : &quot;=a&quot; (exchange_value)
                        : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                        : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
&#125;

#else // !AMD64
inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) &#123;
  return _Atomic_cmpxchg_long(exchange_value, dest, compare_value, os::is_MP());
&#125;
#endif // AMD64
</code></pre>
<p>windows_x86中</p>
<pre><code>// from openjdk\hotspot\src\os_cpu\windows_x86\vm
#ifdef AMD64
inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) &#123;
  return (*os::atomic_cmpxchg_long_func)(exchange_value, dest, compare_value);
&#125;

#else // !AMD64
inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) &#123;
  int mp = os::is_MP();
  jint ex_lo  = (jint)exchange_value;
  jint ex_hi  = *( ((jint*)&amp;exchange_value) + 1 );
  jint cmp_lo = (jint)compare_value;
  jint cmp_hi = *( ((jint*)&amp;compare_value) + 1 );
  __asm &#123;
    push ebx
    push edi
    mov eax, cmp_lo
    mov edx, cmp_hi
    mov edi, dest
    mov ebx, ex_lo
    mov ecx, ex_hi
    LOCK_IF_MP(mp)
    cmpxchg8b qword ptr [edi]
    pop edi
    pop ebx
  &#125;
&#125;
#endif // AMD64
</code></pre>
<p>其他平台…</p>
<p>可以看出，当CPU支持时，最终确实是直接用cmpxchg相关指令实现的。</p>
<h3 id="ObjectLocker锁"><a href="#ObjectLocker锁" class="headerlink" title="ObjectLocker锁"></a>ObjectLocker锁</h3><p>这是synchronized锁吗？</p>
<h2 id="Why-would-you-use-a-CAS-function"><a href="#Why-would-you-use-a-CAS-function" class="headerlink" title="Why would you use a CAS function?"></a>Why would you use a CAS function?</h2><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p>Solaris：原是太阳微系统公司研制的类Unix操作系统，在Sun公司被Oracle并购后，称作Oracle Solaris。早期的Solaris主要用于Sun工作站上</p>
</li>
<li><p>saparc: sun公司开发的处理器，用于Sun工作站等上。Solaris在SPARC上拥有强大的处理能力和硬件支持(相对Intel x86平台)</p>
</li>
<li><p>cx8:</p>
</li>
<li><p>ObjectLocker:</p>
</li>
</ul>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li><p>i = i + 1不是原子操作吗？为什么AtomicLong.incrementAndGet()的实现要这么复杂?直接用i = i + 1实现不行吗？(见《java并发编程实战》18页)</p>
</li>
<li><p>#include &lt;atomic&gt; C++自带的实现与atomic_linux_x86.inline.hpp有什么区别？应该前者是后者的进一步封装吧？</p>
</li>
<li><p>这个native方法的实现为什么在JVM层而不在jdk层？JVM是用来run byte code的。这里的JVM代码是用来run哪个byte code呢？</p>
</li>
<li><p>这里生成的byte code是啥样的？</p>
</li>
</ul>
<h2 id="再挖掘"><a href="#再挖掘" class="headerlink" title="再挖掘"></a>再挖掘</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>(<span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MTY5OTYxL2Nhbi1hbnlvbmUtaW50ZXJwcmV0LXRoaXMtYy1jb2RlLWZyb20tb3BlbmpkazYtaW50by1wbGFpbi1lbmdsaXNo">http://stackoverflow.com/questions/7169961/can-anyone-interpret-this-c-code-from-openjdk6-into-plain-english<i class="fa fa-external-link-alt"></i></span>)</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
      </categories>
  </entry>
  <entry>
    <title>python collection</title>
    <url>/pub/ed599e37/</url>
    <content><![CDATA[<blockquote>
<p>collections — High-performance container datatypes¶</p>
</blockquote>
<p>collections是Python内建的一个集合模块，<br>在2.4版本开始被引入，该模块实现了<code>专用容器数据类型</code>来<strong>替代</strong>python的<code>通用内置容器</code>：dict（字典），list（列表）， set（集合）和tuple（元组）。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>中文名</th>
<th>简介</th>
<th>引入版本</th>
</tr>
</thead>
<tbody><tr>
<td>namedtuple()</td>
<td>命名元组</td>
<td>使用工厂方法创建带有命名的字段的元组的子类</td>
<td>2.6</td>
</tr>
<tr>
<td>deque</td>
<td>双向队列</td>
<td>类似列表的容器，能够快速响应在任何一端进行pop</td>
<td>2.4</td>
</tr>
<tr>
<td>Counter</td>
<td>计数器</td>
<td>字典子类，为可以进行<strong>哈希</strong>的对象计数</td>
<td>2.7</td>
</tr>
<tr>
<td>OrderedDict</td>
<td>有序字典</td>
<td>字典子类，记录了字典的添加次序</td>
<td>2.7</td>
</tr>
<tr>
<td>defaultdict</td>
<td>字典</td>
<td>字典子类，调用一个工厂方法来提供缺失的值</td>
<td>2.5</td>
</tr>
</tbody></table>
<p>除了具体的容器类，collections模块还提供了abstract_base_classes来测试一个类是否体用了一个特定的接口，例如，这是可哈希的还是一个映射。</p>
<p>在2.4版本中新加入，。</p>
<p>中文翻译：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaXJvaF9tczA4L2FydGljbGUvZGV0YWlscy81MjY1MzM4NQ==">https://blog.csdn.net/Shiroh_ms08/article/details/52653385<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2NvbGxlY3Rpb25zLmh0bWw=">collections官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li>源码<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZy5weXRob24ub3JnL2NweXRob24vZmlsZS8yLjcvTGliL2NvbGxlY3Rpb25zLnB5">Lib/collections.py<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZy5weXRob24ub3JnL2NweXRob24vZmlsZS8yLjcvTGliL19hYmNvbGwucHk=">Lib/_abcoll.py<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>[java的collection架构]</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>内建模块</category>
        <category>collection</category>
      </categories>
  </entry>
  <entry>
    <title>Python 对象初探</title>
    <url>/pub/8f55a23/</url>
    <content><![CDATA[<h1 id="Python-对象初探"><a href="#Python-对象初探" class="headerlink" title="Python 对象初探"></a>Python 对象初探</h1><p>在 Python 的世界一切皆对象，不论是整数，还是字符串，甚至连类型、函数等都是一种对象。</p>
<h2 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h2><p>以下是 Python 对象的大致的一个分类</p>
<ul>
<li>Fundamental 对象: 类型对象</li>
<li>Numeric 对象: 数值对象</li>
<li>Sequence 对象: 容纳其他对象的序列集合对象</li>
<li>Mapping 对象: 类似 C++中的 map 的关联对象</li>
<li>Internal 对象: Python 虚拟机在运行时内部使用的对象</li>
</ul>
<p><img src="object-category.jpg" alt="object category"></p>
<h2 id="对象机制的基石-PyObject"><a href="#对象机制的基石-PyObject" class="headerlink" title="对象机制的基石 PyObject"></a>对象机制的基石 PyObject</h2><p>对于初学者来说这么多类型的对象怎么学？别着急，我们后续章节会解答。</p>
<p>在开始我们的学习之旅之前，我们要先认识一个结构体<strong>PyObject</strong>，可以说 Python 的对象机制就是基于<strong>PyObject</strong>拓展开来的，所以我们先看看<strong>PyObject</strong> 到底长什么样。</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDEwNg==">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>经过宏替换后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _object &#123;</span><br><span class="line">    // _PyObject_HEAD_EXTRA  双向链表，垃圾回收需要用到</span><br><span class="line">    struct _object *_ob_next;</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t ob_refcnt;         // 引用计数</span><br><span class="line">    struct _typeobject *ob_type;  // 类型指针，指向类型对象，决定了对象的类型</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>


<p>Python 中的所有对象都拥有一些相同的内容，而这些内容就定义在<strong>PyObject</strong>中，</p>
<p><strong>PyObject</strong> 包含 一个用于垃圾回收的双向链表，一个引用计数变量 <code>ob_refcnt</code> 和 一个类型对象指针<code>ob_type</code></p>
<p>引用计数表示该对象被变量引用的次数，对象被引用1次，ob_refcnt就会加1，引用解除时，ob_refcnt就会减少1。引用计数是Python实现对象回收的重要机制之一。</p>
<p><img src="PyObject.jpg" alt="PyObject"></p>
<h2 id="定长对象与变长对象"><a href="#定长对象与变长对象" class="headerlink" title="定长对象与变长对象"></a>定长对象与变长对象</h2><p>Python中根据对象所占用的内存空间大小是否固定，可以将对象分为定长对象和变长对象。<br>定长对象如整数。变长对象如字符串、列表等。字符串、列表中有多少个元素，都无法事先确定，只能使用变长对象来进行存储。</p>
<p>变长对象都拥有一个相同的内容 <strong>PyVarObject</strong>，而 <strong>PyVarObject</strong>也是基于<strong>PyObject</strong>扩展的。</p>
<p>从代码中可以看出<strong>PyVarObject</strong>比<strong>PyObject</strong>多出了一个用于存储元素个数的变量<em>ob_size</em>。</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDEwNg==">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>宏替换后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="PyVarObject.jpg" alt="PyVarObject"></p>
<h2 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h2><p>前面我们提到了<strong>PyObject</strong> 的 对象类型指针<code>struct _typeobject *ob_type</code>，它指向的类型对象就决定了一个对象是什么类型的。</p>
<p>这是一个非常重要的结构体，它不仅仅决定了一个对象的类型，还包含大量的<code>元信息</code>，<br>包括创建对象需要分配多少内存，对象都支持哪些操作等等。</p>
<p>接下来我们看一下<code>struct _typeobject</code>代码</p>
<p>在 <strong>PyTypeObject</strong> 的定义中包含许多信息，主要分类以下几类:</p>
<ul>
<li>类型名, tp_name, 主要用于 Python 内部调试用</li>
<li>创建该类型对象时分配的空间大小信息，即 <code>tp_basicsize</code> 和 <code>tp_itemsize</code></li>
<li>与该类型对象相关的操作信息(如 <code>tp_print</code> 这样的函数指针)</li>
<li>一些对象属性</li>
</ul>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDM0Ng==">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span> <span class="comment">// 类型名</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line">    <span class="comment">// 创建该类型对象分配的内存空间大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一堆方法定义，函数和指针</span></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line">    <span class="comment">// 标准类方法集</span></span><br><span class="line">    PyNumberMethods *tp_as_number;  <span class="comment">// 数值对象操作</span></span><br><span class="line">    PySequenceMethods *tp_as_sequence;  <span class="comment">// 序列对象操作</span></span><br><span class="line">    PyMappingMethods *tp_as_mapping;  <span class="comment">// 字典对象操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多标准操作</span></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

<h2 id="类型的类型"><a href="#类型的类型" class="headerlink" title="类型的类型"></a>类型的类型</h2><p>在 <strong>PyTypeObjet</strong> 定义开始有一个宏<code>PyOject_VAR_HEAD</code>，查看源码可知 <strong>PyTypeObjet</strong> 是一个变长对象</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDk4">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br></pre></td></tr></table></figure>

<p>对象的类型是由该对象指向的 类型对象 决定的，那么类型对象的类型是由谁决定的呢？<br>对于其他对象，可以通过与其关联的类型对象确定其类型，那么通过什么来确定一个对象是类型对象呢？<br>答案就是 <code>PyType_Type</code></p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvdHlwZW9iamVjdC5jI0wzNTQw">Objects/typeobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/typeobject.c</span></span><br><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;type&quot;</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>PyType_Type</code> 在类型机制中至关重要，所有用户自定义 <code>class</code> 所<br>对应的 <code>PyTypeObject</code> 对象都是通过 <code>PyType_Type</code>创建的</p>
<p>接下来我们看 <code>PyLong_Type</code> 是怎么与 <code>PyType_Type</code> 建立联系的。<br>前面提到，在 Python 中，每一个对象都将自己的引用计数、类型信息保存在开始的部分中。<br>为了方便对这部分内存初始化，Python 中提供了几个有用的宏:</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDY5">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_HEAD_INIT(type)        \</span></span><br><span class="line"><span class="meta">    &#123; _PyObject_EXTRA_INIT              \</span></span><br><span class="line"><span class="meta">    1, type &#125;,</span></span><br></pre></td></tr></table></figure>

<p>这些宏在各种内建类型对象的初始化中被大量使用。<br>以<code>PyLong_Type</code>为例，可以清晰的看到一般的类型对象和<code>PyType_Type</code>之间的关系</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0w1Mzc5">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line"></span><br><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下图是对象运行时的图像表现</p>
<p><img src="object-runtime-relation.jpg"></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Python 创建对象有两种方式</p>
<h3 id="范型-API-或称为-AOL-Abstract-Object-Layer"><a href="#范型-API-或称为-AOL-Abstract-Object-Layer" class="headerlink" title="范型 API 或称为 AOL (Abstract Object Layer)"></a>范型 API 或称为 AOL (Abstract Object Layer)</h3><p>这类 API 通常形如<code>PyObject_XXX</code>这样的形式。可以应用在任何 Python 对象上，<br>如<code>PyObject_New</code>。创建一个整数对象的方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject* longobj = PyObject_New(Pyobject, &amp;PyLong_Type);</span><br></pre></td></tr></table></figure>

<h3 id="与类型相关的-API-或称为-COL-Concrete-Object-Layer"><a href="#与类型相关的-API-或称为-COL-Concrete-Object-Layer" class="headerlink" title="与类型相关的 API 或称为 COL (Concrete Object Layer)"></a>与类型相关的 API 或称为 COL (Concrete Object Layer)</h3><p>这类 API 通常只能作用于某一种类型的对象上，对于每一种内建对象<br>Python 都提供了这样一组 API。例如整数对象，我们可以利用如下的 API 创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *longObj = PyLong_FromLong(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="对象的行为"><a href="#对象的行为" class="headerlink" title="对象的行为"></a>对象的行为</h2><p>在 <strong>PyTypeObject</strong> 中定义了大量的函数指针。这些函数指针可以视为类型对象中<br>所定义的操作，这些操作直接决定着一个对象在运行时所表现出的行为，比如 <strong>PyTypeObject</strong> 中的 <code>tp_hash</code> 指明了该类型对象如何生成其<code>hash</code>值。</p>
<p>在<strong>PyTypeObject</strong>的代码中，我们还可以看到非常重要的三组操作族</p>
<ul>
<li><code>PyNumberMethods *tp_as_number</code></li>
<li><code>PySequenceMethods *tp_as_sequence</code></li>
<li><code>PyMappingMethods *tp_as_mapping</code></li>
</ul>
<p><strong>PyNumberMethods</strong> 的代码如下</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDI0MA==">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="keyword">typedef</span> PyObject * (*binaryfunc)(PyObject *, PyObject *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    binaryfunc nb_matrix_multiply;</span><br><span class="line">    binaryfunc nb_inplace_matrix_multiply;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p><strong>PyNumberMethods</strong> 定义了一个数值对象该支持的操作。一个数值对象如 整数对象，那么它的类型对象 <code>PyLong_Type</code>中<code>tp_as_number.nb_add</code><br>就指定了它进行加法操作时的具体行为。</p>
<p>在以下代码中可以看出<code>PyLong_Type</code>中的<code>tp_as_number</code>项指向的是<code>long_as_number</code></p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0w1MzQy">Objects/longobject.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line"><span class="keyword">static</span> PyNumberMethods long_as_number = &#123;</span><br><span class="line">    (binaryfunc)long_add,       <span class="comment">/*nb_add*/</span></span><br><span class="line">    (binaryfunc)long_sub,       <span class="comment">/*nb_subtract*/</span></span><br><span class="line">    (binaryfunc)long_mul,       <span class="comment">/*nb_multiply*/</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>PySequenceMethods *tp_as_sequence</code> 和 <code>PyMappingMethods *tp_as_mapping</code>的分析与<code>PyNumberMethods *tp_as_number</code> 相同，大家可以自行查阅源码</p>
<h2 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h2><p>Python 创建一个对象比如 <strong>PyLongObject</strong> 时，会分配内存进行初始化，然后<br>Python 内部会用 <code>PyObject*</code> 变量来维护这个对象，其他对象也与此类似</p>
<p>所以在 Python 内部各个函数之间传递的都是一种范型指针 <code>PyObject*</code><br>我们不知道这个指针所指的对象是什么类型，只能通过所指对象的 <code>ob_type</code> 域<br>动态进行判断，而 Python 正是通过 <code>ob_type</code> 实现了多态机制</p>
<p>考虑以下的 calc_hash 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Py_hash_t</span></span><br><span class="line"><span class="function"><span class="title">calc_hash</span><span class="params">(PyObject* object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Py_hash_t hash = object-&gt;ob_type-&gt;tp_hash(object);</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传递给 calc_hash 函数的指针是一个 <code>PyLongObject*</code>，那么它会调用 PyLongObject 对象对应的类型对象中定义的 hash 操作<code>tp_hash</code>，<code>tp_hash</code>可以在<strong>PyTypeObject</strong>中找到，<br>而具体赋值绑定我们可以在 <code>PyLong_Type</code> 初始化代码中看到绑定的是<code>long_hash</code>函数</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0w1Mzc5">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果指针是一个 <code>PyUnicodeObject*</code>，那么就会调用 PyUnicodeObject 对象对应的类型对象中定义的 hash 操作，查看源码可以看到 实际绑定的是 <code>unicode_hash</code>函数</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvdW5pY29kZW9iamVjdC5jI0wxNTA2Ng==">Objects/unicodeobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/unicodeobject.c</span></span><br><span class="line">PyTypeObject PyUnicode_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;str&quot;</span>,              <span class="comment">/* tp_name */</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    (hashfunc) unicode_hash,        <span class="comment">/* tp_hash*/</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python 通过引用计数来管理维护对象在内存中的存在与否</p>
<p>Python 中的每个东西都是一个对象， 都有<code>ob_refcnt</code> 变量，这个变量维护对象的引用计数，从而最终决定该对象的创建与销毁</p>
<p>在 Python 中，主要通过 <code>Py_INCREF(op)</code>与<code>Py_DECREF(op)</code> 这两个宏<br>来增加和减少对一个对象的引用计数。当一个对象的引用计数减少到 0 之后，<br><code>Py_DECREF</code>将调用该对象的<code>tp_dealloc</code>来释放对象所占用的内存和系统资源；</p>
<p>但这并不意味着最终一定会调用 <code>free</code> 释放内存空间。因为频繁的申请、释放内存会大大降低 Python 的执行效率。因此 Python 中大量采用了内存对象池的技术，使得对象释放的空间归还给内存池而不是直接<code>free</code>，后续使用可先从对象池中获取</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvb2JqZWN0LmgjTDc3Nw==">Include/object.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_NewReference(op) (                          \</span></span><br><span class="line"><span class="meta">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span></span><br><span class="line"><span class="meta">    Py_REFCNT(op) = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INCREF(op) (                         \</span></span><br><span class="line"><span class="meta">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">    ((PyObject *)(op))-&gt;ob_refcnt++)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_DECREF(op)                                   \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span></span><br><span class="line"><span class="meta">        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \</span></span><br><span class="line"><span class="meta">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">else</span>                                            \</span></span><br><span class="line"><span class="meta">            _Py_Dealloc(_py_decref_tmp);                \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>cpython源码</category>
        <category>objects</category>
      </categories>
  </entry>
  <entry>
    <title>渣渣中的渣渣 之 DaoVoice</title>
    <url>/pub/9ff21bc3/</url>
    <content><![CDATA[<h2 id="垃圾中的垃圾-之-DaoVoice"><a href="#垃圾中的垃圾-之-DaoVoice" class="headerlink" title="垃圾中的垃圾 之 DaoVoice"></a>垃圾中的垃圾 之 DaoVoice</h2><p>特点：高延迟</p>
<p>你如果用过DaoVoice的话，肯定知道它延迟很长。但是为什么延迟这么长呢，下面来看看。</p>
<p>通常web-chat都采用websocket。<br>html–server–html<br>就是一堆的websocket连接</p>
<p>反应特别慢，消息的发送和接收，在websocket中并未看到。</p>
<p><strong>消息的发送</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbS5kYW92b2ljZS5pby92MS9jb252ZXJzYXRpb25zL2IxZmJhOTU5LWE4NDMtNDNjYS05NTM4LTkyOGExY2RmZDYyZC9yZXBseQ==">https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/reply<i class="fa fa-external-link-alt"></i></span><br>的request payload参数进行明文传输的。</p>
<p><strong>消息的接收</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbS5kYW92b2ljZS5pby92MS9jb252ZXJzYXRpb25zL2IxZmJhOTU5LWE4NDMtNDNjYS05NTM4LTkyOGExY2RmZDYyZC9yZWFk">https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/read<i class="fa fa-external-link-alt"></i></span></p>
<p>消息接收并非是服务器推送的，而是每次客户端主动发送消息时才会触发消息接收。(DaoVoice的设计也太挫了吧，这可不是一般的延迟啊，根本不能叫instant message)</p>
<p>开了个websocket，什么事都不干，发一些没用的数据。</p>
<h2 id="dao-voice原理"><a href="#dao-voice原理" class="headerlink" title="dao voice原理"></a>dao voice原理</h2><p>基于websocket</p>
<p>Request</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request URL:wss://rtm.daovoice.io/socket.io/?EIO=3&amp;transport=websocket&amp;sid=-ezTav4AxWfvgBszAjuI</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:101 Switching Protocols</span><br></pre></td></tr></table></figure>

<p>Response header</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Connection:</span> <span class="string">upgrade</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Tue,</span> <span class="number">06</span> <span class="string">Feb</span> <span class="number">2018 01:52:13 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Accept:</span> <span class="string">+vrxS3Tw4HDKi3JDS5wRL7vIqKc=</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Extensions:</span> <span class="string">permessage-deflate</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">nginx/1.9.13</span></span><br><span class="line"><span class="attr">Upgrade:</span> <span class="string">websocket</span></span><br></pre></td></tr></table></figure>

<p>Frames</p>
<p>首先发送http请求<br><span class="exturl" data-url="aHR0cHM6Ly9ydG0uZGFvdm9pY2UuaW8vc29ja2V0LmlvLz9FSU89MyZhbXA7dHJhbnNwb3J0PXBvbGxpbmcmYW1wO3Q9TTVaV0twcyZhbXA7c2lkPUp0ak82d1hkT29ISDdSWFdGcWh3">https://rtm.daovoice.io/socket.io/?EIO=3&amp;transport=polling&amp;t=M5ZWKps&amp;sid=JtjO6wXdOoHH7RXWFqhw<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbS5kYW92b2ljZS5pby92MS9jb252ZXJzYXRpb25zLzAyMDEwNTk0LWQ3YjgtNGYzYS04OTZhLTRmODJlMmNjOTE5OC9mZXRjaA==">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/fetch<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pbS5kYW92b2ljZS5pby92MS9jb252ZXJzYXRpb25zLzAyMDEwNTk0LWQ3YjgtNGYzYS04OTZhLTRmODJlMmNjOTE5OC9yZWFk">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/read<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pbS5kYW92b2ljZS5pby92MS9jb252ZXJzYXRpb25zLzAyMDEwNTk0LWQ3YjgtNGYzYS04OTZhLTRmODJlMmNjOTE5OC9yZXBseQ==">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/reply<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="如何自己实现在线联系"><a href="#如何自己实现在线联系" class="headerlink" title="如何自己实现在线联系"></a>如何自己实现在线联系</h2><h3 id="利用websocket"><a href="#利用websocket" class="headerlink" title="利用websocket"></a>利用websocket</h3><h3 id="利用微信api"><a href="#利用微信api" class="headerlink" title="利用微信api"></a>利用微信api</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZXpsaXBwaS5jb20vYmxvZy8yMDE4LzAxL25leHQtY2hhdC5odG1s">利用dao voice<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
        <category>plugin</category>
        <category>2</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>plugin</tag>
        <tag>instant-message</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo插件系列】hexo-reference</title>
    <url>/pub/dec3cfee/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renderFootnotes = <span class="built_in">require</span>(<span class="string">&#x27;./src/footnotes&#x27;</span>);</span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">&#x27;hexo-util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register footnotes filter</span></span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  data.content = renderFootnotes(data.content);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add CDN CSS resources</span></span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  data.content =</span><br><span class="line">      util.htmlTag(<span class="string">&#x27;link&#x27;</span>, &#123;<span class="attr">rel</span>: <span class="string">&#x27;stylesheet&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;text/css&#x27;</span>, <span class="attr">href</span>: <span class="string">&#x27;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&#x27;</span>&#125;) +</span><br><span class="line">      data.content;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>是不是应该叫filter</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>blog-framework</category>
        <category>nodejs-hexo</category>
        <category>plugin</category>
        <category>2</category>
      </categories>
  </entry>
  <entry>
    <title>【数据分析篇】aspect-level 数据分析</title>
    <url>/pub/27351887/</url>
    <content><![CDATA[<p>SemEval 2014 Task 4</p>
<p>Read train 2990, test 973</p>
<p>长度 20以下的，Trimmed to train 2124, test 692</p>
<p>数据量好少，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and cheap !</span><br><span class="line">price</span><br><span class="line">1</span><br><span class="line">the staff is n&#x27;t the friendliest or most competent , and i am stickler for service , but everything else about this place makes up for it .</span><br><span class="line">service</span><br><span class="line">-1</span><br><span class="line">the service is always bad though , do n&#x27;t expect much of anything from your server , and i would not recommend bringing a date here either .</span><br><span class="line">service</span><br><span class="line">-1</span><br><span class="line">i absolutely love this place ! ! !</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">a restaurant that does n&#x27;t try to do anything except serve great food with great service in a pleasant atmosphere .</span><br><span class="line">ambience</span><br><span class="line">1</span><br><span class="line">this place was not all that !</span><br><span class="line">miscellaneous</span><br><span class="line">-1</span><br><span class="line">the food is great .</span><br><span class="line">food</span><br><span class="line">1</span><br><span class="line">highly recommended ! ! ! ! !</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">the food was really good , i had the onion soup and it was one of the best ever .</span><br><span class="line">food</span><br><span class="line">1</span><br><span class="line">a++ the service was good to excellent along with the attitude .</span><br><span class="line">service</span><br><span class="line">1</span><br><span class="line">we had a 3 hour brunch- they definitely do not rush you- and they kept the unlimited mimosas flowing the whole time .</span><br><span class="line">service</span><br><span class="line">1</span><br><span class="line">i &#x27;ve been eating at taj mahal for over twenty years and have found them to be the most excellent of the indian eateries on this block of indian restaurants .</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">anyway , the food is good , the price is right and they have a decent wine list .</span><br><span class="line">price</span><br><span class="line">1</span><br></pre></td></tr></table></figure>


<p>基于aspect的情感分析指的是挖掘句子中涉及的aspect，以及对每个aspect表现出来的情感。</p>
<p>现有的工作一般把这个任务分成两个部分：aspect识别，可以是aspect term提取或者aspect分类；aspect的情感识别</p>
<h2 id="aspect-term提取"><a href="#aspect-term提取" class="headerlink" title="aspect term提取"></a>aspect term提取</h2><h1 id="待阅读"><a href="#待阅读" class="headerlink" title="待阅读"></a>待阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cDovL3poYW94dWVsaS53aW4vMjAxNy8wMy8wNi8lRTUlOUYlQkElRTQlQkElOEUtQXNwZWN0LSVFNyU5QSU4NCVFNiU4MyU4NSVFNiU4NCU5RiVFNSU4OCU4NiVFNiU5RSU5MC8=">http://zhaoxueli.win/2017/03/06/%E5%9F%BA%E4%BA%8E-Aspect-%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yMjcwNTNiNGE4NWM=">https://www.jianshu.com/p/227053b4a85c<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>text_classification</category>
        <category>datasets</category>
        <category>aspect</category>
      </categories>
      <tags>
        <tag>dataset</tag>
        <tag>数据分析</tag>
        <tag>文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器翻译】CNN系列 - convseq2seq</title>
    <url>/pub/b4bccd18/</url>
    <content><![CDATA[<h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>convseq2seq 架构<br><img alt="Illustration of batching during training" title="convs2s的batch training过程" src="/images/raw/NN - convseq2seq - architecture.png"><br><strong>注意</strong>: 这里的attention是同时得到的，RNN中的attention则是依次得到的。</p>
<p>卷积过程<br><img alt="convseq2seq的卷积过程" title="convseq2seq的卷积过程" src="/images/raw/NN - convseq2seq - flow.gif"></p>
<p>采用的全卷积网络(没有RNN)</p>
<ul>
<li><code>Position Embedding</code>: 给CNN更多的“位置感”</li>
<li><code>Gated Linear Units</code>: 给CNN的输出加gate<!-- gated linear units eases gradient propagation --></li>
<li><code>Residual Connection</code>: 给CNN都加</li>
<li><code>Multi-step Attention</code>: 一层attention不够那就上叠加的attention</li>
</ul>
<h1 id="Implementation-实现细节"><a href="#Implementation-实现细节" class="headerlink" title="Implementation/实现细节"></a>Implementation/实现细节</h1><p>Fairseq features:</p>
<ul>
<li>multi-GPU (distributed) training on one machine or across multiple machines</li>
<li>fast beam search generation on both CPU and GPU</li>
<li>large mini-batch training (even on a single GPU) via delayed updates</li>
<li>fast half-precision floating point (FP16) training</li>
</ul>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvZmFpcnNlcQ==">fairseq - torch<i class="fa fa-external-link-alt"></i></span> 停止更新</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvZmFpcnNlcQ==">fairseq - pytorch<i class="fa fa-external-link-alt"></i></span> 及时更新</li>
</ul>
<h1 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h1><ul>
<li>A Convolutional Encoder Model for Neural Machine Translation 2016</li>
<li>Convolutional Sequence to Sequence Learning 2017</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmZhY2Vib29rLmNvbS9wb3N0cy8xOTc4MDA3NTY1ODE4OTk5L2Etbm92ZWwtYXBwcm9hY2gtdG8tbmV1cmFsLW1hY2hpbmUtdHJhbnNsYXRpb24v">blog | facebook<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU5NjQ1MzI5L2Fuc3dlci8xNjc3MDQzNzY=">https://www.zhihu.com/question/59645329/answer/167704376<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>translation</category>
        <category>2. 主流model-研究现状</category>
        <category>2. NMT</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>seq2seq</tag>
        <tag>CNN</tag>
        <tag>attention</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器翻译】RNN系列 - GNMT</title>
    <url>/pub/6eefa992/</url>
    <content><![CDATA[<p>2016年9月，Google机器翻译实现重大突破！Google研究团队宣布开发<code>Google神经机器翻译系统</code>(GNMT)。同年11月，Google翻译<strong>停止使用其自2007年10月以来一直使用的专有统计机器翻译（SMT）技术，开始使用神经机器翻译（NMT）</strong>。<br>从此宣告， 机器翻译经过27年左右， 正式从1989年的IBM机器翻译模型(PBMT，基于短语的机器翻译)，过渡到了神经网络机器翻译模型。</p>
<p>GNMT是一种端到端的学习方法，<strong>不再将句子分解为词和短语独立翻译，而是翻译完整的句子</strong>，使得误差降低了 55%-85% 以上。</p>
<img title="GNMT进行中英翻译的流程" src="/images/raw/NN - GNMT - flow.gif">


<p>首先，模型对中文进行编码。整个句子编码完成后，启动decoder，进行解码。解码过程中的每一步，都需要一组attention weight，对输入序列的vector进行加权。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>NMT虽然已经开始应用，</p>
<p>但 NMT 系统的训练和翻译推理的计算成本非常高，同时也难以应对罕见词，这些问题阻碍了 NMT 在实际部署和服务中的应用，因为在实际应用中，准确度和速度都很关键。而谷歌的神经机器翻译提出了带有 8 个编码器和 8 个解码器的深度 LSTM 网络组成的模型，使用了注意力和残差连接。为了提升并行性从而降低训练时间，注意机制将解码器的底层连接到了编码器的顶层。在推理计算过程中使用了低精度运算来加速翻译速度。为改善对罕见词的处理，谷歌将词分成常见子词单元（词的组件）的一个有限集合，该集合既是输入也是输出。这种方法能提供「字符」-delimited models 的灵活性和「词」-delimited models 的有效性之间的平衡、能自然地处理罕见词的翻译、并能最终提升系统的整体准确度。谷歌的波束搜索技术使用了一个长度规范化过程，并使用了一个覆盖度惩罚，其可以激励很可能能覆盖源句子中所有的词的输出句子的生成。在 WMT’ 14 英语-法语和英语-德语基准上，GNMT 实现了可与当前最佳结果媲美的结果。通过在一个单独的简单句子集合的人类对比评估中，它相比于谷歌已经投入生产的基于短语的系统的翻译误差平均降低了 60%。</p>
<!--
GNMT improves on the quality of translation by applying an example based (EBMT) MT method in which the system "learns from millions of examples"
-->


<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><img title="GNMT architecture" src="/images/raw/NN - GNMT - architecture.jpg">

<img title="LSTM with residual connection" src="/images/raw/NN - GNMT - LSTM with residual.png">

<h1 id="zero-shot翻译"><a href="#zero-shot翻译" class="headerlink" title="zero-shot翻译"></a>zero-shot翻译</h1><p>GNMT系统可以处理“零点翻译”，即直接将一种语言翻译成另一种语言（例如中文到日文）。以前Google翻译会<strong>先将源语言翻译成英文，然后将英文翻译成目标语言</strong>，而不是直接从一种语言翻译成另一种语言。</p>
<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><img title="评分从0到6，0表示最差翻译，6表示最佳翻译" src="https://1.bp.blogspot.com/-jOLa-LdidQU/V-qV2oJn1aI/AAAAAAAABPg/-6OhKKPhxT89Vs9HhyKMEnyG_0ncWGjJQCLcB/s640/image00.png">



<img title="不同翻译系统的效果对比" src="https://1.bp.blogspot.com/-TAEq5oc14jQ/V-qWTeqaA7I/AAAAAAAABPo/IEmOBO6x7nIkzLqomgk_DwVtzvpEtJF1QCLcB/s640/img3.png">

<p>以上可以看出</p>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul>
<li>漏翻 <!-- dropping words --></li>
<li>错翻：特别是对于名字和稀有词(rare word)</li>
<li>未考虑大语境(context of the paragraph or page)</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="">GNMT: Bridging the Gap between Human and Machine Translation</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9haS5nb29nbGVibG9nLmNvbS8yMDE2LzA5L2EtbmV1cmFsLW5ldHdvcmstZm9yLW1hY2hpbmUuaHRtbA==">NTM at Production Scale | Google Blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR29vZ2xlX05ldXJhbF9NYWNoaW5lX1RyYW5zbGF0aW9u">GNMT | 维基百科<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUxMDg5MTky">如何评价Google神经机器翻译（GNMT）系统？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>translation</category>
        <category>2. 主流model-研究现状</category>
        <category>2. NMT</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>seq2seq</tag>
        <tag>attention</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR引擎-Tesseract-OCR简介</title>
    <url>/pub/1ff2cbf2/</url>
    <content><![CDATA[<h1 id="Tesseract简介-amp-历史"><a href="#Tesseract简介-amp-历史" class="headerlink" title="Tesseract简介&amp;历史"></a>Tesseract简介&amp;历史</h1><p>Tesseract(/‘tesərækt/) 意思是四维超正方体（英语：tesseract）或正八胞体。下图来自维基百科，是一个正八胞体绕着两个四维空间中互相正交的平面进行双旋转时的透视投影。</p>
<p><img title="这不是Tesseract-OCR的logo" src="https://upload.wikimedia.org/wikipedia/commons/5/55/8-cell-simple.gif"></img></p>
<blockquote>
<p>Tesseract was originally developed at Hewlett-Packard Laboratories Bristol and at Hewlett-Packard Co, Greeley Colorado between 1985 and 1994, with some more changes made in 1996 to port to Windows, and some C++izing in 1998. In 2005 Tesseract was open sourced by HP. Since 2006 it is developed by Google.<br>来自 github官方</p>
</blockquote>
<p>Tesseract-OCR是一个开源的OCR引擎，具有悠久的历史。<br>惠普公司的布里斯托尔实验室在1985-1994年开发完成。起初作为惠普的平板扫描仪的文字识别引擎。Tesseract在1995年UNLV OCR字符识别准确性测试中拔得头筹，受到广泛关注。后来HP放弃了OCR市场。在1994年以后，Tesseract的开发就停止了。</p>
<p>在2005年，HP将Tesseract贡献给开源社区。美国内华达州信息技术研究所获得该源码，同时，Google开始对Tesseract进行功能扩展及优化。目前，Tesseract作为开源项目发布在Google Project上，重获新生。Tesseract的最新版本是3.02，它支持60种以上的语言，提供一个引擎和一个命令行工具。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdC1vY3IvdGVzc2VyYWN0">github-官网<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdC1vY3IvdGVzc2VyYWN0L3dpa2k=">官方文档-wiki<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install tesseract-ocr</p>
<p>sudo apt-get install tesseract-ocr-eng tesseract-ocr-chi-sim</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy56bW9uc3Rlci5tZS8yMDE1LzA0LzE3L3Rlc3NlcmFjdC1pbnN0YWxsLXVzYWdlLmh0bWw=">Tesseract:安装与命令行使用<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看可用的 &quot;语言&quot;</span></span><br><span class="line">$ tesseract --list-langs</span><br></pre></td></tr></table></figure>

<h2 id="Tesseract识别图片"><a href="#Tesseract识别图片" class="headerlink" title="Tesseract识别图片"></a>Tesseract识别图片</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from a TIFF image with Tesseract OCR</span></span><br><span class="line">$ tesseract test.png <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Tesseract识别tiff"><a href="#Tesseract识别tiff" class="headerlink" title="Tesseract识别tiff"></a>Tesseract识别tiff</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 识别tiff文档，默认是英语</span></span><br><span class="line">$ tesseract test.tiff <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别非英语文档</span></span><br><span class="line">tesseract test.tiff -l [lan] test.txt</span><br></pre></td></tr></table></figure>

<h2 id="Tesseract识别pdf"><a href="#Tesseract识别pdf" class="headerlink" title="Tesseract识别pdf"></a>Tesseract识别pdf</h2><p>步骤:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 转换pdf到tiff(或其他格式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tesseract test.pdf <span class="built_in">test</span></span><br><span class="line">Tesseract Open Source OCR Engine v3.02 with Leptonica</span><br><span class="line">Error <span class="keyword">in</span> pixReadStream: Unknown format: no pix returned</span><br><span class="line">Error <span class="keyword">in</span> pixRead: pix not <span class="built_in">read</span></span><br><span class="line">Unsupported image <span class="built_in">type</span>.</span><br></pre></td></tr></table></figure>
<p>tesseract不能直接识别pdf，一般需要借助工具转化成tiff，然后再识别。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ convert test.pdf test.tiff</span><br><span class="line">$ tesseract test.tiff <span class="built_in">test</span></span><br><span class="line">Tesseract Open Source OCR Engine v3.02 with Leptonica</span><br><span class="line">Error <span class="keyword">in</span> pixReadFromTiffStream: can<span class="string">&#x27;t handle bpp &gt; 32</span></span><br><span class="line"><span class="string">Error in pixReadStreamTiff: pix not read</span></span><br><span class="line"><span class="string">Error in pixReadStream: tiff: no pix returned</span></span><br><span class="line"><span class="string">Error in pixRead: pix not read</span></span><br><span class="line"><span class="string">Unsupported image type.</span></span><br></pre></td></tr></table></figure>
<p>tesseract不能够读取bpp &gt; 32的tiff文件。因此我们转为8bit的tiff文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ convert test.pdf -depth 8 test.tiff</span><br><span class="line">$ tesseract test.tiff output</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在能够正常识别了。</p>
<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMWFmZDdmYzU4MTM=">https://www.jianshu.com/p/31afd7fc5813<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="准备训练集"><a href="#准备训练集" class="headerlink" title="准备训练集"></a>准备训练集</h2><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><ul>
<li>图像预处理<br>Tesseract目的不是作为OCR软件，而仅仅是<code>OCR engine</code>。Tesseract在图像预处理方面很弱，如果想得到比较好的识别效果，需要使用者<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rlc3NlcmFjdC1vY3IvdGVzc2VyYWN0L3dpa2kvSW1wcm92ZVF1YWxpdHk=">自己做图片预处理<i class="fa fa-external-link-alt"></i></span>。然而一般多数OCR软件都会集成图片预处理模块，比如Nuance。</li>
</ul>
<p>估计怕做的太好，让商业软件</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>vision</category>
        <category>app</category>
        <category>OCR</category>
        <category>Tesseract-OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
        <tag>Tesseract</tag>
      </tags>
  </entry>
  <entry>
    <title>java hotspot虚拟机 - SocketOutputStream</title>
    <url>/pub/5eb3e0be/</url>
    <content><![CDATA[<h2 id="SocketOutputStream-java"><a href="#SocketOutputStream-java" class="headerlink" title="SocketOutputStream.java"></a>SocketOutputStream.java</h2><p>就只有这一个native方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Writes to the socket.</span></span><br><span class="line"><span class="comment">* @param fd the FileDescriptor</span></span><br><span class="line"><span class="comment">* @param b the data to be written</span></span><br><span class="line"><span class="comment">* @param off the start offset in the data</span></span><br><span class="line"><span class="comment">* @param len the number of bytes that are written</span></span><br><span class="line"><span class="comment">* @exception IOException If an I/O error has occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> native <span class="keyword">void</span> <span class="title">socketWrite0</span><span class="params">(FileDescriptor fd, byte[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> throws IOException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="SocketOutputStream-c"><a href="#SocketOutputStream-c" class="headerlink" title="SocketOutputStream.c"></a>SocketOutputStream.c</h2><p>路径: <code>openjdk\jdk\src\windows\native\java\net\SocketOutputStream.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;java_net_SocketOutputStream.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;net_util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jni_util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> * SocketOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> jfieldID IO_fd_fdID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     java_net_SocketOutputStream</span></span><br><span class="line"><span class="comment"> * Method:    init</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_net_SocketOutputStream_init</span><span class="params">(JNIEnv *env, jclass cls)</span> </span>&#123;</span><br><span class="line">    IO_fd_fdID = NET_GetFileDescriptorID(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     java_net_SocketOutputStream</span></span><br><span class="line"><span class="comment"> * Method:    socketWrite</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/io/FileDescriptor;[BII)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_net_SocketOutputStream_socketWrite0</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              jobject fdObj, jbyteArray data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              jint off, jint len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bufP;</span><br><span class="line">    <span class="keyword">char</span> BUF[MAX_BUFFER_LEN];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(fdObj)) &#123;</span><br><span class="line">        JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">&quot;SocketException&quot;</span>, <span class="string">&quot;Socket closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd = (*env)-&gt;GetIntField(env, fdObj, IO_fd_fdID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(data)) &#123;</span><br><span class="line">        JNU_ThrowNullPointerException(env, <span class="string">&quot;data argument&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use stack allocate buffer if possible. For large sizes we allocate</span></span><br><span class="line"><span class="comment">     * an intermediate buffer from the heap (up to a maximum). If heap is</span></span><br><span class="line"><span class="comment">     * unavailable just use our stack buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= MAX_BUFFER_LEN) &#123;</span><br><span class="line">        bufP = BUF;</span><br><span class="line">        buflen = MAX_BUFFER_LEN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = min(MAX_HEAP_BUFFER_LEN, len);</span><br><span class="line">        bufP = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">size_t</span>)buflen);</span><br><span class="line">        <span class="keyword">if</span> (bufP == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bufP = BUF;</span><br><span class="line">            buflen = MAX_BUFFER_LEN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> loff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> chunkLen = min(buflen, len);</span><br><span class="line">        <span class="keyword">int</span> llen = chunkLen;</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        (*env)-&gt;GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = send(fd, bufP + loff, llen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                llen -= n;</span><br><span class="line">                loff += n;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Due to a bug in Windows Sockets (observed on NT and Windows</span></span><br><span class="line"><span class="comment">             * 2000) it may be necessary to retry the send. The issue is that</span></span><br><span class="line"><span class="comment">             * on blocking sockets send/WSASend is supposed to block if there</span></span><br><span class="line"><span class="comment">             * is insufficient buffer space available. If there are a large</span></span><br><span class="line"><span class="comment">             * number of threads blocked on write due to congestion then it&#x27;s</span></span><br><span class="line"><span class="comment">             * possile to hit the NT/2000 bug whereby send returns WSAENOBUFS.</span></span><br><span class="line"><span class="comment">             * The workaround we use is to retry the send. If we have a</span></span><br><span class="line"><span class="comment">             * large buffer to send (&gt;2k) then we retry with a maximum of</span></span><br><span class="line"><span class="comment">             * 2k buffer. If we hit the issue with &lt;=2k buffer then we backoff</span></span><br><span class="line"><span class="comment">             * for 1 second and retry again. We repeat this up to a reasonable</span></span><br><span class="line"><span class="comment">             * limit before bailing out and throwing an exception. In load</span></span><br><span class="line"><span class="comment">             * conditions we&#x27;ve observed that the send will succeed after 2-3</span></span><br><span class="line"><span class="comment">             * attempts but this depends on network buffers associated with</span></span><br><span class="line"><span class="comment">             * other sockets draining.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAENOBUFS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (llen &gt; MAX_BUFFER_LEN) &#123;</span><br><span class="line">                    buflen = MAX_BUFFER_LEN;</span><br><span class="line">                    chunkLen = MAX_BUFFER_LEN;</span><br><span class="line">                    llen = MAX_BUFFER_LEN;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (retry &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">                    JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">&quot;SocketException&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;No buffer space available - exhausted attempts to queue buffer&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">                        <span class="built_in">free</span>(bufP);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">                retry++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Send failed - can be caused by close or write error.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAENOTSOCK) &#123;</span><br><span class="line">                JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">&quot;SocketException&quot;</span>, <span class="string">&quot;Socket closed&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                NET_ThrowCurrent(env, <span class="string">&quot;socket write error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">                <span class="built_in">free</span>(bufP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len -= chunkLen;</span><br><span class="line">        off += chunkLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">        <span class="built_in">free</span>(bufP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>jvm</category>
        <category>HotSpot</category>
      </categories>
  </entry>
  <entry>
    <title>java hotspot虚拟机 - init方法</title>
    <url>/pub/e4c70599/</url>
    <content><![CDATA[<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<clinit>, 另一个是实例的初始化方法<init><br><clinit>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行<br><init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。</p>
<h2 id="init的实现"><a href="#init的实现" class="headerlink" title="init的实现"></a>init的实现</h2><p>是由jvm实现的，以下是hotspot jvm实现的版本</p>
<p>openjdk\hotspot\src\share\vm\oops\instanceKlass.cpp<br>openjdk\hotspot\src\share\vm\oops\instanceKlassKlass.cpp</p>
<p>为什么叫</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p>oops原来不是Object Oriented Programming，实际指的是 Ordinary Object Pointer（普通对象指针）。它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象。而klass则包含 元数据和方法信息，用来描述Java类。</p>
</li>
<li><p>Klass</p>
</li>
<li><p>KlassKlass</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>(见JVM规范8中的2.9节)</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>jvm</category>
        <category>HotSpot</category>
      </categories>
  </entry>
  <entry>
    <title>java hotspot虚拟机 - class文件</title>
    <url>/pub/3a5d7b99/</url>
    <content><![CDATA[<h2 id="oop-klass-model概述"><a href="#oop-klass-model概述" class="headerlink" title="oop-klass model概述"></a>oop-klass model概述</h2><p>HotSpot JVM并没有根据Java实例对象直接通过虚拟机映射到新建的C++对象，而是设计了一个oop-klass model。</p>
<p>当我们在写Java代码的时候，我们会面对着无数个接口，类，对象和方法。但我们有木有想过，Java中的这些对象、类和方法，在HotSpot JVM中的结构又是怎么样呢？HotSpot JVM底层都是C++实现的，那么Java的对象模型与C++对象模型之间又有什么关系呢？今天就来分析一下HotSpot JVM中的对象模型：oop-klass model，它们的源码位于openjdk-8/openjdk/hotspot/src/share/vm/oops文件夹内。</p>
<p>那么为何要设计这样一个一分为二的对象模型呢？这是因为HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行method dispatch。这个模型其实是参照的 Strongtalk VM 底层的对象模型。</p>
<p>jdk版本：openjdk-7-fcs-src-b147-27_jun_2011<br>源码路径：openjdk\hotspot\src\share\vm\oops\</p>
<p>在oopsHierarchy.hpp里定义了oop和klass各自的体系。<br>这是oop的体系：</p>
<pre><code>typedef class oopDesc*                            oop;
typedef class   instanceOopDesc*            instanceOop;
typedef class   methodOopDesc*                    methodOop;
typedef class   constMethodOopDesc*            constMethodOop;
typedef class   methodDataOopDesc*            methodDataOop;
typedef class   arrayOopDesc*                    arrayOop;
typedef class     objArrayOopDesc*            objArrayOop;
typedef class     typeArrayOopDesc*            typeArrayOop;
typedef class   constantPoolOopDesc*            constantPoolOop;
typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;
typedef class   klassOopDesc*                    klassOop;
typedef class   markOopDesc*                    markOop;
typedef class   compiledICHolderOopDesc*    compiledICHolderOop;
</code></pre>
<h2 id="概述，代码架构"><a href="#概述，代码架构" class="headerlink" title="概述，代码架构"></a>概述，代码架构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">klass.cpp</span><br><span class="line">oop.cpp</span><br><span class="line">arrayKlass.cpp</span><br><span class="line">arrayOop.cpp</span><br><span class="line">instanceKlass.cpp</span><br><span class="line">instanceOop.cpp  // #include &quot;oops/oop.hpp&quot;</span><br><span class="line">methodKlass.cpp</span><br><span class="line"></span><br><span class="line">// A methodOop represents a Java method.</span><br><span class="line">// #include &quot;oops/constantPoolOop.hpp&quot;#include &quot;oops/instanceKlass.hpp&quot; #include &quot;oops/oop.hpp&quot;</span><br><span class="line">methodOop.cpp  </span><br><span class="line"></span><br><span class="line">methodDataKlass.cpp</span><br><span class="line">methodDataOop.cpp</span><br><span class="line">objArrayKlass.cpp</span><br><span class="line">objArrayOop.cpp</span><br><span class="line"></span><br><span class="line">symbol.cpp</span><br></pre></td></tr></table></figure>


<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>oop：<br>Ordinary Object Pointer（普通对象指针），oop.h中定义了oopDesc类(没有oop这个类)</li>
</ul>
<p>oop* 有这个而东东啊</p>
<ul>
<li><p>Desc：<br>即Describe， {name}Desc classes describe the format of Java objects so the fields can be accessed from C++</p>
</li>
<li><p>oopDesc:<br>oop对象的类型其实是oopDesc*。在Java程序运行的过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的oop对象。各种oop类的共同基类为oopDesc类。</p>
</li>
<li><p>oop-klass model：</p>
</li>
</ul>
<h3 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h3><p>一个Klass对象代表一个类的元数据（相当于java.lang.Class对象）。它提供：<br>language level class object (method dictionary etc.)<br>provide vm dispatch behavior for the object</p>
<p>所有的函数都被整合到一个C++类中。<br>Klass对象的继承关系：xxxKlass &lt;:&lt; Klass &lt;:&lt; Metadata &lt;:&lt; MetaspaceObj</p>
<p>klass对象的布局如下：<br>来自klass.hpp</p>
<pre><code>// A Klass is the part of the klassOop that provides:
//  1: language level class object (method dictionary etc.)
//  2: provide vm dispatch behavior for the object
// Both functions are combined into one C++ class. The toplevel class &quot;Klass&quot;
// implements purpose 1 whereas all subclasses provide extra virtual functions
// for purpose 2.

// One reason for the oop/klass dichotomy in the implementation is
// that we don&#39;t want a C++ vtbl pointer in every object.  Thus,
// normal oops don&#39;t have any virtual functions.  Instead, they
// forward all &quot;virtual&quot; functions to their klass, which does have
// a vtbl and does the C++ dispatch depending on the object&#39;s
// actual type.  (See oop.inline.hpp for some of the forwarding code.)
// ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!

//  Klass layout:
//    [header        ] klassOop
//    [klass pointer ] klassOop
//    [C++ vtbl ptr  ] (contained in Klass_vtbl)
//    [layout_helper ]
//    [super_check_offset   ] for fast subtype checks
//    [secondary_super_cache] for fast subtype checks
//    [secondary_supers     ] array of 2ndary supertypes
//    [primary_supers 0]
//    [primary_supers 1]
//    [primary_supers 2]
//    ...
//    [primary_supers 7]
//    [java_mirror   ]
//    [super         ]
//    [name          ]
//    [first subklass]
//    [next_sibling  ] link to chain additional subklasses
//    [modifier_flags]
//    [access_flags  ]
//    [verify_count  ] - not in product
//    [alloc_count   ]
//    [last_biased_lock_bulk_revocation_time] (64 bits)
//    [prototype_header]
//    [biased_lock_revocation_count]
</code></pre>
<h3 id="oop"><a href="#oop" class="headerlink" title="oop"></a>oop</h3><p>oop类型其实是oopDesc*。在Java程序运行的过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的oop对象。各种oop类的共同基类为oopDesc类。</p>
<p>JVM内部，一个Java对象在内存中的布局可以连续分成两部分：instanceOopDesc和实例数据。instanceOopDesc和arrayOopDesc又称为对象头。</p>
<p>instanceOopDesc对象头包含两部分信息：Mark Word 和 元数据指针(Klass*)：</p>
<pre><code>// from oop.hpp
// oopDesc is abstract.
// (see oopHierarchy for complete oop class hierarchy)
class oopDesc &#123;
  friend class VMStructs;
 private:
  volatile markOop  _mark;  // mark word
  union _metadata &#123;    // metadata
    wideKlassOop    _klass;
    narrowOop       _compressed_klass;
  &#125; _metadata;
  ...
</code></pre>
<ul>
<li>Mark word: // 存储对象的hashCode或锁信息等。</li>
<li>Klass*  // 存储到对象类型数据的指针</li>
</ul>
<h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><h3 id="C-vtbl-pointer："><a href="#C-vtbl-pointer：" class="headerlink" title="C++ vtbl pointer："></a>C++ vtbl pointer：</h3><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>ss</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5zY3p5aDMwLmNvbS9wb3N0cy9KYXZhL2p2bS1rbGFzcy1vb3Av">深入探究JVM | klass-oop对象模型研究<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>jvm</category>
        <category>HotSpot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hotspot</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>java系列 - class文件</title>
    <url>/pub/718175b8/</url>
    <content><![CDATA[<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>目的：完整分析class文件。</p>
<h2 id="java源码"><a href="#java源码" class="headerlink" title="java源码"></a>java源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		; <span class="comment">// Loop body is empty</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h2><p>编译得到MyTest.class。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 16进制查看文件</span></span><br><span class="line">vim -b SimpleClass.class</span><br><span class="line"><span class="comment"># 16进制和ascii码对应的显示结果</span></span><br><span class="line">hexdump -C SimpleClass.class</span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cafe babe  | 0000   0033      000c                   </span><br><span class="line">magic num  | minor0  major51  常量池计数器11+1=12  </span><br><span class="line"></span><br><span class="line">//////////// 常量池 /////////////</span><br><span class="line"></span><br><span class="line"><span class="comment">#1  07     0002</span></span><br><span class="line">	class  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2	01     0012         4d79 5465 7374 2f53 696d 706c 6543 6c61 7373  </span></span><br><span class="line">	utf8   length=18    MyTest/SimpleClass                            |  |</span><br><span class="line"></span><br><span class="line"><span class="comment">#3	07     0004  </span></span><br><span class="line">	class  <span class="comment">#4           // java/lang/Object   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4	01     0010         6a61 7661 2f6c 616e 672f 4f62 6a65 6374 |</span></span><br><span class="line">	utf8   lengh16      java/lang/Object                        |</span><br><span class="line"></span><br><span class="line"><span class="comment">#5	01     0006         3c 696e 6974 3e     </span></span><br><span class="line">	utf8   length=6     &lt;init&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#6	01     0003         2829 56</span></span><br><span class="line">	utf8   length=3     ()V</span><br><span class="line"></span><br><span class="line"><span class="comment">#7	01     0004         436f 6465</span></span><br><span class="line">	utf8   length=3     Code</span><br><span class="line"></span><br><span class="line"><span class="comment">#8	0a     000300       09</span></span><br><span class="line">	md_ref <span class="comment">#3.          #9  //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9	0c     0005         0006</span></span><br><span class="line">	nam&amp;ty <span class="comment">#5           #6   //  &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10	01     0003         64 6664</span></span><br><span class="line">	utf8   length=3     dfd</span><br><span class="line"></span><br><span class="line"><span class="comment">#11	01     000d         53 7461 636b 4d61 7054 6162 6c65</span></span><br><span class="line">	utf8   length=13    StackMapTable</span><br><span class="line"></span><br><span class="line">//////////// 常量池 /////////////</span><br><span class="line"></span><br><span class="line">0021               0001         0003</span><br><span class="line">可能是public       <span class="comment">#1 类索引    #3 父类索引</span></span><br><span class="line"></span><br><span class="line">// 0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。</span><br><span class="line"></span><br><span class="line">0000            </span><br><span class="line">接口计数器      接口表</span><br><span class="line"></span><br><span class="line">0000       </span><br><span class="line">fields_count</span><br><span class="line"></span><br><span class="line">0002</span><br><span class="line">methods_count</span><br><span class="line"></span><br><span class="line">//////////////// 第一个method void &lt;init&gt;  ///////////</span><br><span class="line"></span><br><span class="line">0001     0005       0006</span><br><span class="line">public   <span class="comment">#5&lt;init&gt;   #6()V      其值为()V，表示&lt;init&gt;方法没有参数和返回值, 其实这是编译器自动生成 的实例构造器方法</span></span><br><span class="line"></span><br><span class="line">0001            </span><br><span class="line">attrib_count    </span><br><span class="line"></span><br><span class="line">0007        00000011     0001       0001        00000005     2ab70008b1  0000                    0000</span><br><span class="line"><span class="comment">#7Code属性  attrib_len   max_stack  max_locals  code_length  code[]      exception_table_length  attribute_count</span></span><br><span class="line">// 代码是存储在Class文件中的method的code属性的code[]数组中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//////////////// 第二个method dfd()  ///////////</span><br><span class="line"></span><br><span class="line">0000              000a     0006</span><br><span class="line">没写access_flag   <span class="comment">#10,dfd  ()V</span></span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">attrib_count</span><br><span class="line"></span><br><span class="line">0007        00000028       0002       0002        0000000f          033ca700068401011b1064a1fffab1  </span><br><span class="line"><span class="comment">#7Code属性  属性表的长度   max_stack  max_locals  code_length=15    code[]，解析见《jvm spec》41页</span></span><br><span class="line"></span><br><span class="line">0000</span><br><span class="line">exception_table_length</span><br><span class="line"></span><br><span class="line">0001</span><br><span class="line">attribute_count</span><br><span class="line"></span><br><span class="line">000b                  00000007   0002              fc00 0501 0200 00</span><br><span class="line"><span class="comment">#11:StackMapTable     length     num_of_entries    7个length的stack_map_frame</span></span><br></pre></td></tr></table></figure>




<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>.和：是怎么区分的？</p>
<h2 id="其他阅读"><a href="#其他阅读" class="headerlink" title="其他阅读"></a>其他阅读</h2><p><span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5jbi9hcnRpY2xlcy85MjI5Lmh0bWw=">http://coolshell.cn/articles/9229.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>jvm</category>
        <category>编译与反编译</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】random的源码实现</title>
    <url>/pub/6b34bb62/</url>
    <content><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><ul>
<li>Math.random()方法来产生一个随机数，这个产生的随机数是0-1之间的一个double</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="生成从1到10的int型随机数"><a href="#生成从1到10的int型随机数" class="headerlink" title="生成从1到10的int型随机数"></a>生成从1到10的int型随机数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)(<span class="number">1</span>+Math.random()*(<span class="number">10</span>-<span class="number">1</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二:</span></span><br><span class="line"><span class="keyword">int</span> i = random.nextInt(<span class="number">99</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="主要涉及的类"><a href="#主要涉及的类" class="headerlink" title="主要涉及的类"></a>主要涉及的类</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazh1L2pkazh1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvUmFuZG9tLmphdmE=">java.util.Random<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Random从Jdk 1.0开始就有了，而<code>ThreadLocalRandom</code>是Jdk1.7才新增的。简单从命名和类所在的包上看，两者的区别在于对并发的支持。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>lang</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java源码</tag>
        <tag>random</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>【java源码系列】 - String</title>
    <url>/pub/2a8bf999/</url>
    <content><![CDATA[<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>String s = “abc”,并没有在堆上生成对象<br>Object o = new Object() 对应字节码为:</p>
<pre><code>0: new           #2                  // class java/lang/Object
3: dup           
4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
7: astore_1   
</code></pre>
<p>String s = “abc” 对应字节码为:</p>
<pre><code>0: ldc           #2                  // String abc
2: astore_1  
</code></pre>
<p>String s = new String() 对应字节码为:</p>
<pre><code>0: new           #2                  // class java/lang/String
3: dup           
4: invokespecial #3                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:()V
7: astore_1  
</code></pre>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>lang</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>【java源码系列】 - System</title>
    <url>/pub/7d785abb/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java.lang.System.java</p>
<h2 id="跟踪arraycopy"><a href="#跟踪arraycopy" class="headerlink" title="跟踪arraycopy"></a>跟踪arraycopy</h2><p>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);</p>
<h3 id="System-c"><a href="#System-c" class="headerlink" title="System.c"></a>System.c</h3><pre><code>// jdk/src/share/native/java/lang/System.c

/* Only register the performance-critical methods */
static JNINativeMethod methods[] = &#123;
    &#123;&quot;currentTimeMillis&quot;, &quot;()J&quot;,              (void *)&amp;JVM_CurrentTimeMillis&#125;,
    &#123;&quot;nanoTime&quot;,          &quot;()J&quot;,              (void *)&amp;JVM_NanoTime&#125;,
    &#123;&quot;arraycopy&quot;,     &quot;(&quot; OBJ &quot;I&quot; OBJ &quot;II)V&quot;, (void *)&amp;JVM_ArrayCopy&#125;,
&#125;;
</code></pre>
<h3 id="jvm-cpp"><a href="#jvm-cpp" class="headerlink" title="jvm.cpp"></a>jvm.cpp</h3><pre><code>// src/share/vm/prims/jvm.cpp

JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
                               jobject dst, jint dst_pos, jint length))
  JVMWrapper(&quot;JVM_ArrayCopy&quot;);
  // Check if we have null pointers
  if (src == NULL || dst == NULL) &#123;
    THROW(vmSymbols::java_lang_NullPointerException());
  &#125;
  arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
  arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
  assert(s-&gt;is_oop(), &quot;JVM_ArrayCopy: src not an oop&quot;);
  assert(d-&gt;is_oop(), &quot;JVM_ArrayCopy: dst not an oop&quot;);
  // Do copy
  Klass::cast(s-&gt;klass())-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
JVM_END
</code></pre>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】HashMap</title>
    <url>/pub/1b7bcecc/</url>
    <content><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><ul>
<li>java 1.0 中没有HashMap，有<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JpdE1pbmRMYWIvSkRLLTEuMC4yL2Jsb2IvbWFzdGVyL3NyYy9qYXZhL3V0aWwvSGFzaHRhYmxlLmphdmE=">HashTable<i class="fa fa-external-link-alt"></i></span></li>
<li>java 1.2 引入HashMap</li>
<li>java 7 基于哈希表的实现</li>
<li>java 8 采用的</li>
</ul>
<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>


<h2 id="hash过程"><a href="#hash过程" class="headerlink" title="hash过程"></a>hash过程</h2><p>流程</p>
<ol>
<li>对key计算hashcode</li>
<li>将hashcode映射到有限bucket空间</li>
<li>在相应的bucket内，存储或查询相应的key</li>
</ol>
<h3 id="计算hashcode"><a href="#计算hashcode" class="headerlink" title="计算hashcode"></a>计算hashcode</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazd1L2pkazd1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZhI0wzNTY=">java7<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k); <span class="comment">// 麻蛋</span></span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();  <span class="comment">// 按位异或</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);  <span class="comment">// “扰动函数”。Java 8中这步已经简化了，只做一次16位右位移异或混合，而不是四次，但原理是不变的。</span></span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>); <span class="comment">// &gt;&gt;&gt; 无符号右移运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础知识:</p>
<ol>
<li><code>hashSeed</code> 随机数的种子，详见..</li>
<li><code>^</code> 按位异或。作用:</li>
<li><code>&gt;&gt;&gt;</code>  无符号右移运算符<br>左移的规则：丢弃高位，0补低位<br>右移的规则：丢弃低位，高位的空位补符号位，即正数补零，负数补1</li>
</ol>
<p>右移的偏移量20，12，7，4是怎么来的呢？因为Java中对象的哈希值都是32位的，所以这几个数应该<br>就是把高位与低位做异或运算，</p>
<p>再看一下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazh1L2pkazh1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL2xhbmcvU3RyaW5nLmphdmEjTDE0NjU=">String类中hashcode的计算<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];  <span class="comment">// 为什么取素数？为什么取31？</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在存储数据计算hash地址的时候，我们希望尽量减少有同样的hash地址，所谓“冲突”。如果使用相同hash地址的数据过多，那么这些数据所组成的 hash链就更长，从而降低了查询效率！所以在选择系数的时候要选择尽量长的系数并且让乘法尽量不要溢出的系数，因为如果计算出来的hash地址越大，所 谓的“冲突”就越少，查找起来效率也会提高。</p>
<p>使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！</p>
<p>在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失.<br>而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因不过与此！</p>
<h3 id="分配hashcode到bucket"><a href="#分配hashcode到bucket" class="headerlink" title="分配hashcode到bucket"></a>分配hashcode到bucket</h3><p>hashcode的取值空间太大，不能作为直接存储地址。因此要把hashcode分配到一定数量的bucket中，取值<code>[0, capacity‐1]</code>。</p>
<p>为了使每个key都能在冲突最小的情况下映射到[0,capacity)，通常有两种做法：</p>
<ol>
<li>capacity为素数，<code>index = hashCode(key) mod capacity</code></li>
<li>capacity为2的倍数，<code>index = hashCode(key) &amp; (capacity‐1)</code></li>
</ol>
<p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazd1L2pkazd1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZhI0wzNzQ=">java7中<i class="fa fa-external-link-alt"></i></span></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 16</span></span><br><span class="line">index = hashCode(key) &amp; (capacity‐<span class="number">1</span>); <span class="comment">// 映射到0,capacity-1之间(类似mod)  </span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>普通的哈希算法（也称硬哈希）采用简单取模的方式，将机器进行散列，这在cache环境不变的情况下能取得让人满意的结果，但是当<strong>cache环境动态变化</strong>时，这种静态取模的方式显然就不满足单调性的要求（当增加或减少一台机子时，几乎所有的存储内容都要被<strong>重新散列到别的缓冲区</strong>中）。</p>
</blockquote>
<h3 id="存储或查询-get-put"><a href="#存储或查询-get-put" class="headerlink" title="存储或查询 (get put)"></a>存储或查询 (get put)</h3><p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazd1L2pkazd1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZhI0w0NTc=">java7的get<i class="fa fa-external-link-alt"></i></span></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/dmlloyd/openjdk/blob/jdk7u/jdk7u/jdk/src/share/classes/java/util/HashMap.java#L486"><strong>java7的put</strong></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p><a href="https://github.com/dmlloyd/openjdk/blob/jdk7u/jdk7u/jdk/src/share/classes/java/util/HashMap.java#L572"><strong>java7的rehash</strong></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">// 创建新的entry array</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度？</p>
<p>一致性？</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//  默认的平衡因子为0.75。过高的因子会降低存储空间但是查找的时间就会增加。</span></span><br><span class="line"><span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;   <span class="comment">// 哈希表容量（也就是buckets或slots大小）</span></span><br><span class="line"><span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>NUll keys always map to hash 0, thus index 0</p>
<h1 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h1><ul>
<li>Hashtable</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>EnumMap</li>
</ul>
<h2 id="VS-Hashtable"><a href="#VS-Hashtable" class="headerlink" title="VS Hashtable"></a>VS Hashtable</h2><p>HashMap 不是线程安全的</p>
<p><strong>HashMap 是 HashTable 的轻量级实现</strong>，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value，由于非线程安全，效率上可能高于 Hashtable。</p>
<h2 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h2><h1 id="revisit"><a href="#revisit" class="headerlink" title="revisit"></a>revisit</h1><p>设计</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazd1L2pkazd1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZh">HashMap.java | java7<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtbGxveWQvb3Blbmpkay9ibG9iL2pkazh1L2pkazh1L2pkay9zcmMvc2hhcmUvY2xhc3Nlcy9qYXZhL3V0aWwvSGFzaE1hcC5qYXZh">HashMap.java | java8<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ul>
<li>hashcode的计算？</li>
<li>Null key的处理？为什么</li>
<li>常量<ul>
<li>modCount的作用？</li>
<li>loadFactor的作用？</li>
<li>为什么容量必须为2的指数倍（默认为16）？</li>
<li>超容后，reshash的复杂度是多少？怎样降低复杂度？怎样保证一致性？</li>
<li>容量超过<code>Integer.MAX_VALUE</code>怎么办？</li>
<li>hashSeed的影响？</li>
</ul>
</li>
<li>并发的影响？见</li>
<li>如何做到key的排序？见</li>
<li>为什么放到util呢？ Map类的操作对象是其他类，所以也属于工具类。当然也可以理解为普通类(封装类、组合类)</li>
</ul>
<blockquote>
<p>答案在文中寻找</p>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>【java源码系列】Collection Framework</title>
    <url>/pub/aca7a464/</url>
    <content><![CDATA[<h2 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Collection</span><br><span class="line">├List</span><br><span class="line">│├ArrayList</span><br><span class="line">│├LinkedList</span><br><span class="line">│└Vector</span><br><span class="line">│　└Stack   <span class="comment"># 实现了栈的基本操作，由于涉及不够规范，目前极少使用。使用queue接口的相关实现可以完全取代它</span></span><br><span class="line">├PriorityQueue</span><br><span class="line">├Set</span><br><span class="line">│├EnumSet 	 </span><br><span class="line">│├HashSet</span><br><span class="line">│├LinkedHashSet</span><br><span class="line">│├TreeSet</span><br><span class="line">└ArrayDeque</span><br></pre></td></tr></table></figure>





<p><img title="java collection framework的架构" src="/images/raw/Java - diagram - java.util.Collection - skywang.jpg"></img></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC8zMzA4NDk4Lmh0bWw=">http://www.cnblogs.com/skywang12345/p/3308498.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h2><table>
<thead>
<tr>
<th align="left">类</th>
<th align="right">同步(线程安全)</th>
<th align="right">随机访问</th>
<th align="right">快速增删</th>
<th align="right">存储空间</th>
<th align="right">复杂度：增删改查，containsValue</th>
<th align="center">其他语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="right">..</td>
<td align="right">Yes</td>
<td align="right">O()</td>
<td align="right">最小</td>
<td align="right"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">ArrayList</td>
<td align="right">..</td>
<td align="right">Yes</td>
<td align="right">O()</td>
<td align="right">小</td>
<td align="right">.</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">LinkedList</td>
<td align="right">..</td>
<td align="right">No</td>
<td align="right">O()</td>
<td align="right">大</td>
<td align="right">.</td>
<td align="center">redis中的list采用双向链表实现</td>
</tr>
<tr>
<td align="left">Vector</td>
<td align="right">..</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Stack</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>class Stack<E> extends Vector<E><br>interface Queue<E> extends Collection<E></p>
<h2 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h2><p>排队：秒杀。FIFO，<br>消息队列：<br>频繁插入：采用linkedList</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>collection</tag>
      </tags>
  </entry>
  <entry>
    <title>python deque双向队列</title>
    <url>/pub/c18b237c/</url>
    <content><![CDATA[<p>Python标准库中包含了四种队列，分别是<code>queue.Queue</code>、<code>asyncio.Queue</code>、<code>multiprocessing.Queue</code>、<code>collections.deque</code>。<br>可见deque是标准库collections中的</p>
<p>Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。<br>Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。</p>
<p>虽然 list 对象也支持类似操作，不过这里优化了定长操作和 pop(0) 和 insert(0, v) 的开销。<br>它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。</p>
<p>如果 maxlen 没有指定或者是 None ，deques 可以增长到任意长度。<br>否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。<br>限定长度deque提供类似Unix filter tail 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。</p>
<p>deque还支持迭代，清洗，len(d), reversed(d), copy.copy(d), copy.deepcopy(d), 成员测试 in 操作符，<br>和下标引用 d[-1] 。索引存取在两端的复杂度是 O(1)， 在中间的复杂度比 O(n) 略低。要快速存取，使用list来替代。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Data for deque objects is stored in a doubly-linked list of fixed<br>length blocks.  This assures that appends or pops never move any<br>other data elements besides the one being appended or popped.</p>
<p>关键</p>
<ol>
<li>fixed length blocks 好像能减少内存</li>
<li></li>
</ol>
<p><a href="cpython/Modules/_collectionsmodule.c">_collectionsmodule.c</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BLOCK &#123;</span><br><span class="line">    struct BLOCK *leftlink;</span><br><span class="line">    PyObject *data[BLOCKLEN];</span><br><span class="line">    struct BLOCK *rightlink;</span><br><span class="line">&#125; block;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    block *leftblock;</span><br><span class="line">    block *rightblock;   </span><br><span class="line">    Py_ssize_t leftindex;       /* 0 &lt;= leftindex &lt; BLOCKLEN */</span><br><span class="line">    Py_ssize_t rightindex;      /* 0 &lt;= rightindex &lt; BLOCKLEN */</span><br><span class="line">    size_t state;               /* incremented whenever the indices move */</span><br><span class="line">    Py_ssize_t maxlen;          /* maxlen is -1 for unbounded deques */</span><br><span class="line">    PyObject *weakreflist;</span><br><span class="line">&#125; dequeobject;</span><br></pre></td></tr></table></figure>

<p>leftindex 是干嘛的？</p>
<h2 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>cpython源码</category>
        <category>collections</category>
        <category>deque</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】Map</title>
    <url>/pub/8748fd7b/</url>
    <content><![CDATA[<h1 id="diagram，java设计架构"><a href="#diagram，java设计架构" class="headerlink" title="diagram，java设计架构"></a>diagram，java设计架构</h1><p>来自网络 <span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC8zMzA4OTMxLmh0bWw=">http://www.cnblogs.com/skywang12345/p/3308931.html<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/images/raw/Java - diagram - java.util.Map - skywang.jpg"></img></p>
<p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。</p>
<p><img src="/images/raw/Java - diagram - java.util.Map - xusong.svg"></img></p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><table>
<thead>
<tr>
<th>类</th>
<th align="right">同步(线程安全)</th>
<th align="right">order</th>
<th align="right">null key</th>
<th>null value</th>
<th align="right">implementation</th>
<th align="right">增删查改(按key)</th>
<th>查(按value) containsValue</th>
<th>C</th>
<th align="center">C++(STL)</th>
<th>python</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td align="right">×</td>
<td align="right">无序</td>
<td align="right">√</td>
<td>√</td>
<td align="right">hash table （采用seperate chaining解决键冲突）java8采用了哈希表与红黑树结合的方法</td>
<td align="right">O(1)</td>
<td>顺序查找 O(n)</td>
<td>比如redis的实现</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>LinkedHashmap</td>
<td align="right">×</td>
<td align="right">按插入顺序排序</td>
<td align="right">√</td>
<td>√</td>
<td align="right">同上</td>
<td align="right"></td>
<td></td>
<td></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>Hashtable</td>
<td align="right">√</td>
<td align="right">无序</td>
<td align="right">×</td>
<td>×</td>
<td align="right">同上</td>
<td align="right"></td>
<td></td>
<td></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>TreeMap</td>
<td align="right"></td>
<td align="right">按key自定义排序</td>
<td align="right"></td>
<td></td>
<td align="right">红黑树</td>
<td align="right">O(log n)</td>
<td></td>
<td></td>
<td align="center"></td>
<td>无</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td></td>
<td></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>EnumMap</td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td></td>
<td align="right"></td>
<td align="right"></td>
<td></td>
<td></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>
<li>HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
</ul>
<blockquote>
<p>sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。<br>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。<br> 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p>
</blockquote>
<p>有没有既linked，又线程安全的Map，答案没有。因为多个线程同时操作，不同的执行顺序会产生不同的结果。所以linked的东东都应该不存在线程安全性。不能加锁吗？ –by xs</p>
<h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>HashTable使用Enumeration，HashMap使用Iterator。<br>HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<p>6.哈希值的使用不同，HashTable直接使用对象的hashCode，代码是这样的：<br>int hash = key.hashCode();<br>int index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>而HashMap重新计算hash值，而且用与代替求模：<br>int hash = hash(k);<br>int i = indexFor(hash, table.length);</p>
<p>static int hash(Object x) {<br>　　int h = x.hashCode();</p>
<p>　　h += ~(h &lt;&lt; 9);<br>　　h ^= (h &gt;&gt;&gt; 14);<br>　　h += (h &lt;&lt; 4);<br>　　h ^= (h &gt;&gt;&gt; 10);<br>　　return h;<br>}<br>static int indexFor(int h, int length) {<br>　　return h &amp; (length-1);<br>}<br>以上只是一些比较突出的区别，当然他们的实现上还是有很多不同的，比如<br>HashMap对null的操作</p>
<h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1>]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Python List 对象</title>
    <url>/pub/b6e91a25/</url>
    <content><![CDATA[<p>List跟Java的ArrayList、STL中的vector相似。</p>
<p>在Python中的list可以存放任何类型的数据，查看PyListObject可以发现，list实际存放的是PyObject* 指针</p>
<h2 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h2><p>list对象是一个变长对象，在运行时动态调整其所维护的内存和元素，并且支持插入删除等操作，list的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyVarObject ob_base;   <span class="comment">// 即 PyObject_VAR_HEAD</span></span><br><span class="line">    PyObject **ob_item;    <span class="comment">// 数组</span></span><br><span class="line">    Py_ssize_t allocated;  <span class="comment">// 可容纳元素的总数，0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p>注意<br>self-&gt;ob_base-&gt;ob_size<br>self-&gt;ob_base-&gt;ob_base</p>
<p>其中，ob_size就是list实际拥有的元素数量，allocated指的是实际申请的内存空间，<br>比如列表A实际申请了5元素的空间，但是此时A只包含了2个元素，则ob_size为2，allocated为5。</p>
<p>图的结构对，但是少了个小写的对象ob_base</p>
<h3 id="List的创建和初始化"><a href="#List的创建和初始化" class="headerlink" title="List的创建和初始化"></a>List的创建和初始化</h3><p>PyList_New 创建对象</p>
<p>为了避免频繁的申请内存空间，创建PyListObject的时候会先检查缓冲池是否有可用空间.</p>
<h3 id="list-resize-调整list存储空间"><a href="#list-resize-调整list存储空间" class="headerlink" title="list_resize 调整list存储空间"></a>list_resize 调整list存储空间</h3><p>随着list元素的增加，list的存储空间可能会不够用，这个时候就需要扩大list的存储空间。<br>随着list元素的减少，list的存储空间可能存在冗余，这个时候就需要缩小list的存储空间。<br>函数<code>list_resize</code>就是用于调节list存储空间大小的</p>
<p>当 <code>allocated/2 &lt;= newsize &lt;= allocated</code> 时，list_resize只会改变 ob_size不会改变allocated。<br>其他情况则需要调用<code>PyMem_Realloc</code>函数分配新的空间存储列表元素。</p>
<p>列表allocated的增长模式是 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, …</p>
<p>其公式为 <code>new_allocated = (size_t)newsize + (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6)</code></p>
<p>后面更改为：</p>
<h2 id="插入、删除"><a href="#插入、删除" class="headerlink" title="插入、删除"></a>插入、删除</h2><p>List的添加和删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append       # 追加元素 PyList_Append</span><br><span class="line">pop</span><br><span class="line">remove       # 移除元素 list_remove</span><br><span class="line">insert       # 插入元素 PyList_Insert</span><br><span class="line">a[1:3]=&#x27;&#x27;    # list_ass_slice</span><br></pre></td></tr></table></figure>


<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>PyListObject对象的其他常见操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 创建PyListObject PyList_New</span><br><span class="line">- 对象赋值 PyList_SetItem</span><br><span class="line">- 获取元素 PyList_GetItem</span><br><span class="line">- 调整list大小 list_resize</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5L2FydGljbGUvZGV0YWlscy84MTgwNzA5Ng==">https://blog.csdn.net/qq_33339479/article/details/81807096<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>cpython源码</category>
        <category>objects</category>
        <category>list</category>
      </categories>
  </entry>
  <entry>
    <title>Python 整数对象</title>
    <url>/pub/a3ffad4e/</url>
    <content><![CDATA[<p>Python2 的整数对象 有 <code>PyIntObject</code> 和 <code>PyLongObject</code> 这两种类型，Python3 只保留了 <code>PyLongObject</code>。<br>这里我们介绍一下python3的<code>PyLongObject</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="number">3.7</span><span class="number">.3</span> (default, Mar <span class="number">27</span> <span class="number">2019</span>, <span class="number">22</span>:<span class="number">11</span>:<span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 小整数</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>


<h2 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name , 在python2中是long */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    ...</span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到，PyLong_Type类型对象的tp_name就是int，也就是说，在Python内部，它就是int类型。</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvbG9uZ29iamVjdC5oI0wxMA==">Include/longobject.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// longobject.h</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvbG9uZ2ludHJlcHIuaCNMODU=">Include/longintrepr.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* longobject.h  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* longintrepr.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyVarObject ob_base;   <span class="comment">// 即 PyObject_VAR_HEAD</span></span><br><span class="line">    digit ob_digit[<span class="number">1</span>];     <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出 PyLongObject 是变长对象</p>
<h2 id="类型对象-PyLong-Type"><a href="#类型对象-PyLong-Type" class="headerlink" title="类型对象 PyLong_Type"></a>类型对象 PyLong_Type</h2><p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0w1Mzc5">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="创建整数对象"><a href="#创建整数对象" class="headerlink" title="创建整数对象"></a>创建整数对象</h2><p>从 PyLong_Type 可以看出，创建一个整数对象的入口函数为 long_new</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvY2xpbmljL2xvbmdvYmplY3QuYy5oI0ww">Objects/clinic/longobject.c.h<i class="fa fa-external-link-alt"></i></span></p>
<p>从 long_new_impl 函数可以看出有如下几种情况</p>
<ul>
<li>x == NULL 且 obase != NULL 调用 PyLong_FromLong</li>
<li>obase 为 NULL 调用 PyNumber_Long</li>
<li>x 和 obase 都不为 NULL<ul>
<li>PyUnicode 调用 PyLong_FromUnicodeObject，最终调用 PyLong_FromString</li>
<li>PyByteArray/PyBytes 调用_PyLong_FromBytes，最终调用 PyLong_FromString</li>
</ul>
</li>
</ul>
<h2 id="小整数对象"><a href="#小整数对象" class="headerlink" title="小整数对象"></a>小整数对象</h2><p>一些整数在一开始就会被初始化一直留存，当再次使用直接从小整数对象池中获取，不用频繁的申请内存。</p>
<p>默认的小整数范围是 [-5, 257) 源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wxNw==">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<p>get_small_int</p>
<p>宏 <strong>CHECK_SMALL_INT</strong> 会检查传入的数是否在小整数范围内，如果是直接返回。<br>可以在创建或复制整数对象等函数中找到 <strong>CHECK_SMALL_INT</strong> 的身影，以下只列出了<br><strong>PyLong_FromLong</strong>，就不一一列举了</p>
<h3 id="小整数初始化"><a href="#小整数初始化" class="headerlink" title="小整数初始化"></a>小整数初始化</h3><p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0w1NDYy">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<p><code>_PyLong_Init</code></p>
<h2 id="整数的存储结构"><a href="#整数的存储结构" class="headerlink" title="整数的存储结构"></a>整数的存储结构</h2><p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wxNTgx">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<p>在 <strong>long_to_decimal_string_internal</strong>中添加如下代码并重新编译安装</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">long_to_decimal_string_internal</span><span class="params">(PyObject *aa,</span></span></span><br><span class="line"><span class="params"><span class="function">                                PyObject **p_output,</span></span></span><br><span class="line"><span class="params"><span class="function">                                _PyUnicodeWriter *writer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                _PyBytesWriter *bytes_writer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">char</span> **bytes_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyLongObject *scratch, *a;</span><br><span class="line">    PyObject *str = <span class="literal">NULL</span>;</span><br><span class="line">    Py_ssize_t size, <span class="built_in">strlen</span>, size_a, i, j;</span><br><span class="line">    digit *pout, *pin, rem, tenpow;</span><br><span class="line">    <span class="keyword">int</span> negative;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PyUnicode_Kind</span> <span class="title">kind</span>;</span></span><br><span class="line"></span><br><span class="line">    a = (PyLongObject *)aa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加打印代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ob_size     = %d\n&quot;</span>, Py_SIZE(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; Py_SIZE(a); ++index) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ob_digit[%d] = %d\n&quot;</span>, index, a-&gt;ob_digit[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译安装后进入 python 解释器输入如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">9223372043297226753</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ob_size     = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ob_digit[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ob_digit[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ob_digit[<span class="number">2</span>] = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9223372043297226753</span></span><br></pre></td></tr></table></figure>

<p>如下图所示</p>
<p><img src="long-storage.png" alt="longobject storage"></p>
<p>注：这里的 30 是由 <strong>PyLong_SHIFT</strong> 决定的，64 位系统中，<strong>PyLong_SHIFT</strong> 为 30，否则 <strong>PyLong_SHIFT</strong> 为 15</p>
<h2 id="整数对象的数值操作"><a href="#整数对象的数值操作" class="headerlink" title="整数对象的数值操作"></a>整数对象的数值操作</h2><h3 id="整数相加"><a href="#整数相加" class="headerlink" title="整数相加"></a>整数相加</h3><p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wzMDgx">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<p>long_add</p>
<p>可以看到整数的加法运算函数 long_add 根据 a、b 的 ob_size 又细分为两个函数 (x_add 和 x_sub) 做处理</p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wyOTkx">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the absolute values of two integers. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyLongObject *</span></span><br><span class="line"><span class="function"><span class="title">x_add</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    digit carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure a is the larger of the two: */</span></span><br><span class="line">    <span class="comment">// 确保 a 大于 b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z = _PyLong_New(size_a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        carry += a-&gt;ob_digit[i];</span><br><span class="line">        z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;</span><br><span class="line">        carry &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;ob_digit[i] = carry;</span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加法运算函数 x_add 从 ob_digit 数组的低位开始依次按位相加，carry 做进位处理，然后处理 a 对象的高位数字，最后使用 long_normalize 函数调整 ob_size，确保 ob_digit[abs(ob_size)-1]不为零，这与普通四则运算的加法运算相同，只不过进位单元不同而已</p>
<p><img src="long-x-add.png" alt="longobject x_add"></p>
<p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wzMDI1">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/longobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Subtract the absolute values of two integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyLongObject *</span></span><br><span class="line"><span class="function"><span class="title">x_sub</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));</span><br><span class="line">    PyLongObject *z;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    digit borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure a is the larger of the two: */</span></span><br><span class="line">    <span class="comment">// 确保 a 大于 b</span></span><br><span class="line">    <span class="keyword">if</span> (size_a &lt; size_b) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#123; Py_ssize_t size_temp = size_a;</span><br><span class="line">            size_a = size_b;</span><br><span class="line">            size_b = size_temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_a == size_b) &#123;</span><br><span class="line">        <span class="comment">/* Find highest digit where a and b differ: */</span></span><br><span class="line">        <span class="comment">// 找到最高位 a 与 b的差异</span></span><br><span class="line">        i = size_a;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; a-&gt;ob_digit[i] == b-&gt;ob_digit[i])</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;ob_digit[i] &lt; b-&gt;ob_digit[i]) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            &#123; PyLongObject *temp = a; a = b; b = temp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size_a = size_b = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    z = _PyLong_New(size_a);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_b; ++i) &#123;</span><br><span class="line">        <span class="comment">/* The following assumes unsigned arithmetic</span></span><br><span class="line"><span class="comment">           works module 2**N for some N&gt;PyLong_SHIFT. */</span></span><br><span class="line">        borrow = a-&gt;ob_digit[i] - b-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; <span class="comment">/* Keep only one sign bit */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size_a; ++i) &#123;</span><br><span class="line">        borrow = a-&gt;ob_digit[i] - borrow;</span><br><span class="line">        z-&gt;ob_digit[i] = borrow &amp; PyLong_MASK;</span><br><span class="line">        borrow &gt;&gt;= PyLong_SHIFT;</span><br><span class="line">        borrow &amp;= <span class="number">1</span>; <span class="comment">/* Keep only one sign bit */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(borrow == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_SIZE(z) = -Py_SIZE(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> long_normalize(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与普通四则运算减法相同，数不够大则向高一位借位，<br>减法运算函数 x_sub 的示例图如下，注：PyLong_SHIFT 为 30</p>
<p><img src="long-x-sub.png" alt="longobject x_sub"></p>
<h3 id="整数相乘"><a href="#整数相乘" class="headerlink" title="整数相乘"></a>整数相乘</h3><p>源文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wzNTQ3">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span></p>
<p>long_mul</p>
<p>k_mul 函数是一种快速乘法 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wzMjY4">源文件<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Karatsuba 的算法主要是用于两个大数的乘法，极大提高了运算效率，相较于普通乘法降低了复杂度，并在其中运用了递归的思想。<br>基本的原理和做法是将位数很多的两个大数 x 和 y 分成位数较少的数，每个数都是原来 x 和 y 位数的一半。<br>这样处理之后，简化为做三次乘法，并附带少量的加法操作和移位操作。</p>
</blockquote>
<p>具体可以看 wiki <span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLWhhbnMvS2FyYXRzdWJhJUU3JUFFJTk3JUU2JUIzJTk1">Karatsuba 算法<i class="fa fa-external-link-alt"></i></span>的实现</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvbG9uZ29iamVjdC5jI0wz">Objects/longobject.c<i class="fa fa-external-link-alt"></i></span><br>的第三行有这么一句话 <code>XXX The functional organization of this file is terrible</code>，<br>而且这个注释在Python2.7版本中也有，并一直保留到最新版本master分支，看来是一段陈年往事。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>cpython源码</category>
        <category>objects</category>
        <category>long</category>
      </categories>
  </entry>
  <entry>
    <title>【比特币源码】交易 transaction</title>
    <url>/pub/fb455505/</url>
    <content><![CDATA[<h1 id="名词-术语"><a href="#名词-术语" class="headerlink" title="名词 术语"></a>名词 术语</h1><ul>
<li><strong>交易</strong>: 简单地说，交易指把⽐特币从⼀个地址转到另⼀个地址。更准确地说，⼀笔“交易”指⼀个经过签名运算的，表达价值转移的<br>数据结构。每⼀笔“交易”都经过⽐特币⽹络传输，由矿⼯节点收集并封包⾄区块中，永久保存在区块链某处。</li>
<li><strong>交易验证</strong>: 被验证成功的交易放入本地内存交易池中（Local Memory Tx Pool，交易池是存储在本地内存中，并不是存储在硬盘里，因此不同节点的两池内容可能有很大差别。原则是，要保证任何在<strong>本地内存交易池中的交易均是未确认的</strong>。</li>
<li><strong>交易确认</strong>: 当⼀项交易被区块收录时，我们可以说它有⼀次确认。矿⼯们在此区块之后每再产⽣⼀个区块，此项交易的确认数就再加⼀。当确认数达到六及以上时，通常认为这笔交易⽐较安全并难以逆转。<ul>
<li>确认数+1什么意思？</li>
</ul>
</li>
<li><strong>交易权重</strong>: 挨个打包进入到区块体中；优先处理权重最高的交易；偶尔会出现提示：”当前网路交易拥堵，建议提高交易费用”。正是因为按照优先级处理，所以在网络交易拥堵的时候，有可能造成<strong>低优先级的交易“永远”不会被打包</strong>。交易的权重大小取决于三个因素：1）交易创建时间越早；2）交易UTXO大小越大；3）交易费用越高，则权重越大。</li>
<li><strong>⼯作量证明</strong>: ⼯作量证明指通过有效计算得到的⼀⼩块数据。具体到⽐特币，矿⼯必须要在满⾜全⽹⽬标难度的情况下求解SHA256算法</li>
</ul>
<ul>
<li><strong>难度</strong>: 整个⽹络会通过调整“难度”这个变量来控制⽣成⼯作量证明所需要的计算⼒。难度怎样调整的，见。。</li>
<li><strong>难度⽬标</strong>: 使整个⽹络的计算⼒⼤致每10分钟产⽣⼀个区块所需要的难度数值即为难度⽬标。</li>
<li><strong>难度调整</strong>: 整个⽹络每产⽣2,106个区块后会根据之前2,106个区块的算⼒进⾏难度调整。</li>
</ul>
<h1 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h1><p>⽐特币交易是⽐特币系统中最重要的部分。根据⽐特币系统的设计原理，<strong>系统中任何其他的部分都是为了确保⽐特币交易可<br>以被⽣成、能在⽐特币⽹络中得以传播和通过验证，并最终添加⼊全球⽐特币交易总账簿</strong>（⽐特币区块链）。⽐特币交易的<br>本质是数据结构，这些数据结构中含有⽐特币交易参与者价值转移的相关信息。⽐特币区块链是全球复式记账总账簿，每个⽐特币交易都是在⽐特币区块链上的⼀个公开记录。</p>
<h1 id="比特币“交易打包”底层原理"><a href="#比特币“交易打包”底层原理" class="headerlink" title="比特币“交易打包”底层原理"></a>比特币“交易打包”底层原理</h1><h2 id="“挖矿”与“交易打包”"><a href="#“挖矿”与“交易打包”" class="headerlink" title="“挖矿”与“交易打包”"></a>“挖矿”与“交易打包”</h2><p>前文我们说到，所谓“挖矿”，就是生成一个最新“区块”的过程，“矿工”在该过程中，是为了获取比特币的奖励（经济驱动）；</p>
<p>这部分奖励分为两部分：比特币网络系统的CoinBase奖励  和 所打包的所有交易的交易费（交易费的作用下文会介绍）；</p>
<p>那么，交易打包的过程和底层原理是什么呢？下文我们将图文展示整个交易打包的细节；</p>
<h2 id="“交易打包”过程？"><a href="#“交易打包”过程？" class="headerlink" title="“交易打包”过程？"></a>“交易打包”过程？</h2><p>每个比特币客户端节点自加入比特币网络开始，无时不刻不在做着创造新区块的操作；</p>
<p>而创造新区块的过程，即是打包每一笔“比特币交易”的过程；</p>
<p>下图是站在“比特币客户端节点”的角度，来描述一次区块生成过程中的交易打包过程。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iLzAuMTcvc3JjL3ByaW1pdGl2ZXMvdHJhbnNhY3Rpb24uaCNMMjY0">primitives/transaction.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The basic transaction that is broadcasted on the network and contained in</span></span><br><span class="line"><span class="comment"> * blocks.  A transaction can contain multiple inputs and outputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTransaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下变量采用常量，为了避免无意的改动</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CTxIn&gt; vin;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CTxOut&gt; vout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> nVersion;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> nLockTime;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COutPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    uint256 hash;</span><br><span class="line">    <span class="keyword">uint32_t</span> n;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** An input of a transaction.  It contains the location of the previous</span></span><br><span class="line"><span class="comment"> * transaction&#x27;s output that it claims and a signature that matches the</span></span><br><span class="line"><span class="comment"> * output&#x27;s public key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTxIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    COutPoint prevout;</span><br><span class="line">    CScript scriptSig;</span><br><span class="line">    <span class="keyword">uint32_t</span> nSequence;</span><br><span class="line">    CScriptWitness scriptWitness; <span class="comment">//! Only serialized through CTransaction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> SEQUENCE_FINAL = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> SEQUENCE_LOCKTIME_DISABLE_FLAG = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> SEQUENCE_LOCKTIME_TYPE_FLAG = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> SEQUENCE_LOCKTIME_MASK = <span class="number">0x0000ffff</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SEQUENCE_LOCKTIME_GRANULARITY = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** An output of a transaction.  It contains the public key that the next input</span></span><br><span class="line"><span class="comment"> * must be able to sign with to claim it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTxOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CAmount nValue;</span><br><span class="line">    CScript scriptPubKey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变交易是干嘛用的？交易还能撤销？更改？回退？</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CMutableTransaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CTxIn&gt; vin;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CTxOut&gt; vout;</span><br><span class="line">    <span class="keyword">int32_t</span> nVersion;</span><br><span class="line">    <span class="keyword">uint32_t</span> nLockTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│Tx: 12af...e85d                              │</span><br><span class="line">├─────────────────────┬───────────────────────┤</span><br><span class="line">│TxIn                 │TxOut                  │</span><br><span class="line">├─────────────┬───────┼──────┬────────────────┤</span><br><span class="line">│prev hash    │index  │btc   │pkScript        │</span><br><span class="line">├─────────────┼───────┼──────┼────────────────┤</span><br><span class="line">│0000...0000  │ffff   │12.5  │OP_DUP c58a...  │</span><br><span class="line">├─────────────┼───────┼──────┼────────────────┤</span><br><span class="line">│2016...a3c5  │3      │0.15  │OP_DUP a1b2...  │</span><br><span class="line">├─────────────┼───────┼──────┼────────────────┤</span><br><span class="line">│2015...b6d8  │1      │0.08  │OP_DUP c3d4...  │</span><br><span class="line">└─────────────┴───────┴──────┴────────────────┘</span><br></pre></td></tr></table></figure>


<p>除了第一笔交易是矿工的挖矿所得外，每一笔交易都拥有一个或多个输入（TxIn），以及一个或多个输出（TxOut）。</p>
<p>第一笔矿工挖矿的收入交易通常被称为Coinbase，它没有输入，所以TxIn的Hash总是被标记为<code>00000000...0000</code><br>其他的交易，任何一个TxIn都会唯一追溯到区块链上在本区块之前的某个交易Hash，以及索引。</p>
<p>通过交易Hash和索引（从0开始），即可唯一确定一个未花费的交易输出——UTXO（Unspent Transaction Output）。<br>这样，每一个Tx Input都和之前的某个Tx Output关联了起来。</p>
<h2 id="交易的输出和输⼊"><a href="#交易的输出和输⼊" class="headerlink" title="交易的输出和输⼊"></a>交易的输出和输⼊</h2><p>⽐特币交易的基本单位是未经使⽤的⼀个交易输出，简称UTX。UTXO是不能再分割、被所有者锁住或记录于区块链中的并<br>被整个⽹络识别成货币单位的⼀定量的⽐特币货币</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li>《精通比特币》</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL2FydGljbGUvMDAxNDgyNzE4NjAzNjk2YTZiNmViMmJlYmM3NDIxMWFiOTY3MTQ2YTk1MmFlMGMwMDA=">深入理解比特币交易的脚本<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lYzdlZTJiYjE2OTc=">比特币“交易打包”底层原理与区块链“分叉”<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUJiNDExQjdkcQ==">比特币和区块链啥原理？ - 李永乐<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTJiNDExcTdrdQ==">比特币交易如何防伪？ - 李永乐<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>block-chain</category>
        <category>虚拟货币</category>
        <category>币种</category>
        <category>比特币-BTC</category>
        <category>源码</category>
        <category>基本的数据结构</category>
        <category>primitive</category>
      </categories>
  </entry>
  <entry>
    <title>BERT</title>
    <url>/pub/8283aaba/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一种新的语言表征模型 BERT——来自 Transformer 的双向编码器表征。与最近的语言表征模型不同，BERT 旨在基于所有层的左、右语境来预训练深度双向表征。BERT 是首个在大批句子层面和 token 层面任务中取得当前最优性能的基于微调的表征模型，其性能超越许多使用任务特定架构的系统，刷新了 11 项 NLP 任务的当前最优性能记录。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h2 id="无监督sequence-learning"><a href="#无监督sequence-learning" class="headerlink" title="无监督sequence learning"></a>无监督sequence learning</h2><ul>
<li>基于特征的策略<ul>
<li>（如 ELMo）使用将预训练表征作为额外特征的任务专用架构。  </li>
<li>什么意思？</li>
</ul>
</li>
<li>微调策略（finetuning）<ul>
<li>（如生成预训练 Transformer (OpenAI GPT)）引入了<strong>任务特定最小参数</strong>(pretrain model之外的参数很少)，通过简单地微调<br>预训练参数在下游任务中进行训练。</li>
</ul>
</li>
</ul>
<p>在之前的研究中，两种策略在预训练期间使用相同的目标<br>函数，利用单向语言模型来学习通用语言表征。</p>
<h2 id="传统方法的局限"><a href="#传统方法的局限" class="headerlink" title="传统方法的局限"></a>传统方法的局限</h2><p>标准语言模型是单向的(从左到右)，这限制了可以在预训练期间使用的架构类型。</p>
<div class="note info">
            <p><strong>解读</strong></p><ol><li><strong>单向</strong>: RNN、ngram都是单向的。word2vec、ELMo是都是双向吧？双向lstm呢？</li><li><strong>限制架构类型</strong>: pretrain用的从左向右的单向网络，在双向网络transformer上怎样fine tune？比如OpenAI的GPT采用的从左到右的架构，其中每个 token 只能注意Transformer 自注意力层中的先前 token。<strong>这种局限很致命</strong></li></ol>
          </div>

<h1 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h1><p>BERT（Bidirectional Encoder Representations from Transformers）改进了基于微调的策略。</p>
<p>BERT 提出一种新的预训练目标——<code>遮蔽语言模型</code>（masked language model，MLM），来<strong>克服上文提到的单向局限</strong>。MLM 的灵感来自 Cloze 任务（Taylor, 1953）。MLM 随机遮蔽输入中的一些 token，，目标在于仅基于遮蔽词的语境来预测其原始词汇 id。与从左到右的语言模型预训练不同，MLM 目标允许表征融合左右两侧的语境，从而预训练一个深度双向 Transformer。除了 MLM，我们还引入了一个「下一句预测」（next sentence prediction）任务，该任务联合预训练文本对表征。</p>
<h2 id="main-task"><a href="#main-task" class="headerlink" title="main task"></a>main task</h2><p>BERT在11个NLP任务上Fine-tuning</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TASKS = [<span class="string">&quot;CoLA&quot;</span>, <span class="string">&quot;SST&quot;</span>, <span class="string">&quot;MRPC&quot;</span>, <span class="string">&quot;QQP&quot;</span>, <span class="string">&quot;STS&quot;</span>, <span class="string">&quot;MNLI&quot;</span>, <span class="string">&quot;SNLI&quot;</span>, <span class="string">&quot;QNLI&quot;</span>, <span class="string">&quot;RTE&quot;</span>, <span class="string">&quot;WNLI&quot;</span>, <span class="string">&quot;diagnostic&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>具体如下:</p>
<table>
<thead>
<tr>
<th>input</th>
<th>output</th>
<th>task</th>
</tr>
</thead>
<tbody><tr>
<td>单句</td>
<td>类别</td>
<td>SST-2, CoLA</td>
</tr>
<tr>
<td>单句</td>
<td>标注</td>
<td>CoNLL-2003(NER)</td>
</tr>
<tr>
<td>双句</td>
<td>类别</td>
<td>MNLI, QQP, QNLI, STS-B, MRPC, RTE, SWAG</td>
</tr>
<tr>
<td>双句</td>
<td>标注</td>
<td>SQuAD v1.1</td>
</tr>
</tbody></table>
<h2 id="other-task"><a href="#other-task" class="headerlink" title="other task"></a>other task</h2><ul>
<li><a href="/pub/ba80d46a">语言模型</a></li>
<li>机器翻译</li>
</ul>
<p>BERT并不能直接用于以上模型，具体方案见相应的链接。</p>
<ul>
<li>embedding用法<ul>
<li>static embedding</li>
<li>dynamic embedding</li>
</ul>
</li>
</ul>
<h1 id="code解读"><a href="#code解读" class="headerlink" title="code解读"></a>code解读</h1><h3 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h3><ul>
<li>中文维基百科（包含繁体、简体）</li>
</ul>
<h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><ul>
<li><strong>词典大小</strong>: 21128</li>
<li><strong>分词</strong><ul>
<li>character‑based tokenization for Chinese</li>
<li>WordPiece tokenization for all other languages.</li>
</ul>
</li>
</ul>
<p><strong>字典内容，质量</strong>: 很杂乱</p>
<ul>
<li>词典第一个是[pad]<ul>
<li>[unused0] 是干嘛的？</li>
<li>[UNK]</li>
<li>[CLS] 用于分类的标记</li>
<li>[SEP] 句子分隔符</li>
<li>[MASK] 用于mask language model</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">&quot;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">user</span><br><span class="line">december</span><br><span class="line">meiki</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ## 表示连接符，比如 pupperteer词典中没有，分词后是 puppet、##eer</span><br><span class="line">##境</span><br><span class="line">##墅</span><br><span class="line">##銘</span><br></pre></td></tr></table></figure>


<h3 id="tokenizer-分词"><a href="#tokenizer-分词" class="headerlink" title="tokenizer 分词"></a>tokenizer 分词</h3><ul>
<li>词典为什么不采用BPE？如何应用在我们的模型上？</li>
<li>Amrozi accused his brother<ul>
<li>‘am’, ‘##ro’, ‘##zi’, ‘accused’, ‘his’, ‘brother’, 分词采用最长匹配？？</li>
</ul>
</li>
<li>中文采用的什么分词<ul>
<li>卧槽，好暴力，直接用的字，都不用分词</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS1yZXNlYXJjaC9iZXJ0L2Jsb2IvbWFzdGVyL3Rva2VuaXphdGlvbi5weSNMMTk1">https://github.com/google-research/bert/blob/master/tokenization.py#L195<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nbHVlYmVuY2htYXJrLmNvbS9sZWFkZXJib2FyZA==">glue实时榜单<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yYWpwdXJrYXIuZ2l0aHViLmlvL1NRdUFELWV4cGxvcmVyLw==">SQuAD实时榜单<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>lm_and_pretrain</category>
        <category>model</category>
        <category>nnlm</category>
        <category>tansformers</category>
      </categories>
      <tags>
        <tag>bert</tag>
      </tags>
  </entry>
  <entry>
    <title>BERT用于语言模型的方案</title>
    <url>/pub/ba80d46a/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>BERT取得了较大成功，但是原始的模型并不能直接用于对句子打分 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS1yZXNlYXJjaC9iZXJ0L2lzc3Vlcy8zNQ==">#35<i class="fa fa-external-link-alt"></i></span>，也就是常规的语言模型任务。<br>如何利用bert的预训练模型对句子打分？</p>
<p>序列掩码的方式应该比较合理。</p>
<p>并非autoregressive结构，速度较快</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><ol>
<li>双向<ul>
<li>采用sequential mask. 计算量较大，精度也最高</li>
</ul>
</li>
<li>单向，类似GPT。计算量稍微小点，但是作为12层的transformer，计算量仍然不小</li>
<li>只用embedding(768维)，自己构造小结构的语言模型<ul>
<li>动态embedding: 用bert作为embedding layer</li>
<li>静态embedding</li>
</ul>
</li>
</ol>
<p>1比较靠谱，因此后面重点介绍方案一。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于一个句子 $S = w_1, w_2,…, w_k$，通常可以这样来表示整个句子的概率</p>
<p>$$<br>p(S) = \prod_{i=1}^{k} p(w_i | context)<br>$$</p>
<p>传统的语言模型，比如RNN中,  $context = w_1, …, w_{i-1}$,<br>$$<br>p(S) = \prod_{i=1}^{k} p(w_i | w_1, …, w_{i-1})<br>$$</p>
<p>如何利用bert对句子打分？一个简单的思路就是每次mask掉一个词 $w _ i$ ，然后利用bert得到该词的概率 $p(w _ i)$。即作为双向语言模型，BERT具有更大的上下文信息，$context = w_1, …, w_{i-1}, w_{i+1}, …, w_k$，</p>
<p>$$<br>p(S) = \prod_{i=1}^{k} p(w_i | w_1, …, w_{i-1},w_{i+1}, …,w_k)<br>$$</p>
<p>进一步可以转化为句子的ppl。</p>
<h1 id="总体评价"><a href="#总体评价" class="headerlink" title="总体评价"></a>总体评价</h1><p>char-level的语言模型，由于词组内的高概率，会使整个句子ppl普遍偏高。句子间的相对ppl还靠谱。</p>
<p>单个word/char的概率预测效果较好。</p>
<blockquote>
<p><strong>建议</strong>:<br>用分词后的中文重新pretrain，然后进行word-level language model predict。</p>
</blockquote>
<h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a>中文测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> BERT_BASE_DIR=model/chinese_L-12_H-768_A-12</span><br><span class="line"><span class="built_in">export</span> INPUT_FILE=data/lm/test.zh.tsv</span><br><span class="line">python run_lm_predict.py \</span><br><span class="line">  --input_file=<span class="variable">$INPUT_FILE</span> \</span><br><span class="line">  --vocab_file=<span class="variable">$BERT_BASE_DIR</span>/vocab.txt \</span><br><span class="line">  --bert_config_file=<span class="variable">$BERT_BASE_DIR</span>/bert_config.json \</span><br><span class="line">  --init_checkpoint=<span class="variable">$BERT_BASE_DIR</span>/bert_model.ckpt \</span><br><span class="line">  --max_seq_length=128 \</span><br><span class="line">  --output_dir=/tmp/lm_output/</span><br></pre></td></tr></table></figure>

<p>以下是部分结果，更多见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvYmVydF9hc19sYW5ndWFnZV9tb2RlbC9ibG9iL21hc3Rlci9kYXRhL2xtL3Jlc3VsdC56aC5qc29u">result.zh.json<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;2016&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.06563900411128998</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;全&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.4981258511543274</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;国&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.9088247418403625</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;低&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">1.6259804397122934e-05</span>  <span class="comment"># 低概率</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;考&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.4023572504520416</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">...</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">13.400421357093588</span></span><br><span class="line">  &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;落&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.1483132392168045</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;霞&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.42232587933540344</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;与&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.8615185022354126</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;孤&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.9975666999816895</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;鹜&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.5613960027694702</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;齐&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.18012434244155884</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;跑&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">1.3388593288254924e-05</span>   <span class="comment"># 低概率</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">...</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">11.983086642867598</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>


<p>中文测试样例来源于<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9ubHAvZG5ubG1fY24=">百度云dnnlm<i class="fa fa-external-link-alt"></i></span></p>
<!--
英文model跑中文 - UNK的影响


export BERT_BASE_DIR=model/uncased_L-12_H-768_A-12
export INPUT_FILE=data/lm/test.zh.tsv
python run_lm_predict.py \
  --input_file=$INPUT_FILE \
  --vocab_file=$BERT_BASE_DIR/vocab.txt \
  --bert_config_file=$BERT_BASE_DIR/bert_config.json \
  --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt \
  --max_seq_length=128 \
  --output_dir=/tmp/lm_output/

UNK太多，没有多大意义。
-->

<h1 id="更多测试"><a href="#更多测试" class="headerlink" title="更多测试"></a>更多测试</h1><h2 id="中文model给英文句子打分"><a href="#中文model给英文句子打分" class="headerlink" title="中文model给英文句子打分"></a>中文model给英文句子打分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">gone with bad</span><br><span class="line">gone with the wind</span><br><span class="line">slavery african</span><br></pre></td></tr></table></figure>

<p>采用的<code>chinese_L-12_H-768_A-12</code>。即中文词典跑英文，会出现很多OOV，造成较多subtoken。<br>ppl较大。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.01559396181255579</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;world&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">7.31540481524462e-08</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">29607.558139141183</span>    <span class="comment"># 为什么ppl这么高？</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;go&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.16923364996910095</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##ne&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.0627128928899765</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;with&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.019953709095716476</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;bad&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">9.239820428774692e-07</span>   <span class="comment"># 这里低概率，比较合理</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">267.37285553187235</span>    <span class="comment"># ppl也算合理</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;go&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.026223953813314438</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##ne&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.06661253422498703</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;with&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.04489848017692566</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;the&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.7770023941993713</span>   <span class="comment"># 局部高概率，ngram能都有多大的概率？</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;wind&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">7.36875972506823e-06</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">74.05246212422989</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.15798506140708923</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##la&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.06484799832105637</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##ver&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.04713333398103714</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##y&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.022265272215008736</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;af&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.9910877346992493</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##ric&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.9998739957809448</span>   <span class="comment"># african是一个词汇，african局部高概率</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;token&quot;:</span> <span class="string">&quot;##an&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prob&quot;:</span> <span class="number">0.17350609600543976</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;ppl&quot;:</span> <span class="number">6.592083876588999</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我觉得，不能按照token来mask</p>
<p>char-level lm的一大缺陷，就是会造成局部概率过高，使得整体ppl失真。<br>ppl的本意是要考虑word间的</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h1LXNvbmcvYmVydF9hc19sYW5ndWFnZV9tb2RlbA==">github源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>lm_and_pretrain</category>
        <category>model</category>
        <category>nnlm</category>
        <category>tansformers</category>
      </categories>
      <tags>
        <tag>bert</tag>
        <tag>语言模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器翻译】transformer</title>
    <url>/pub/664e9bad/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在2017年5月Facebook发布了<code>ConvSeq2Seq</code>模型吊打了GNMT一个月之后，Google发出了最强有力的反击，发表了一篇论文Attention is all you need，文中提出了一种新的架构叫做<code>Transformer</code>，用以来实现机器翻译。它<strong>抛弃了传统的CNN、RNN，只采用attention</strong>，取得了很好的效果，激起了工业界和学术界的广泛讨论。</p>
<h1 id="背景，motivation"><a href="#背景，motivation" class="headerlink" title="背景，motivation"></a>背景，motivation</h1><h2 id="如何获取context信息"><a href="#如何获取context信息" class="headerlink" title="如何获取context信息"></a>如何获取context信息</h2><p>常用的模型架构有RNN、CNN、CRF，详见 <a href="/pub/cf92193c">序列学习</a>。</p>
<h3 id="transformer横空出世"><a href="#transformer横空出世" class="headerlink" title="transformer横空出世"></a>transformer横空出世</h3><p>Transformer避开了recurrence，只用attention，便可以刻画出输入和输出的依赖关系。</p>
<p>对比RNN的决策步骤太长问题，transformer可<strong>单步决策</strong>。通过一层self-attention，bank能够直接attend到river上。</p>
<p>ConvS2S是线性时间复杂度，ByteNet是log时间复杂度。而Transformer则是常数时间复杂度</p>
<!-- 前提是the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention。-->



<h1 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h1><!-- 亮点 trick -->

<ul>
<li>dot product attention</li>
<li>multi-head</li>
<li>彩蛋: restricted self-attention，<!-- 说多了都是泪。不给人留活路。 --></li>
</ul>
<table title="self-attention的几种形式"  border="1"><tbody><tr><td><img height="80px" src="/images/raw/NN - Attention - Encoder-Decoder Attention.png"></td><td><img height="80px" src="/images/raw/NN - Attention - Encoder Self-Attention.png"></td><td><img height="80px" src="/images/raw/NN - Attention - MaskedDecoder Self-Attention.png"></td></tr></tbody></table>



<h2 id="dot-product-attention"><a href="#dot-product-attention" class="headerlink" title="dot product attention"></a>dot product attention</h2><table border="1"><tbody><tr><td><img height="40px" title="Scaled Dot Product Attention" src="/images/raw/NN - transformer - scaled dot product attention.png"></td><td><img height="40px" title="Multi-Head Attention" src="/images/raw/NN - transformer - multi head attention.png"></td></tr></tbody></table>


<p>前面给出的是一般化的框架形式的描述，事实上Google给出的方案是很具体的。首先它定义了Attention一种泛化形式：<br>$$ Attention(\boldsymbol{Q},\boldsymbol{K},\boldsymbol{V}) = softmax\left(\frac{\boldsymbol{Q}\boldsymbol{K}^{\top}}{\sqrt{d_k}}\right)\boldsymbol{V} $$</p>
<p>其中$ \boldsymbol{Q}\in\mathbb{R}^{n\times d_k}, \boldsymbol{K}\in\mathbb{R}^{m\times d_k}, \boldsymbol{V}\in\mathbb{R}^{m\times d_v} $。如果忽略激活函数softmax的话，那么事实上它就是三个$ n\times d_k,d_k\times m, m\times d_v $的矩阵相乘，最后的结果就是一个$ n\times d_v $的矩阵。</p>
<p>这里将attention抽象成 <code>q: query</code>, <code>k: key</code>, <code>v: value</code>。</p>
<p><strong>为什么要采用scale？</strong></p>
<p>因为量级太大，softmax后就非0即1了，不够“soft”了。也会导致softmax的梯度非常小。也就是让softmax结果<strong>不稀疏</strong>(问号脸，通常人们希望得到更稀疏的attention吧)。</p>
<!-- 通常的softmax计算还有个小trick，会减去最大的一个value，避免overflow -->

<ol>
<li>attention 可以不只是用于 decoder 里每步输入一个符号，而是可以用在网络中的任意一层，把一个序列转换成另一个序列。这个作用与 convolutional layer、recurrent layer 等是类似的，但有一个好处就是不再局限于局域性。attention是直接去capture dependency structure，摆脱了局限性魔咒</li>
<li>attention 可以一般地描述为在一个 key-value mapping 中进行检索，只不过 query 跟 key 可以进行模糊匹配，检索结果是各个 key 对应的 value 的加权平均。</li>
</ol>
<p>Query, key, value 其实并不是专门针对翻译的概念。不过可以举一些翻译中的例子。例如，当刚刚翻译完主语之后，attention 的内部状态就会想要去找谓语，这时它就把「想找谓语」这件事编码成 query。然后句子里本身是谓语的地方，会有一个 key，表明「我这里可以提供谓语」，它跟 query 一拍即合。这个 key 对应的 value 就是谓语本身的 embedding。</p>
<blockquote>
<p>点乘注意力在何凯明的Non-local Neural Networks中被解释成Embedded Gaussian的一种特例。非要跟高斯扯上关系，好牵强。</p>
</blockquote>
<h3 id="VS-additive-attention"><a href="#VS-additive-attention" class="headerlink" title="VS additive attention"></a>VS additive attention</h3><p>additive attention等价于一个前馈网络:</p>
<p>$$<br>softmax([Q,K]W)=softmax(QW^Q+KW^K)<br>$$</p>
<p>这个的计算速度没有dot-product attention在GPU上快。</p>
<p>详见 Neural machine translation by jointly learning to align and translate</p>
<h3 id="VS-其他attention"><a href="#VS-其他attention" class="headerlink" title="VS 其他attention"></a>VS 其他attention</h3><h3 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h3><p>以Q为例，单个head的计算</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yMnRlbnNvci9ibG9iL21hc3Rlci90ZW5zb3IydGVuc29yL2xheWVycy9jb21tb25fYXR0ZW50aW9uLnB5I0wyNjQ2">code-t2t<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0t5dWJ5b25nL3RyYW5zZm9ybWVyL2Jsb2IvbWFzdGVyL21vZHVsZXMucHkjTDE2OQ==">code-Kyubyong<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jvam9uZS9hdHRlbnRpb24vYmxvYi9tYXN0ZXIvYXR0ZW50aW9uX2tlcmFzLnB5">code-keras<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>将输入向量切成8份，这每一<br>份可以看成一个local partial，然后再分别attnetion最终再concat成一个context向量。如果将本文multi-head attention的V输入切成八份后的<br>向量类比关注不同local paritial的卷积核的话，我们可以看到CNN和这里multi-head attention异曲同工</p>
<p><strong>优势</strong>：</p>
<ol>
<li>It expands the model’s ability to focus on different positions。 这个最强势。通过attention到不同的维度。细粒度的attention，超赞。</li>
</ol>
<ul>
<li>既是细粒度的attention，又不增加计算量</li>
</ul>
<ol>
<li>能在encode的时候并行化，(这里的并行是相对RNN吗？one-head是大矩阵也可以并行。convS2S同样可以）</li>
<li>降维到d/head，即bottleneck的思想，减少计算量 <!-- this follows the bottleneck
design of ResNet and reduces the computation 来自non-local NN--></li>
</ol>
<p><strong>举例</strong><br>忽略batch_size</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num_units = <span class="number">512</span> <span class="comment"># 也叫 num_channel, emb_size</span></span><br><span class="line">max_length = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">K,Q,V = [<span class="number">10</span>, <span class="number">512</span>]</span><br><span class="line">W = [<span class="number">512</span>,<span class="number">512</span>]</span><br><span class="line">A = attention(KW, KQ, KW)</span><br><span class="line"></span><br><span class="line">加上head后</span><br><span class="line">num_head = <span class="number">8</span></span><br><span class="line">K_i,Q_i,V_i = [<span class="number">10</span>,<span class="number">64</span>] <span class="comment">#</span></span><br><span class="line">W_i = [<span class="number">64</span>,<span class="number">512</span>]  <span class="comment"># 值得注意的是，这里不是 [64,64]，即并未减少计算量和参数量</span></span><br><span class="line">A_i = attention(K_i W_i, W_i,)</span><br></pre></td></tr></table></figure>


<ul>
<li>Multiple attention layers (heads) in parallel</li>
<li>Each head uses different linear transformations.</li>
<li>Different heads can learn different relationships.</li>
</ul>
<div class="note info">
            <p><strong>思考</strong></p><ol><li>self attention遗漏了什么？位置信息</li><li>self attention中的k, q, v分别指代什么？</li><li>self attention是否可逆向？</li></ol>
          </div>

<h2 id="FFN层"><a href="#FFN层" class="headerlink" title="FFN层"></a>FFN层</h2><p>FFN(Position-wise Feed-Forward Network)。</p>
<ul>
<li><strong>Position-wise</strong>: 顾名思义，就是对每个position采用相同的操作。</li>
<li><strong>Feed-Forward Network</strong>: 就是最普通的全连接神经网络，这里采用的两层，relu作为激活函数</li>
</ul>
<img width="150px" title="position wise FFN" src="/images/raw/NN - transformer - FFN.png">
FFN层对接multi-head attention层，那么该层的输入 $x \in \mathbb{R}^{batchsize \times length \times d_{model}}$。





<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yMnRlbnNvci9ibG9iL3YxLjkuMC90ZW5zb3IydGVuc29yL21vZGVscy90cmFuc2Zvcm1lci5weSNMMTM3Mw==">https://github.com/tensorflow/tensor2tensor/blob/v1.9.0/tensor2tensor/models/transformer.py#L1373<i class="fa fa-external-link-alt"></i></span></p>
<p>$$<br>FFN(x)=max(0,x W_1+b_1)W_2+b_2<br>$$</p>
<p>其中输入和输出的维度都是$d_{model}=512$，中间维度是$d_{ff}=2048$。对于单个position<br>$$<br>x \in \mathbb{R}^{512}, W_1 \in \mathbb{R}^{512 \times 2048}, W_2 \in \mathbb{R}^{2048 \times 512}<br>$$</p>
<h3 id="与卷积的等价性"><a href="#与卷积的等价性" class="headerlink" title="与卷积的等价性"></a>与卷积的等价性</h3><p>这里的全连接层，一种替代方案就是采用kernel size为1的卷积，即</p>
<p>tensor2tensor中有两种实现<a href="">dense_relu_dense</a> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yMnRlbnNvci9ibG9iL3YxLjkuMC90ZW5zb3IydGVuc29yL2xheWVycy9jb21tb25fbGF5ZXJzLnB5I0wxNjEx">conv_relu_conv<i class="fa fa-external-link-alt"></i></span>，默认采用的前者。</p>
<p>其中卷积的维度是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input.shape = [batch_size, length, 512]</span><br><span class="line">kernel_1 = [2048,1]   </span><br><span class="line">kernel_2 = [512, 1]  </span><br></pre></td></tr></table></figure>
<p>tensor2tensor实现中，conv1d中的kernel_size如果为1，默认返回dense。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yMnRlbnNvci9ibG9iL3YxLjkuMC90ZW5zb3IydGVuc29yL2xheWVycy9jb21tb25fbGF5ZXJzLnB5I0w2MDc=">源码<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tpu_conv1d</span>(<span class="params">inputs, filters, kernel_size, padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;tpu_conv1d&quot;</span></span>):</span></span><br><span class="line">  <span class="keyword">if</span> kernel_size == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> dense(inputs, filters, name=name, use_bias=<span class="literal">True</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>逗比，conv到底比dense会不会加速？</p>
<p>为什么我觉得kernel_size=512才等价于全连接？</p>
<blockquote>
<p>实际上，kernel_size没必要一定是1的。</p>
</blockquote>
<h3 id="层数与维度设计"><a href="#层数与维度设计" class="headerlink" title="层数与维度设计"></a>层数与维度设计</h3><p>很自然，我们有两个疑问。</p>
<ol>
<li>为什么要两层？MLP?</li>
<li>为什么要先升维再降维？ high-rank</li>
</ol>
<p>通常的bottleNeck架构，先降维再升维(减小计算量)。</p>
<p>两大作用:</p>
<ol>
<li>multi-head attention之后的merge</li>
</ol>
<ul>
<li>类似group conv之后的merge，DWConv后的1*1卷积与channel shuffle</li>
</ul>
<!-- 全连接层参数较多，比如常用的CNN架构里很少在中间层放全连接。-->
<div class="note info">
            <p><strong>小结</strong></p><ol><li>为什么叫强调<code>position-wise</code>？</li></ol><ul><li>解释一: 这里FFN层是每个position进行相同且独立的操作，所以叫position-wise。对每个position独立做FFN。</li><li>解释二：从卷积的角度解释，这里的FFN等价于kernel_size=1的卷积，这样每个position都是独立运算的。如果kernel_size=2，或者其他，position之间就具有依赖性了，貌似就不能叫做position-wise了</li></ul><ol><li>为什么要采用全连接层？</li></ol><ul><li>目的: 增加非线性变换</li><li>如果不采用FFN呢？有什么替代的设计？</li></ul><ol><li>为什么采用2层全连接，而且中间升维？</li></ol><ul><li>这也是所谓的bottle neck，只不过低维在IO上，中间采用high rank</li></ul>
          </div>


<h2 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h2><p>回顾一下Transformer的整个架构，不难发现Transformer模型本身并不能捕捉序列的顺序。换句话说，如果将K,V按行打乱顺序（相当于句子中的词序打乱），那么Attention的结果还是一样的。这就表明了，<strong>到目前为止，Attention模型顶多是一个非常精妙的“词袋模型”而已</strong>。</p>
<!--
attention-based BOW，这个模型也不错哎。
目前的模型entirely invariant to sequence ordering.
-->

<p>Sinusoid Positional Encoding</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0t5dWJ5b25nL3RyYW5zZm9ybWVyL2Jsb2IvbWFzdGVyL21vZHVsZXMucHkjTDEyMA==">code<i class="fa fa-external-link-alt"></i></span></p>
<p>1、以前在RNN、CNN模型中其实都出现过Position Embedding，但在那些模型中，Position Embedding是锦上添花的辅助手段，也就是“有它会更好、没它也就差一点点”的情况，因为RNN、CNN本身就能捕捉到位置信息。但是在这个纯Attention模型中，Position Embedding是位置信息的唯一来源，因此它是模型的核心成分之一，并非仅仅是简单的辅助手段。</p>
<p>2、在以往的Position Embedding中，基本都是根据任务训练出来的向量。而Google直接给出了一个构造Position Embedding的公式：<br>$$<br>\left{<br>\begin{aligned}&amp;PE_{2i}(p)=\sin\Big(p/10000^{2i/{d_{pos}}}\Big)\<br>&amp;PE_{2i+1}(p)=\cos\Big(p/10000^{2i/{d_{pos}}}\Big)<br>\end{aligned}<br>\right.<br>$$</p>
<!-- github的公式渲染，需要双反斜线 -->

<p>这里的意思是将id为$p$的位置映射为一个$d_pos$维的位置向量，这个向量的第$i$个元素的数值就是$PE_{i}(p)$。Google在论文中说到他们比较过直接训练出来的位置向量和上述公式计算出来的位置向量，效果是接近的。因此显然我们更乐意使用公式构造的Position Embedding了。</p>
<p>3、Position Embedding本身是一个<code>绝对位置</code>的信息，但在语言中，<code>相对位置</code>也很重要，Google选择前述的位置向量公式的一个重要原因是：由于我们有 $\sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta$以及$\cos(\alpha+\beta)=\cos\alpha\cos\beta-\sin\alpha\sin\beta$，这表明位置$p+k$的向量可以表示成位置$p$的向量的线性变换，这提供了表达相对位置信息的可能性。</p>
<!-- relative position VS absolute position -->

<div class="note info">
            <p><strong>小结</strong></p><ol><li>Transformer并没有在结构上突破传统的LSTM和CNN，只是采用了position encoding的方式取巧。<br>如何在结构上突破CNN和LSTM的缺陷，达到获取position(时序)信息、任意长度依赖、易并行的效果？</li><li>其他方案</li></ol><ul><li><strong>拼接</strong>: 起来作为一个新向量，也可以把位置向量定义为跟词向量一样大小，然后两者加起来。FaceBook的论文和Google论文中用的都是后者。直觉上相加会导致信息损失，似乎不可取</li><li><strong>multi-channel</strong>:</li></ul>
          </div>




<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="layer-norm"><a href="#layer-norm" class="headerlink" title="layer norm"></a>layer norm</h2><img height="300px" weight="300px" alt="transformer" title="transformer - data flow" src="/images/raw/NN - transformer - dataflow.gif">

<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>经过测试，列了以下可视化结果。</p>
<img width="300px" src="/images/raw/NN - transformer - attention visualization 1.png">

<img width="300px" src="/images/raw/NN - transformer - attention visualization 2.png">

<img width="300px" src="/images/raw/NN - transformer - attention visualization 3.png">

<p>TODO，+动态可视化</p>
<h1 id="维度设计"><a href="#维度设计" class="headerlink" title="维度设计"></a>维度设计</h1><p>在NLP的很多网络里，一般</p>
<ul>
<li>hidden_dim和embedding_dim 相等</li>
<li></li>
</ul>
<p>每层的维度都是相同的维度，(只在FFN层进行了局部升维)。</p>
<p>这与传统的</p>
<h1 id="参数量-amp-计算量"><a href="#参数量-amp-计算量" class="headerlink" title="参数量 &amp; 计算量"></a>参数量 &amp; 计算量</h1><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul>
<li>TensorFlow<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0t5dWJ5b25nL3RyYW5zZm9ybWVy">https://github.com/Kyubyong/transformer<i class="fa fa-external-link-alt"></i></span>  简易版，bucket、lr、decay等都没有实现</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvbW9kZWxzL3RyZWUvbWFzdGVyL29mZmljaWFsL3RyYW5zZm9ybWVy">https://github.com/tensorflow/models/tree/master/official/transformer<i class="fa fa-external-link-alt"></i></span> TF官方code，基本不更新</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yMnRlbnNvciN0cmFuc2xhdGlvbg==">https://github.com/tensorflow/tensor2tensor#translation<i class="fa fa-external-link-alt"></i></span>  官方code，产品级，更新频繁</li>
<li>代码解析： <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamlhb3hpYW9zYW4vYXJ0aWNsZS9kZXRhaWxzLzc0OTA5MDc2">https://blog.csdn.net/mijiaoxiaosan/article/details/74909076<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>Pytorch</li>
</ul>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>Attention层的好处是能够一步到位捕捉到全局的联系，因为它直接把序列两两比较（代价是计算量变为$\mathscr{O}(n^2)$)，当然由于是纯矩阵运算，这个计算量相当也不是很严重）；相比之下，RNN需要一步步递推才能捕捉到，而CNN则需要通过层叠来扩大感受野，这是Attention层的明显优势。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9haS5nb29nbGVibG9nLmNvbS8yMDE3LzA4L3RyYW5zZm9ybWVyLW5vdmVsLW5ldXJhbC1uZXR3b3JrLmh0bWw=">Transformer | Google-blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXh1ZS5mbS9hcmNoaXZlcy80NzY1">《Attention is All You Need》浅读（简介+代码）| kexue.fm<i class="fa fa-external-link-alt"></i></span> 很多还没看懂，后面继续看</li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzQ2NDA4MA==">从convS2S到transformer | 知乎<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>app</category>
        <category>nlp</category>
        <category>translation</category>
        <category>2. 主流model-研究现状</category>
        <category>2. NMT</category>
        <category>transformer</category>
      </categories>
      <tags>
        <tag>self-attention</tag>
        <tag>机器翻译</tag>
        <tag>seq2seq</tag>
        <tag>attention</tag>
      </tags>
  </entry>
  <entry>
    <title>【RNN系列】长短期记忆 LSTM （从RNN到LSTM）</title>
    <url>/pub/a6941437/</url>
    <content><![CDATA[<!-- the implementation of LSTM -->

<h1 id="传统方法-History"><a href="#传统方法-History" class="headerlink" title="传统方法 History"></a>传统方法 History</h1><p>error signals “flowing backwards in time” tend to either <code>blow up</code> or <code>vanish</code>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5ODEyMDEz">bp算法中为什么会产生梯度消失？ | 知乎<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>LSTM网络是RNN的一种，专门设计用于解决long-term dependency/memory问题，1997年由 Hochreiter &amp; Schmidhuber提出。<br>由于独特的设计结构，LSTM适合于处理和预测时间序列中间隔和延迟非常长的重要事件。</p>
<!-- Long Short Term Memory networks – usually just called “LSTMs” – are a special kind of RNN, capable of learning long-term dependencies.  -->

<p>名字：long short-term memory<br>意思是vanilla RNN是short-term memory，sequence太长，</p>
<ul>
<li><strong>LSTM只能避免RNN的梯度消失</strong>（<code>gradient vanishing</code>）；</li>
<li>梯度膨胀(<code>gradient explosion</code>)不是个严重的问题，一般靠裁剪后的优化算法即可解决，比如<code>gradient clipping</code>（如果梯度的范数大于某个给定值，将梯度同比收缩）。下面简单说说LSTM如何避免梯度消失.</li>
<li>梯度弥散是什么鬼？</li>
</ul>
<p>cell: memory_cell</p>
<h2 id="关于梯度消失问题"><a href="#关于梯度消失问题" class="headerlink" title="关于梯度消失问题"></a>关于梯度消失问题</h2><h3 id="梯度消失问题–直观解释"><a href="#梯度消失问题–直观解释" class="headerlink" title="梯度消失问题–直观解释"></a>梯度消失问题–直观解释</h3><!-- In theory, RNNs are absolutely capable of handling “long-term dependencies.” -->

<image title="传统RNN的梯度消失问题" src="/images/raw/NN - RNN - vanish gradient problem - alex.png" width="70%">

<p>传统RNN中存在的梯度消失。</p>
<!-- conventional RNN: 1. The sensitivity of the input valus decays overtime 2. The network forgets the previous input-->


<h3 id="梯度消失-–-产生的原因"><a href="#梯度消失-–-产生的原因" class="headerlink" title="梯度消失 – 产生的原因"></a>梯度消失 – 产生的原因</h3><p>本质原因就是因为<strong>矩阵高次幂</strong>导致的</p>
<p>在多层网络中，影响梯度大小的因素主要有两个：权重和激活函数的偏导。</p>
<p>深层的梯度是<strong>多个激活函数偏导乘积</strong>的形式来计算，如果这些激活函数的偏导比较小（小于1）或者为0，那么梯度随时间很容易vanishing；相反，如果这些激活函数的偏导比较大（大于1），那么梯度很有可能就会exploding。因而，梯度的计算和更新非常困难。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM0ODc4NzA2">https://www.zhihu.com/question/34878706<i class="fa fa-external-link-alt"></i></span></p>
<p>参考:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53aWxkbWwuY29tLzIwMTUvMTAvcmVjdXJyZW50LW5ldXJhbC1uZXR3b3Jrcy10dXRvcmlhbC1wYXJ0LTMtYmFja3Byb3BhZ2F0aW9uLXRocm91Z2gtdGltZS1hbmQtdmFuaXNoaW5nLWdyYWRpZW50cy8=">BP Through Time and Vanishing Gradients<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudG9yb250by5lZHUvfmdyYXZlcy9waGQucGRmI3BhZ2U9NDU=">Chapter 4: LSTM | Supervised Sequence Labelling with Recurrent Neural Networks<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL21scmV2aWV3L3VuZGVyc3RhbmRpbmctbHN0bS1hbmQtaXRzLWRpYWdyYW1zLTM3ZTJmNDZmMTcxNA==">关于valve的比喻<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<!-- we fist introduce the interface, then the implementation  -->

<h2 id="梯度消失问题-–-解决方案"><a href="#梯度消失问题-–-解决方案" class="headerlink" title="梯度消失问题 – 解决方案"></a>梯度消失问题 – 解决方案</h2><p>见后续的gate</p>
<h2 id="梯度消失问题-–-LSTM是如何避免的"><a href="#梯度消失问题-–-LSTM是如何避免的" class="headerlink" title="梯度消失问题 – LSTM是如何避免的"></a>梯度消失问题 – LSTM是如何避免的</h2><p>1、当gate是关闭的，那么就会阻止对当前信息的改变，这样以前的依赖信息就会被学到。2、当gate是打开的时候，并不是完全替换之前的信息，而是在之前信息和现在信息之间做加权平均。所以，无论网络的深度有多深，输入序列有多长，只要gate是打开的，网络都会记住这些信息。</p>
<!-- https://www.cc.gatech.edu/~san37/img/dl/grad_lstm.png -->
<image title="the preservation over time of gradient information by LSTM" width="70%" src="/images/raw/NN - RNN - LSTM - preservation of gradient - alex.png">
<!-- LSTM: 1. The cell remember the input as long as it wants 2. The output can be used anytime it wants-->

<p>上面这个例子中，数据从实心1向后传递。通过gate的配合，成功在节点4和6输出该数据。<strong>数据流(梯度)不会因long-term传输而消失</strong>，有效解决RNN的梯度消失问题。即<strong>梯度保持</strong></p>
<p>用数学来表达，就是f=1,i=0，那么就状态保持(完整)。f=0，i=1就状态遗忘(后面也LSTM的变种，采用i=1-f)。</p>
<ul>
<li>当gate是关闭的，那么就会阻止对当前信息的改变，这样以前的依赖信息就会被学到。</li>
<li>当gate是打开的时候，并不是完全替换之前的信息，而是在之前信息和现在信息之间做加权平均。所以，无论网络的深度有多深，输入序列有多长，只要gate是打开的，网络都会记住这些信息。</li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iaW9pbmYuamt1LmF0L3B1YmxpY2F0aW9ucy9vbGRlci8yNjA0LnBkZiNwYWdlPTU=">LSTM | Sepp Hochreiter 1997<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="LSTM的设计思想"><a href="#LSTM的设计思想" class="headerlink" title="LSTM的设计思想"></a>LSTM的设计思想</h1><p>LSTM的核心：cell + gate。<br>用于解决传统RNN中的梯度消失问题 (Gradient Vanish)</p>
<h2 id="关于gate"><a href="#关于gate" class="headerlink" title="关于gate"></a>关于gate</h2><!-- 备用图片 http://www.solidswiki.com/images/3/34/Gate_valves.gif -->

<table border="1"><colgroup><col width="30%"><col width="70%"></colgroup><tbody><tr><td><img src="/images/raw/NN - RNN - LSTM gate - colah.png"></td><td><img src="https://i.makeagif.com/media/7-27-2015/OLkiOf.gif"></td></tr></tbody></table>



<p>gate，即阀门、开关。取值范围[0,1]，0表示关闭，1表示通行</p>
<p>使用一个合适激活函数，它的梯度在一个合理的范围。LSTM使用gate function，有选择的让一部分信息通过。gate是由一个sigmoid单元和一个逐点乘积操作组成，sigmoid单元输出1或0，用来判断通过还是阻止，然后训练这些gate的组合。所以，<strong>当gate是打开的（梯度接近于1），梯度就不会vanish。并且sigmoid不超过1，那么梯度也不会explode</strong>。</p>
<table border="1"><tbody><tr><td><img title="RNN的信息流: $tanh(c_{t-1})$" src="/images/raw/NN - RNN - colah.png"></td><td><img title="LSTM的信息流：普通的乘加操作" src="/images/raw/NN - RNN - LSTM - cell forget - colah.png"></td></tr></tbody></table>

<ul>
<li>RNN中时序传递采用tanh，是非线性变换，多次叠加梯度计算需要利用链式法则，难收敛。</li>
<li>LSTM中 <strong>时序传递采用乘加操作，是线性变换</strong>，多次叠加可合并，梯度仍然容易求。链式法则求梯度，也会有f的乘积啊</li>
</ul>
<!-- vanishing gradient over time,或者 The Problem of Long-Term Dependencies-->





<blockquote>
<p>Gates are a way to optionally let information through.</p>
</blockquote>
<p>待看</p>
<ul>
<li>An Empirical Exploration of Recurrent Network Architectures.</li>
<li>Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling.</li>
</ul>
<h2 id="关于cell的设计"><a href="#关于cell的设计" class="headerlink" title="关于cell的设计"></a>关于cell的设计</h2><p>$h_t$在RNN中承担两个角色:</p>
<ul>
<li>作为当前时刻的<code>output</code>，用于prediction</li>
<li>作为当前时刻的<code>hidden state</code>，用于时序信息的传递</li>
</ul>
<p>LSTM将这两个角色拆分为 $h_t$和$C$，这样LSTM中的隐状态实际上就是$C$了，$h_t$作为<code>output</code>。通过这样的设计，输出层只利用$h_t$的信息，而不直接利用内部cell的值 $C$。</p>
<img width="50%" src="https://jhui.github.io/assets/rnn/lstm.png">

<p>x和h_t-1做一个拼接，过sigmoide得到forget-gate。<br>forget-gate作用在c_t-1上。</p>
<p><strong>为什么要设计cell？这样抽象的意义？</strong></p>
<p>LSTM中c和h的区别: 仅仅是一个输出门的区别(c没过输出门，$h_{t-1}$作为上一时刻的输出，要过输出门)。</p>
<ul>
<li>c与x拼接送入forget gate呢？</li>
<li>forget作用在h上呢？</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODkxOTc2NQ==">https://zhuanlan.zhihu.com/p/28919765<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>为什么i不是是只作用于x，为什么还要作用于</strong> $h_{t-1}$</p>
<p><strong>GRU中合并了cell state和和hidden state</strong></p>
<h2 id="关于激活函数"><a href="#关于激活函数" class="headerlink" title="关于激活函数"></a>关于激活函数</h2><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><p>sigmoid之类的大量用在rnn的门也并非是概率解释的问题。而是理想门函数是阶跃函数，但其本身不可导，所以soft成sigmoid是一种折中。而且rnn中sigmoid陷入饱和区本身也是一件无所谓的事儿，因为门的作用本身就是通过与不通过，他希望的就是激活值大量集中在0/1附近而不是其他的连续值。</p>
<p>为什么rnn中sigmoid陷入饱和区本身也是一件无所谓的事儿？不影响梯度消失？</p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>为什么用tanh不用ReLU？</p>
<p>在CNN等结构中将原先的sigmoid、tanh换成ReLU可以取得比较好的效果。<br>为什么在RNN中，将tanh换成ReLU不能取得类似的效果？</p>
<p>从信号处理的方式说，要保证系统稳定。类似线性系统极点要在单位圆里，非线性直接加个激活卡住。所以简而言之：Relu不行，越界了；sigmoid差一半平面；只有tanh刚好。tanh还有个好处是零点梯度为1，这个性质比sigmoid好，relu在右半平面也是1，但越界不稳定，然并卵了。</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYxMjY1MDc2L2Fuc3dlci8yMzk5ODc3MDQ=">https://www.zhihu.com/question/61265076/answer/239987704<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output, (h_n, c_n) = lstm(<span class="built_in">input</span>, (h_0, c_0))  <span class="comment"># pytorch的接口</span></span><br><span class="line">new_h, (new_c, new_h) = lstm(inputs, (c, h))  <span class="comment"># tensorflow的接口，其中state=(c, h)</span></span><br></pre></td></tr></table></figure>

<p>LSTM可以看做有两个隐状态h和c，对应的隐层就是一个Tuple。<br>这里可以对比RNN的接口。</p>
<p>在RNN中 $output = c_t = h_t$，即$h$既是<code>hidden state</code>又是<code>output</code></p>
<p><strong>为什么lstm代码里和有些图里，习惯吧output称作h(hidden)？</strong> 前面已经解释了</p>
<p><strong>这里为什么要用 tuple 呢？直接把它们拼成一个 Tensor 不行吗，tuple 还得一个一个遍历，这多麻烦？</strong></p>
<p>不行。因为多层 RNN 并不需要每一层都一样大，例如有可能最底层维度比较高，隐层单元数较大，越往上则隐层维度越小。这样一来，每一层的状态维度都不一样，没法 concat 成一个 Tensor 啊！）；而这个大的 RNN 单元的输出则只有原先的最上层 RNN 的输出，即整体的</p>
<p>接口(对LSTM的封装)要具有良好的扩展性(水平扩展-sequence，垂直扩展-stack)。<br>在stack lstm中，下一层的out对接上一层的input，在深度模型的概念里这就是隐含层hidden的作用，所以命名为hidden。</p>
<p>但是呢，作为一个cell，我还是觉得叫output比较好。追根溯源，谁第一个采用hidden命名的？</p>
<p><strong>为什么lstm代码里要把(c, h)封装成一个tuple？</strong></p>
<ol>
<li>为什么不拼成一个tensor？</li>
<li>为什么不用2个独立元素？</li>
</ol>
<p>这样设计的目的是为了兼容RNN的接口(毕竟LSTM属于RNN的一种)。另外</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dG9yY2gvcHl0b3JjaC9ibG9iL21hc3Rlci90b3JjaC9ubi9tb2R1bGVzL3Jubi5weSNMMzQ2">pytorch 源码 - LSTM<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi9vcHMvcm5uX2NlbGxfaW1wbC5weSNMNTUz">tensorflow源码 - BasicLSTMCell<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="example-应用示例"><a href="#example-应用示例" class="headerlink" title="example 应用示例"></a>example 应用示例</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvdHV0b3JpYWxzL3JlY3VycmVudA==">应用示例–基于lstm的语言模型<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</span><br><span class="line"><span class="comment"># current_batch_of_words不是sequence，只是</span></span><br><span class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words:  </span><br><span class="line">  <span class="comment"># 这里的输入和输出都是符号，类型是tf.placeholder，lstm参数是tf.variable</span></span><br><span class="line">  output, state = lstm(current_batch_of_words, state)</span><br></pre></td></tr></table></figure>


<h1 id="LSTM-实现"><a href="#LSTM-实现" class="headerlink" title="LSTM: 实现"></a>LSTM: 实现</h1><p>In order to make the learning process tractable, it is common practice to create an “unrolled” version of the network, which contains a <strong>fixed number (num_steps) of LSTM inputs and outputs</strong>. The model is then trained on this finite approximation of the RNN. This can be implemented by feeding inputs of length num_steps at a time and performing a backward pass after each such input block.</p>
<p>为什么要有限长度?<br>对于任意长度的序列，BP算法计算复杂，因此采用固定长度的序列。</p>
<p>为什么要固定一个静态长度？<br>是tensorflow的静态图从中作梗吧，动态图则没有这个限制。</p>
<h2 id="LSTM-tensorflow实现"><a href="#LSTM-tensorflow实现" class="headerlink" title="LSTM: tensorflow实现"></a>LSTM: tensorflow实现</h2><image src="/images/raw/NN - LSTM - tensorflow with Equation - colah.png">


<p>tensorflow源码 - <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9ibG9iL21hc3Rlci90ZW5zb3JmbG93L3B5dGhvbi9vcHMvcm5uX2NlbGxfaW1wbC5weSNMNTUz">BasicLSTMCell<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码精简版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, inputs, state</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Run one step of LSTM.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    inputs: `2-D` tensor with shape `[batch_size, input_size]`. 是单个时间节点的batch样本</span></span><br><span class="line"><span class="string">    state:</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    hidden state, new state ().</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  c, h = state</span><br><span class="line">  gate_inputs = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, h], <span class="number">1</span>), self._kernel)</span><br><span class="line">  gate_inputs = nn_ops.bias_add(gate_inputs, self._bias)</span><br><span class="line">  <span class="comment"># i = input_gate, j = new_input, f = forget_gate, o = output_gate</span></span><br><span class="line">  i, j, f, o = array_ops.split(</span><br><span class="line">      value=gate_inputs, num_or_size_splits=<span class="number">4</span>, axis=one)</span><br><span class="line"></span><br><span class="line">  forget_bias_tensor = constant_op.constant(self._forget_bias, dtype=f.dtype)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># update</span></span><br><span class="line">  new_c = add(multiply(c, sigmoid(add(f, forget_bias_tensor))),</span><br><span class="line">              multiply(sigmoid(i), self._activation(j)))</span><br><span class="line">  new_h = multiply(self._activation(new_c), sigmoid(o))</span><br><span class="line">  new_state = LSTMStateTuple(new_c, new_h)</span><br><span class="line">  <span class="keyword">return</span> new_h, new_state</span><br></pre></td></tr></table></figure>

<h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p>包装的好复杂，参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRkbGVlLmNuLzIwMTcvMDUvMjkvTFNUTS1QeXRvcmNoJUU1JUFFJTlFJUU3JThFJUIwLw==">https://blog.ddlee.cn/2017/05/29/LSTM-Pytorch%E5%AE%9E%E7%8E%B0/<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>难并行</li>
<li>计算量大<ul>
<li>low rank approximation之类的参数控制，运算量会是对应RNN的四倍以上。所以Gating其实是一种代价很高的方法。</li>
</ul>
</li>
<li>难优化</li>
</ul>
<h1 id="FAQ-汇总"><a href="#FAQ-汇总" class="headerlink" title="FAQ 汇总"></a>FAQ 汇总</h1><p>关于静态图和动态图？</p>
<ul>
<li>LSTM为什么要设置cell？ cell state 和 hidden state的关系、区别？为什么lstm代码里和有些图里，习惯吧output称作h(hidden)？</li>
<li>为什么要引入gate？</li>
<li>gate是点，还是向量？<ul>
<li>向量， decides what parts of the cell state we’re going to output</li>
</ul>
</li>
<li>LSTM为什么不用ReLU？</li>
</ul>
<h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2NvbGFoLmdpdGh1Yi5pby9wb3N0cy8yMDE1LTA4LVVuZGVyc3RhbmRpbmctTFNUTXMv">Understanding LSTM Networks | colah<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2FyeGl2Lm9yZy9hYnMvMTQwOS4yMzI5">Recurrent Neural Network Regularization | tensorflow中BasicLSTMCell对应的paper<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudG9yb250by5lZHUvfmdyYXZlcy9waGQucGRm">Supervised Sequence Labelling with Recurrent Neural Networks<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yMnJ0LmNvbS93cml0dGVuLW1lbW9yaWVzLXVuZGVyc3RhbmRpbmctZGVyaXZpbmctYW5kLWV4dGVuZGluZy10aGUtbHN0bS5odG1s">Understanding, Deriving and Extending the LSTM | R2RT<i class="fa fa-external-link-alt"></i></span></li>
<li><a href=".">Revisit Long Short-Term Memory: An Optimization Perspective | 朱军大佬</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlxaXpoaXhpbi5jb20vYXJ0aWNsZXMvMjAxNy0wMS0xNi02">地平线语音战略与研究<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>黄畅：我补充一点。关于 LSTM，不管你是单向的、双向的、摞一起的、不摞一起的，其实都有一个问题：<strong>信息传导的约束很强</strong>。换句话说，不管是做前向预测还是后向 BP（反向传播），一个信息从左边到右边，或者从开始到结束，都要经过很长的路径。而且在<strong>整个过程中，会有很多非线性的变化</strong>，尤其是 LSTM 这种典型的、很容易进入自我限制状态的模型。经过很多次这样的事情，就导致整个<strong>优化变得异常困难</strong>。这个结构天生就使得优化变得非常困难。</p>
<p>xusong: 加上skip connection呢，这个可以加在LSTM内部，也可以外部</p>
<p>这是 LSTM 的弊病，它的结构设计有很大限制性。你可以类比一些其他结构，比如 ResNet，它通过建立 free-way 的方式，人为地架了很多 <strong>short-pass</strong>（短路径），使得本来在网络上距离很远的两个单元之间建立一些高速的快速通道。直观的理解就是可以让它们之间的信息沟通更加顺畅，减轻我前面说的那个问题。</p>
<p>更进一步，你会发现在语音识别中有人用<strong>完整的 CNN 替代 LSTM</strong>，包括讯飞、微软、百度。刚开始的时候 CNN 用得很浅，只是作为基本的局部表达，后来发现可以用 <strong>CNN 不断堆积</strong>，而且堆的很有技巧。在计算量不显著增加的情况下，这样就可以<strong>用 CNN 覆盖很大的语境</strong>。</p>
<p>就是说优化算法本身也许没有很好的进步，但是通过网络结构的设计可以规避目前主要基于 SGD 的优化算法难以解决的 LSTM 问题，直接构造一个更适合目前优化算法去优化的网络结构。所以本质上很难说哪个结构更好，你只能说这个结构更适合现在主流的这种优化方法。</p>
<p>其实论文出来时我稍微看了一点，它本质上好像和 attention model 很像。attention model 的概念是不管语境是怎么传过来的，总是有选择的看所有东西，做决策（比如生成一个词）的时候有选择的去做。这时候会产生一个 attention mask，这可以理解成一个 gate，封住一些不想看的东西，保留想看的。</p>
<p>这个在图像和 NLP 里面已经得到很好的验证。NLP、语音、图像其实都是相通的，你会发现很多思想、结构、设计理念会越来越相似。这也给了我们信心，让我们可以实现语音图像识别一体化交互，用一套统一的专用架构去做解决各种各样的问题。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>RNN</category>
      </categories>
      <tags>
        <tag>rnn</tag>
        <tag>lstm</tag>
        <tag>gradient vanish</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript的正则表达式</title>
    <url>/pub/5e28078b/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="匹配到的字符串"><a href="#匹配到的字符串" class="headerlink" title="匹配到的字符串"></a>匹配到的字符串</h2><table>
<thead>
<tr>
<th>字符</th>
<th>替换文本</th>
</tr>
</thead>
<tbody><tr>
<td>$&amp;</td>
<td>与正则相匹配的字符串</td>
</tr>
<tr>
<td>$`</td>
<td>匹配字符串左边的字符</td>
</tr>
<tr>
<td>$’</td>
<td>匹配字符串右边的字符</td>
</tr>
<tr>
<td>$1,$2,$3,…,$n</td>
<td>匹配结果中对应的分组匹配结果</td>
</tr>
</tbody></table>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h2 id="匹配的正则表达式"><a href="#匹配的正则表达式" class="headerlink" title="匹配的正则表达式"></a>匹配的正则表达式</h2><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>匹配将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’&#39;的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’&#39;,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a*/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。</td>
</tr>
<tr>
<td>.</td>
<td>（小数点）匹配除换行符之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配 ‘x’ 并且记住匹配项，就像下面的例子展示的那样。括号被称为 捕获括号。模式/(foo) (bar) \1 \2/中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。</td>
</tr>
<tr>
<td>(?:x)</td>
<td>匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。</td>
</tr>
<tr>
<td>x(?=y)</td>
<td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td>
</tr>
<tr>
<td>x(?!y)</td>
<td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</td>
</tr>
<tr>
<td>x</td>
<td>y    | 匹配‘x’或者‘y’。例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中得a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/都匹配“test.i.ng”中得所有字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。</td>
</tr>
<tr>
<td>[\b]</td>
<td>匹配一个退格(U+0008)。（不要和\b混淆了。）</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）例子：/\bm/匹配“moon”中得‘m’；/oo\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。注意: JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，小数位数和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\B../匹配”noonday”中得’oo’, 而/y\B./匹配”possibly yesterday”中得’ye‘</td>
</tr>
<tr>
<td>\cX</td>
<td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\cM/ 匹配字符串中的 control-M (U+000D)。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字。等价于[0-9]。例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于[^0-9]。例如， /\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符 (U+000C)。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符 (U+000A)。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符 (U+000D)。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如, /\s\w*/ 匹配”foo bar.”中的’ bar’。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符。等价于[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如， /\S\w*/ 匹配”foo bar.”中的’foo’。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个水平制表符 (U+0009)。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符 (U+000B)。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非单字字符。等价于[^A-Za-z0-9_]。例如, /\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</td>
</tr>
<tr>
<td>\n</td>
<td>当 n 是一个正整数，一个返回引用到最后一个与有n插入的正则表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\sorange\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td>
</tr>
<tr>
<td>\0</td>
<td>匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \0<digits> 是一个八进制转义序列。</td>
</tr>
<tr>
<td>\xhh</td>
<td>与代码 hh 匹配字符（两个十六进制数字）</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>与代码 hhhh 匹配字符（四个十六进制数字）。</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2R1bml6Yi9KUy1SZWd1bGFyLWV4cHJlc3Npb24tYXdlc29tZQ==">常用的JS正则表达式 | Github<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SEO</title>
    <url>/pub/435df108/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="如何检查自己网站是否被baidu-google检索"><a href="#如何检查自己网站是否被baidu-google检索" class="headerlink" title="如何检查自己网站是否被baidu google检索"></a>如何检查自己网站是否被baidu google检索</h2><p>site:xu-song.top git<br>site:xu-song.github.io git</p>
<h2 id="提交百度检索"><a href="#提交百度检索" class="headerlink" title="提交百度检索"></a>提交百度检索</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL2xpbmtzdWJtaXQvdXJs">https://ziyuan.baidu.com/linksubmit/url<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>百度搜索资源平台为站长提供链接提交通道，您可以提交想被百度收录的链接，百度搜索引擎会按照标准处理，但不保证一定能够收录您提交的链接。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhZGRpbmdzLmNuLzIwMTYvMDUvMTQvYmxvZy9oZXhvLXNpdGVtYXAv">Hexo 博客添加百度sitemap<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM3NjMzNjg3">hexo部署在github，用百度的站长收录sitemap，抓取失败怎么办？<i class="fa fa-external-link-alt"></i></span><br>Github屏蔽了百度爬虫。<br>除了sitemap还有其他提交方法，还可以采用主动推送和自动推送，</p>
<h2 id="为什么我的博客始终无法被百度收录"><a href="#为什么我的博客始终无法被百度收录" class="headerlink" title="为什么我的博客始终无法被百度收录"></a>为什么我的博客始终无法被百度收录</h2><p>我在GoDaddy购买了域名，完成了在谷歌搜录，百度完成自动推送的设置后在sitemap一栏中填入我的域名始终显示sitemap抓取失败，请问这是什么问题我该如何解决呢   – 知乎</p>
<p>github 禁止了百度的爬虫，你可以在 国内的 coding.net 上放一份，然后修改域名服务商的 CNAME 让国内的指向 coding.net ，国外的依然指向 github。具体你自己查下吧</p>
<blockquote>
<p>就算放开了，肯定也没有国内的vps收录快。还有就是并不是所有的ip地址的权重都一样。爬虫有自己喜欢和不喜欢的ip群</p>
</blockquote>
<p>如果完全没有外链，也不向百度提交，相当于孤岛，是不可能被收录的。<br>除非有人替你提交，或者本身百度数据库有你域名的记录。</p>
<p>没外链不代表孤岛，没外链你DNS修改时候百度等也有可能会知道，参考dnspod和百度合作的某文章……</p>
<h2 id="有多个域名，怎么做最符合-SEO"><a href="#有多个域名，怎么做最符合-SEO" class="headerlink" title="有多个域名，怎么做最符合 SEO?"></a>有多个域名，怎么做最符合 SEO?</h2><p>把其他域名都转发到主域名。很多人把不同的域名都解析到同一个网站，这样导致的结果是其他的域名没有对主域名起到任何作用，反而可能导致负面影响，如：让搜索引擎分不清到底哪一个是主域名。</p>
<p>搜索引擎对同一ip下的域名有互相推广的作用，给的比重越来越小了，多个域名同时解析到一个主机上，对SEO是有影响的，比如说：排名不好、PR值低、收录量少等问题。</p>
<p>对于多域名绑定建议从下面入手：</p>
<pre><code>1.使用301重定向功能。关于301重定向的操作需要注意的是：不要将次要网站中的所有网页的流量都重定向到主站上，这样做虽然节省了很多工作量，但是如果用户从搜索引擎上找过来，访问到的网页并不是他想要的内容，就会损失流量。尽可能做到页对页的重定向，保证用户从搜索引擎找过来的网页即使不是绝对匹配也是相关的内容。

2.给次要的网站首页做一个导航,把流量指引到主站上；

3.给次要的域名做URL转发；
</code></pre>
<p>一定要这样做：实现301重定向把次域名重定向到主域名去，避免权重分散，甚至被K，或者影响SEO排名。</p>
<ul>
<li>301 redirect:：301代表永久性转移。301重定向是网页更改地址后对搜索引擎最友好的方法，只要不是暂时搬移的情况，都建议使用301来做转址。</li>
<li>302 redirect:：302代表暂时性转移。在前些年，不少Black Hat SEO曾广泛应用这项技术作弊。各大主要搜索引擎均加强了打击力度。(怎么作弊？)</li>
</ul>
<p>当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。好处是，第一，没有网址规范化问题，第二，也很重要的，网页A的PR网页级别会传到网页B。</p>
<h1 id="SEO与跳转-重定向"><a href="#SEO与跳转-重定向" class="headerlink" title="SEO与跳转(重定向)"></a>SEO与跳转(重定向)</h1><p>301 vs 302 vs meta-refresh tag</p>
<p><img src="http://www.redalkemi.com/public/tinymce/images/uploads/2008/04/bot-blog4.jpg"></img></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5yZWRhbGtlbWkuY29tL2Jsb2cvcG9zdC90aGUtc2VvLXdhci1vZi1yZWRpcmVjdHMtMzAxLXZzLTMwMi12cy1tZXRhLXJlZnJlc2gtdGFn">参考<i class="fa fa-external-link-alt"></i></span></p>
<p>URL 重定向服务实际并非DNS 服务，它们在 HTTP 级别运行，而非 DNS 级别。使用URL转发的客户基本都是免费DNS的用户，当前业务暂不会投入支持。</p>
<h2 id="301重定向"><a href="#301重定向" class="headerlink" title="301重定向"></a>301重定向</h2><p>301 重定向，是指当用户通过浏览器访问某个 URL 时，Web 服务器被设置自动跳转到另外一个 URL，此时给客户端的返回码是 301。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>301 重定向一般用于两个 URL 之间的跳转。由于 301 重定向可以实现 URL 跳转后的权重转移，实现 SEO 优化，所以常用于如下场景：</p>
<ul>
<li>网站有多个域名，但有一个主域名作为 SEO 推广对象，所有其他域名可以做 301 重定向到主域名，实现权重转移。</li>
<li>网站更换过域名，希望用新的域名作为 SEO 推广对象，当网站的用户访问旧域名时就会被 301 重定向到新的域名，实现权重转移。<ul>
<li>迁移后，访问统计归零。</li>
<li>301重定向之后是不会承继老网站的关键词排名，只不过老网站的排名依然在而已，用户点击你的老域名会直接指向新域名</li>
</ul>
</li>
<li>网站部分内容做过调整，URL 已经无法访问，可以做 301 重定向实现权重转移。</li>
</ul>
<p>参考：</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy4zNjBkb2MuY29tL2NvbnRlbnQvMTQvMDIxMi8xNS8xMzc4MDE5Ml8zNTE5MjAzNTIuc2h0bWw=">http://www.360doc.com/content/14/0212/15/13780192_351920352.shtml<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5odXJlbmNhaS5jb20vYXJjaGl2ZXMvNDUz">http://www.hurencai.com/archives/453<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="服务器ip迁移"><a href="#服务器ip迁移" class="headerlink" title="服务器ip迁移"></a>服务器ip迁移</h3><p>比如从gitpage迁移到coding page。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5OTg3MTEy">https://www.zhihu.com/question/19987112<i class="fa fa-external-link-alt"></i></span></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="URL设计-与-SEO"><a href="#URL设计-与-SEO" class="headerlink" title="URL设计 与 SEO"></a>URL设计 与 SEO</h2><ul>
<li>静态URL</li>
<li>尽量英文，中文用拼音。(现在搜索引擎也对中文优化了，貌似中文url也不错，例如wikipedia的中文页面就采用的中文url)</li>
<li>字母全部小写</li>
<li>URL中包含关键词</li>
<li>url要短</li>
<li>单词之间一般建议使用短横线（-）分隔，不要使用下划线或者其他符号</li>
</ul>
<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>robots.txt位置固定，sitemap.xml需要在robots.txt中指定路径</p>
<p>必要性</p>
<h1 id="提交链接的几种方式"><a href="#提交链接的几种方式" class="headerlink" title="提交链接的几种方式"></a>提交链接的几种方式</h1><p>Sitemap提交：在配置sitemap文件时，无论是txt格式的文本文档还是还是xml格式的文件。都不建议将其sitemap的文件名命名为sitemap.txt或sitemap.xml这么大众化且谁都能够知道的文件名。如果你这样设置，你的竞争对手或需要你网站内容的人很容易就能拿到你所有的页面url。出于保险起见还是使用一些自己定义的较复杂的文件名。每一个url都必须包含http://，文件中包含的url不得超过5万条，单文件大小不得超过10MB，一个站点最多提交5万个sitemap文件，超出5万个不再处理并会提示“链接数超”。如果是通过子域名的形式验证的站点。那么主域名下的sitemap文件是可以包含该域名下的所有域名的url的。</p>
<p>主动推送：</p>
<p>对比sitemap而言在及时抓取上推送更快、发现更快、抓取更及时。如果是时效性文章不排除其收录速度达到一瞬间的效率，这里特别建议一下，最好是主动推送我们网站第一时间产生的新内容给百度其效果更佳；主动推送是有推送数量的限制，尽可能的不要推送重复的内容给百度。这样会大大浪费自己的可推送资源。</p>
<p>自动推送：<code>在页面被访问时，页面URL将立即被推送给百度</code>。</p>
<h2 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h2><p>爬虫会通过网页内部的链接发现新的网页。但是如果没有连接指向的网页怎么办?或者用户输入条件生成的动态网页怎么办?能否让网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页?这就是sitemap，最简单的 Sitepmap 形式就是XML文件，在其中列出网站中的网址以及关于每个网址的其他数据(上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度等等)，利用这些信息搜索引擎可以更加智能地抓取网站内容。</p>
<p>新的问题来了，爬虫怎么知道这个网站有没有提供sitemap文件，或者说网站管理员生成了sitemap，(可能是多个文件)，爬虫怎么知道放在哪里呢?</p>
<p>由于robots.txt的位置是固定的，于是大家就想到了把sitemap的位置信息放在robots.txt里。这就成为robots.txt里的新成员了。</p>
<p>站点地图对于百度失效。可以用主动推送和自动推送，</p>
<p>对于主域名下有多个2级域名的问题，应该是每一个二级域名都有自己独立的robots文件和sitemap。</p>
<p>必要性：不做也能收录。<br>最好做，为蜘蛛提供一个引导，有利于收录</p>
<p>知乎没有sitemap.xml，或许自定义了文件名</p>
<p><a href="https://blog.eson.org/2018/03/04/web/site-dev/seo-in-hexo/">https://blog.eson.org/2018/03/04/web/site-dev/seo-in-hexo/</a></p>
<h2 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h2><p>调用接口<br><span class="exturl" data-url="aHR0cDovL2RhdGEuenouYmFpZHUuY29tL3VybHM/c2l0ZT1odHRwczovL2Jsb2cuZXNvbi5vcmcmYW1wO3Rva2VuPWhPcmFYc3JVNmpsNlBpZmcmcXVvdDs=">http://data.zz.baidu.com/urls?site=https://blog.eson.org&amp;token=hOraXsrU6jl6Pifg&quot;<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>hexo的baidu主动推送<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aXdhbmcvaGV4by1iYWlkdS11cmwtc3VibWl0">hexo-baidu-url-submit<i class="fa fa-external-link-alt"></i></span></p>
<p>新链接的产生，hexo generate会产生一个文本文件，里面包含最新的链接<br>新链接的提交，hexo deploy会从上述文件中读取链接，提交至百度搜索引擎。</p>
<h2 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h2><p>页面每次被访问时，页面URL将立即被推送给百度。借助用户的浏览行为来触发推送动作，无需站长汇总URL再进行主动推送操作，省去了站长人工操作的时间。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>需要将这段js代码部署到我们的每一个网页中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);  <span class="comment">//</span></span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>每当用户进行访问时，就会触发了这段代码，这段代码自动将当前页面的url推送给了百度。具体推送代码如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96ei5iZHN0YXRpYy5jb20vbGlua3N1Ym1pdC9wdXNoLmpz">push.js<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="regexp">/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi</span></span><br><span class="line">      , r = <span class="built_in">window</span>.location.href</span><br><span class="line">      , t = <span class="built_in">document</span>.referrer;</span><br><span class="line">    <span class="keyword">if</span> (!e.test(r)) &#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="string">&quot;https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif&quot;</span>;</span><br><span class="line">        t ? (o += <span class="string">&quot;?r=&quot;</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.referrer),</span><br><span class="line">        r &amp;&amp; (o += <span class="string">&quot;&amp;l=&quot;</span> + r)) : r &amp;&amp; (o += <span class="string">&quot;?l=&quot;</span> + r);</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">new</span> Image;</span><br><span class="line">        i.src = o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>比如每次访问页面<code>https://blog.eson.org</code>时，都会触发一个http请求<code>https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif?l=https://blog.eson.org/</code>。这就是自动推送。</p>
<h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><p>hexo-theme-next中的baidu自动推送，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2xheW91dC9fdGhpcmQtcGFydHkvc2VvL2JhaWR1LXB1c2guc3dpZw=="> baidu-push.swig<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建议同时配置这三种方式，并让三者协同工作，将抓取和收录价值最大化。</p>
<h1 id="怎样判断网站有网址规范化问题？"><a href="#怎样判断网站有网址规范化问题？" class="headerlink" title="怎样判断网站有网址规范化问题？"></a>怎样判断网站有网址规范化问题？</h1><ol>
<li>查一下这些URL是否都有差不多的PR值和网页快照：</li>
</ol>
<p><span class="exturl" data-url="aHR0cDovL2RvbWFpbm5hbWUuY29tLw==">http://domainname.com<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5kb21haW5uYW1lLmNvbS9pbmRleC5odG1s">http://www.domainname.com/index.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2RvbWFpbm5hbWUuY29tL2luZGV4Lmh0bWw=">http://domainname.com/index.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5kb21haW5uYW1lLmNvbS8=">http://www.domainname.com<i class="fa fa-external-link-alt"></i></span></p>
<p>2)搜一下site:domain.com看是否结果中有多个主页版本。</p>
<p>3)你的网站是否在Google有大量网页被标为“ 补充材料”(Supplemental Result)。一般认为被归为“ 补充材料”是网址规范化问题的征兆。</p>
<p>reference： <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VvemFjLmNvbS9zZW8vMzAxLXJlZGlyZWN0Lw==">https://www.seozac.com/seo/301-redirect/<i class="fa fa-external-link-alt"></i></span></p>
<p>site:.top</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ol>
<li><p>edu和gov后缀的域名天生权重更高。有些域名天生反链高，比如xxx   sex   之类的等等！</p>
<ul>
<li>百度说：使用何种形式的域名后缀对百度网页搜索没有影响</li>
</ul>
</li>
<li><p>注册时间越早的域名，越有利于排名。</p>
</li>
<li><p>到期时间越晚的域名，越有利于排名。</p>
</li>
<li><p>不同的子域名是会被当作独立网站处理的，不能继承主域名的权重。</p>
</li>
<li><p>不同国家的域名，在本国会越有利于排名，比如<span class="exturl" data-url="aHR0cDovL2FiYy5jbuWcqOS4reWbveS8muaOkuWQjeabtOWlvSzogIxodHRwLy9hYmMudXMlRTUlOUMlQTglRTclQkUlOEUlRTUlOUIlQkQlRTQlQkMlOUElRTYlOEUlOTIlRTUlOTAlOEQlRTYlOUIlQjQlRTUlQTUlQkQlRTMlODAlODI=">http://abc.cn在中国会排名更好，而http://abc.us在美国会排名更好。<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<p>一个网站有多个域名没问题，请做好301跳转，别每个域名都可以访问。</p>
<p>gov和edu对排名有利，但对大多数人没什么指导意义，因为你根本弄不到这种后缀的域名。</p>
<p>域名买卖历史，（不涉及到违规行业越好）</p>
<p>惩罚 &amp; 奖励</p>
<ul>
<li>关键词堆砌</li>
<li>频繁的修改网页title、description和keywords</li>
<li>网站加上黑链</li>
<li>短时间内频繁的增加外链，或者短时间内大量的删除外链</li>
<li>服务器不稳定，网站经常打不开活域名解析错误。</li>
<li>全站 HTTPS，谷歌对 HTTPS 有加分</li>
<li>响应式设计，谷歌对提供友好移动端友好页面有加分</li>
<li>AMP，谷歌对提供 AMP 支持的网站有加分</li>
<li>PWA，谷歌对 PWA 有加分</li>
<li>加载优化，谷歌对 Pageseed 测试 90 分以上的网站有加分</li>
</ul>
<ul>
<li><p>页面内容持续不断更新，迎合了搜索引擎喜新厌旧的特性。</p>
</li>
<li><p>关键词密度要提升，但不是堆积</p>
</li>
<li><p>高质量内容出现在代码更靠前的位置，方便搜索引擎识别抓取。</p>
</li>
<li><p>内容很少的页面搜索引擎肯定不喜欢</p>
</li>
</ul>
<h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p>有很多大学生在他们大学的个人网站上出卖链接。搜索引擎怎样去辨别哪些来自.edu的链接是自然的？哪些又是买卖的呢？</p>
<h2 id="seo诊断"><a href="#seo诊断" class="headerlink" title="seo诊断"></a>seo诊断</h2><p>bing站长有SEO Analyzer。</p>
<h3 id="title长度"><a href="#title长度" class="headerlink" title="title长度"></a>title长度</h3><p>诊断我的主页，title太短，因为只有四个字母ESON。</p>
<blockquote>
<p>Recommended Action:<br>Change the length of the title to be between 5 and 100 characters</p>
</blockquote>
<blockquote>
<p>SEO Explanation:<br>If the title is too short, it may not provide us and users with enough information to understand the relevancy of your page.  If the title is too long, we may need to shorten it in the search results and your keywords may not appear on the search results page.  You should try to keep the length of the title somewhere between at least 5 characters and 100 characters.</p>
</blockquote>
<h3 id="description长度"><a href="#description长度" class="headerlink" title="description长度"></a>description长度</h3><blockquote>
<p>Recommended Action:<br>Change the description in the <meta description> tag in the page source to be between 25 and 160 characters in length.</p>
</blockquote>
<blockquote>
<p>SEO Explanation:<br>Search engine crawlers only show the first 150-160 characters of the description in the search results page, so if a description is too long, searchers may not see all of the text. If a description is too short, the search engines may add text found elsewhere on the page. Note that search engines may show a different description from the one you have authored if they feel it may be more relevant to a user’s search.</p>
</blockquote>
<h3 id="tag数量太多"><a href="#tag数量太多" class="headerlink" title=" tag数量太多"></a><h1> tag数量太多</h3><p><a href="https://blog.eson.org/2018/01/25/web/site-dev/seo/seo-for-spider/">https://blog.eson.org/2018/01/25/web/site-dev/seo/seo-for-spider/</a></p>
<blockquote>
<p>There are multiple <h1> tags on the page.<br>Recommended Action:<br>Remove redundant <h1> tags from the page source, so that only one <h1> tag exists.</p>
</blockquote>
<h3 id="tag-的-ALT属性"><a href="#tag-的-ALT属性" class="headerlink" title=" tag 的 ALT属性"></a><img> tag 的 ALT属性</h3><blockquote>
<p>Recommended Action:<br>Use the <img alt> attribute to write descriptive content for the image: &lt;img source=”pic.gif” alt=”Accurate and descriptive keyword text that represents the image.”</img>.</p>
</blockquote>
<blockquote>
<p>SEO Explanation:<br>As a general rule, search engines do not interpret the content of image files. The text provided in the <img alt> attribute enables the site owner to provide relevant information to the search engine and to the end user. Alt text is helpful to end users if they have images disabled or if the image does not properly load. In addition, the Alt text is utilized by screen readers. Make sure that your Alt text is descriptive and accurately reflects what the image represents and supports the content on the page.</p>
</blockquote>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2VibWFzdGVyd29ybGQuY29tL2ZvcnVtMjUvMzcxNi5odG0=">https://www.webmasterworld.com/forum25/3716.htm<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5laGNvby5jb20vc2VvLmh0bWw=">http://www.ehcoo.com/seo.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL2NvbGxlZ2UvYXJ0aWNsZWluZm8/aWQ9MzY=">百度站长平台关于SEO的建议<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZW1vbnhxLmNuLzIwMTcvMTEvMjMvWyVFOCU4NyVBQSVFNSU4OCVCNiVFNSVCNyVBNSVFNSU4NSVCN10lRTUlQUUlOUUlRTclOEUlQjAlRTglODclQUElRTUlOEElQTglRTYlOEUlQTglRTklODAlODFIZXhvJUU1JThEJTlBJUU1JUFFJUEyJUU2JTk2JTg3JUU3JUFCJUEwJUU4JTg3JUIzJUU3JTk5JUJFJUU1JUJBJUE2Lw==">自动推送Hexo博客文章至百度<i class="fa fa-external-link-alt"></i></span> 待看<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyNzI2OTgx">知乎是怎么把 SEO 做起来的？<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jaGluYXouY29tL3dlYi8yMDE1LzExMTgvNDcxODY4LnNodG1s">https建议<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL2NvbGxlZ2UvYXJ0aWNsZWluZm8/aWQ9ODc0">新站如何被百度快速收录<i class="fa fa-external-link-alt"></i></span><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2></li>
</ul>
<h1 id="常见疑问"><a href="#常见疑问" class="headerlink" title="常见疑问"></a>常见疑问</h1><h2 id="http站点转为https后，对站点原本的评价权重得分是否有影响？"><a href="#http站点转为https后，对站点原本的评价权重得分是否有影响？" class="headerlink" title="http站点转为https后，对站点原本的评价权重得分是否有影响？"></a>http站点转为https后，对站点原本的评价权重得分是否有影响？</h2><p>无影响，后续会有正向收益，认为https更安全，在排序上会有倾斜。</p>
<h2 id="转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？"><a href="#转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？" class="headerlink" title="转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？"></a>转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？</h2><p>快照和排名不会有变化，建议301永久存在，不管是对搜索引挚还是对用户来说都更好一些。</p>
<h2 id="针对https的站点，百度在抓取技术层面上有哪些建议？"><a href="#针对https的站点，百度在抓取技术层面上有哪些建议？" class="headerlink" title="针对https的站点，百度在抓取技术层面上有哪些建议？"></a>针对https的站点，百度在抓取技术层面上有哪些建议？</h2><p>如果以前有http站点，建议永久保留跳转行为。之后注意通过百度站长平台的抓取诊断工具和抓取异常工具关注抓取结果。</p>
<h2 id="百度索引量增加收录量反而下降是什么原因？"><a href="#百度索引量增加收录量反而下降是什么原因？" class="headerlink" title="百度索引量增加收录量反而下降是什么原因？"></a>百度索引量增加收录量反而下降是什么原因？</h2><p>百度索引量是指被百度收集的数量，百度收录量是指被百度放出的数量</p>
<blockquote>
<ol>
<li>索引量指可以被搜索用户搜索到的网站数据库，索引量工具同时支持站点自定义想要关注的目录，查看某一目录规则下的索引量；索引量不等于流量，索引量会有定期数据波动，属于正常现象。</li>
<li>百度索引数据最快每天更新一次，最迟一周更新一次，不同站点的更新日期可能不同。</li>
<li>您可以查询到近一年中每天的索引量数据，一年前的索引量数据为每月索引量数据。</li>
<li>如果已有流量数据查询不到，请隔日再查，最长间隔一周可查询到数据。<br>来自百度 <span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tLw==">https://ziyuan.baidu.com<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<ol>
<li>百度索引是指你的网页已被百度蜘蛛爬取到百度索引库里了，但这不表示你的网页被百度收录了，所以你是检索不到的。</li>
<li>百度收录是指，在百度索引库的网页经一定检查符合百度标准的，百度“转移到”（这个词是我自己说的，方便理解，实际百度未必这样处理）收录库里，予以放出，也就是被百度收录了这时你才能检索到自己的网页，但此时你的网页如果不符合标准仍然有从百度收录库被删的可能，比如文章是复制的重复率太高等等，百度检查也不是完美的。</li>
</ol>
<p>索引增加说明，百度蜘蛛还会定期到你的网站爬取网页，所以你的索引会增加。<br>收录减少很可能是因为你的网页在百度的价值不够，又被百度收录删了。</p>
<h2 id="为什么百度索引量和收录量一直不增加呢"><a href="#为什么百度索引量和收录量一直不增加呢" class="headerlink" title="为什么百度索引量和收录量一直不增加呢?"></a>为什么百度索引量和收录量一直不增加呢?</h2><p>新站开始收录比较慢比较正常，当然有些新站收录也会比较好。<br>这个也是有一些偶性的，看下抓取频次和日志里面的蜘蛛爬行情况，都是正常即可。</p>
<h2 id="提交链接后，都会被百度抓取并收录吗？"><a href="#提交链接后，都会被百度抓取并收录吗？" class="headerlink" title="提交链接后，都会被百度抓取并收录吗？"></a>提交链接后，都会被百度抓取并收录吗？</h2><p>百度对已提交的数据，不保证一定会抓取及收录所有网址。是否收录与页面质量相关。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>电商比较重视排名，SEO一定要好</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>麻蛋，百度不行啊。seo设置麻烦，收录又慢。google都不用设置，收录又新又好。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>web</category>
        <category>建站</category>
        <category>seo</category>
      </categories>
      <tags>
        <tag>domain</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>【卷积】2. 深度学习中的卷积进化史</title>
    <url>/pub/7203e497/</url>
    <content><![CDATA[<p>尚未完成，备份</p>
<table>
<thead>
<tr>
<th></th>
<th>参数(模型大小，静态)</th>
<th>计算量</th>
<th>特征图大小(memory消耗)</th>
<th>参数自由度(可滑动、复用度)</th>
<th>特征图的自由度</th>
<th>参数的秩/映射能力</th>
<th>输出特征图[n,c]的秩/困惑度/表达力</th>
<th></th>
<th></th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>全连接</td>
<td>[$n \times c$, $n \times c$]</td>
<td>$ n \times c  \times n \times c$</td>
<td></td>
<td>0</td>
<td></td>
<td>4</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>conv</td>
<td>[k,c,c]</td>
<td>k<em>c</em>n*c</td>
<td></td>
<td>1</td>
<td></td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td>conv局部连接替代全连接+权值共享，大大减少参数，其次减少计算量</td>
</tr>
<tr>
<td>conv分解-DSC</td>
<td>[k,c] + [1,c,c]</td>
<td>k<em>c+c</em>c</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>对卷积核的rank2分解</td>
</tr>
<tr>
<td>conv分解-Flattern</td>
<td>[k] + [c] + [c]</td>
<td>k+c+c</td>
<td></td>
<td>3</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>对卷积核的rank1分解</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>self-attention</td>
<td></td>
<td>n<em>c</em>c<em>3 + n</em>n*d</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RSA</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>权值共享度越高，参数越少</td>
<td></td>
<td></td>
<td></td>
<td>参数秩越高，映射能力越强。</td>
<td>减小特征图的秩，类似减少维度、增加正则约束、信息压缩</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>越少越好</td>
<td>越少越好</td>
<td></td>
<td></td>
<td></td>
<td>越高越好</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>这和映射能力是trade off的关系</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><img title="卷积网络架构" src="/images/raw/NN - CNN - WHC - cs231n.jpeg">

<p>feature map的维度[H,W,C]，通常称为[height, weight, channel/depth]</p>
<ul>
<li><strong>GConv</strong>: group convolution，分组卷积<ul>
<li>优势: 减少了计算量和参数量，组间独立类似稀疏约束</li>
<li>缺陷: 限制了通道之间信息的流动，降低了模型表达能力</li>
</ul>
</li>
<li>spatial conv，主要</li>
</ul>
<p>排除法</p>
<ul>
<li><strong>**wise</strong>: **-by-**的意思，逐个。<ul>
<li>组词: 一张张，一片片，一个个，一组组，逐点，逐张，逐个，逐组</li>
<li>在数学上的概念通常表示单元之间独立。</li>
</ul>
</li>
<li><strong>PWConv</strong>: pointwise convolution, 逐点卷积，[1,1,new_c]<ul>
<li>也叫position-wise，因为把每次操作一个position，f(position)，即position间独立(不交互)。</li>
<li>言外之意: <strong>除position以外，其他维度可以交互/不独立</strong>，比如<code>channel combination</code></li>
</ul>
</li>
<li><strong>DWConv</strong>: depthwise convolution, 逐通道卷积，也叫channelwise，<strong>channel by channel的意思</strong><ul>
<li>[w,h,c]</li>
<li>每次操作一个channel，以一个channel为操作对象，f(channel)，即channel间独立(不交互)，不同channel进行相同操作</li>
<li>言外之意: <strong>除channel以外，其他维度的交互</strong>,比如: <code>spatial convolution</code> performed independently over every channel of an input</li>
<li>depthwise则是极致的group，有多少个channel就分成多少组。讲的真清楚，但是这样做是不是<strong>太狠了</strong>？channel之间的交互一点都不剩了</li>
<li>实例：<ul>
<li>机器翻译中常用的attention，是position之间的交互，channel之间无交互</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>深度可分离卷积</strong>: 将普通的卷积运算拆分成逐通道卷积（depthwise convolution）和逐点卷积（pointwise convolution）两部进行，有效地减少了计算量和参数量；<em>减少了多少？</em></li>
</ul>
<p>pointwise group convolution怎么跟depthwise差不多啊？</p>
<ul>
<li>逐点群卷积</li>
</ul>
<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><ul>
<li>全连接，是[W,H,C]整个feature的全连接</li>
<li>卷积，是局部feature的全连接。<ul>
<li>即[w,h,c] 维度上的全连接</li>
<li>当$w<em>h</em>c$，计算量仍然很大</li>
<li>当w=W,h=H 时，也叫全卷积，就等价于全连接。</li>
</ul>
</li>
<li>1*1卷积是channel上的全连接</li>
</ul>
<p>这些实质是</p>
<ol>
<li><strong>利用稀疏连接(sparse connection)的方式来提高卷积的效率</strong>。</li>
<li>采用group/split的思想来实现稀疏，简单易行</li>
</ol>
<ul>
<li>一维卷积: 常用于序列模型，自然语言处理领域。</li>
<li>二维卷积: 常用于计算机视觉、图像处理领域</li>
<li>三维卷积: 常用于医学领域（CT影响），视频处理领域（时间维度）</li>
</ul>
<!--
3D卷积中[weight,height,time], 对这三个维度分解。 channel维度算不算？不算，channel维度是全连接的，但是也需要来分解
-->


<p><strong>一维卷积</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入特征图:</span> [<span class="string">n</span>,<span class="string">c</span>] <span class="comment"># channel即embedding</span></span><br><span class="line"><span class="string">卷积核:</span> [<span class="string">k</span>,<span class="string">c</span>,<span class="string">c</span>] <span class="comment"># 这里简化 c_out = c_in，当然也可以不相等</span></span><br><span class="line"><span class="string">输出特征图:</span> [<span class="string">n</span>,<span class="string">c</span>]</span><br></pre></td></tr></table></figure>


<p><strong>二维卷积</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入特征图:</span> [<span class="string">H</span>,<span class="string">W</span>,<span class="string">C</span>]</span><br><span class="line"><span class="string">卷积核:</span> [<span class="string">k</span>,<span class="string">k</span>,<span class="string">C</span>,<span class="string">C</span>]</span><br><span class="line"><span class="string">输出特征图:</span> [<span class="string">H&#x27;</span>,<span class="string">W&#x27;</span>,<span class="string">C&#x27;</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>参数</th>
<th>计算量</th>
<th>参数的秩</th>
<th>特征图的秩</th>
<th></th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>全连接</td>
<td>w<em>h</em>c1<em>w</em>h*c2</td>
<td>w<em>h</em>c1<em>w</em>h*c2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>conv</td>
<td>[k,k,c1,c2]</td>
<td>k<em>k</em>c1<em>c2</em>w*h</td>
<td></td>
<td></td>
<td></td>
<td>conv通过权值共享，大大减少参数，其次减少计算量</td>
</tr>
<tr>
<td>group-conv</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DSC</td>
<td>[k,k,c1] + [1,1,c1,c2]</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>对卷积核的rank2分解</td>
</tr>
<tr>
<td>Flattern-conv</td>
<td>[k,k,c1] + [1,1,c1,c2]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>对卷积核的rank1分解</td>
</tr>
</tbody></table>
<p><strong>三维卷积</strong><br>视频</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入特征图:</span> [<span class="string">T</span>,<span class="string">H</span>,<span class="string">W</span>,<span class="string">C</span>]</span><br><span class="line"><span class="string">卷积核:</span> [<span class="string">t</span>,<span class="string">k</span>,<span class="string">k</span>,<span class="string">C</span>,<span class="string">C&#x27;</span>]</span><br></pre></td></tr></table></figure>



<ul>
<li>计算量少</li>
<li>参数量少</li>
<li>内存消耗少</li>
<li>映射能力强</li>
<li>特征表达能力强</li>
</ul>
<p>这就是我们的需求，但是很多环节是trade off的关系。</p>
<h2 id="merge的方式"><a href="#merge的方式" class="headerlink" title="merge的方式"></a>merge的方式</h2><p>group限制了通道之间信息的流动，降低了模型表达能力，<br>所以group后一般都会再merge一次。即传统的split-transform-merge架构</p>
<ul>
<li><strong>concat</strong>:<ul>
<li>concat没有不同channel之间的融合，即仍然保持维度上的独立性。所以一般后面会接channel融合的策略，比如1*1卷积</li>
<li>实例: alexNet、Transformer、</li>
</ul>
</li>
<li><strong>升维 + sum/mean</strong>:<ul>
<li>一般group内的<strong>channel数需要还原</strong>。因为如果不还原直接add，group比较多的时候信息损失严重</li>
<li>实例: mobileNet</li>
</ul>
</li>
<li><strong>升维 + weighted-sum</strong>:<ul>
<li>实例: weighted-transformer、</li>
</ul>
</li>
<li><strong>shuffle</strong>: channel shuffle<ul>
<li>用处: Channel Shuffle for Group Convolutions</li>
<li>实例: ShuffleNet</li>
</ul>
</li>
<li><strong>其他策略呢？</strong></li>
</ul>
<h1 id="卷积-VS-全连接"><a href="#卷积-VS-全连接" class="headerlink" title="卷积 VS 全连接"></a>卷积 VS 全连接</h1><p>全连接的结构下会引起参数数量的膨胀，容易过拟合且局部最优。</p>
<p>CNN层改全连接为局部连接，这是由于图片的特殊性造成的（图像的一部分的统计特性与其他部分是一样的），通过<code>局部连接</code>和<code>参数共享</code>大范围的减少参数值。可以通过使用多个filter来提取图片的不同特征（多卷积核）。</p>
<blockquote>
<p>麻蛋，这是背课文啊。</p>
</blockquote>
<h1 id="卷积在深度学习中的应用"><a href="#卷积在深度学习中的应用" class="headerlink" title="卷积在深度学习中的应用"></a>卷积在深度学习中的应用</h1><blockquote>
<p>Convolutional neural networks therefore constitute a very useful tool for machine learning practitioners. However, learning to use CNNs for the first time is generally an intimidating experience.</p>
</blockquote>
<img title="边缘检测滤波器(卷积核)对图像的滤波(卷积)" src="http://wx2.sinaimg.cn/large/006Fmjmcly1fdwjpji6qtj30dw05d0t8.jpg">

<h2 id="CNN为什么work？"><a href="#CNN为什么work？" class="headerlink" title="CNN为什么work？"></a>CNN为什么work？</h2><ul>
<li>局部连接代替全连接，&amp; 权值共享</li>
<li>pooling层，</li>
<li>是</li>
</ul>
<h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><ul>
<li>2012年， 基于深度学习CNN网络的AlexNet在ILSVRC竞赛的ImageNet上大放异彩</li>
<li>检测: 2014年Ross Girshick利用CNN成功取代了HOG、DPM等特征提取， ross等人把目标检测分成了三个步骤，首先是对图像提取detection proposal，其实就是图像中一些可能是检测物体的区域，然后使用cnn对这些proposal进行特征提取，最后用svm对这些提取到的特征进行分类，从而完成检测的任务，这是 Two-stage object detectors鼻祖。</li>
</ul>
<h1 id="简单卷积"><a href="#简单卷积" class="headerlink" title="简单卷积"></a>简单卷积</h1><img title="" src="https://tracholar.github.io/assets/images/conv2d.gif">
<!-- http://cs231n.github.io/convolutional-networks/ -->

<img title="△ 卷积核为3、步幅为1和带有边界扩充的二维卷积结构" src="/images/raw/NN - CNN - 动态图.gif">

<p>卷积核为3、步幅为1和带有边界扩充的二维卷积结构</p>
<ul>
<li>卷积核大小（Kernel Size）：定义了卷积操作的感受野。在二维卷积中，通常设置为3，即卷积核大小为3×3。</li>
<li>步幅（Stride）：定义了卷积核遍历图像时的步幅大小。其默认值通常设置为1，也可将步幅设置为2后对图像进行下采样，这种方式与最大池化类似。</li>
<li>边界扩充（Padding）：定义了网络层处理样本边界的方式。当卷积核大于1且不进行边界扩充，输出尺寸将相应缩小；当卷积核以标准方式进行边界扩充，则输出数据的空间尺寸将与输入相等。</li>
<li>输入与输出通道（Channels）：构建卷积层时需定义输入通道I，并由此确定输出通道O。这样，可算出每个网络层的参数量为I×O×K，其中K为卷积核的参数个数。例，某个网络层有64个大小为3×3的卷积核，则对应K值为 3×3 =9。</li>
</ul>
<h1 id="卷积的变形"><a href="#卷积的变形" class="headerlink" title="卷积的变形"></a>卷积的变形</h1><ol>
<li>关于size</li>
</ol>
<ul>
<li>1, $1 \times 1$, $1 \times 1 \times 1$</li>
<li>全卷积</li>
</ul>
<ol>
<li>基于分组的</li>
</ol>
<ul>
<li>group conv</li>
</ul>
<ol>
<li>基于分解的</li>
<li>基于</li>
</ol>
<h2 id="基于拆分-分组的-split-group"><a href="#基于拆分-分组的-split-group" class="headerlink" title="基于拆分/分组的 split/group"></a>基于拆分/分组的 split/group</h2><h2 id="group-conv"><a href="#group-conv" class="headerlink" title="group conv"></a>group conv</h2><p>对channel 分group，然后各group独立，最后再合并。</p>
<h3 id="关于group之间是否共享卷积核？以及影响？"><a href="#关于group之间是否共享卷积核？以及影响？" class="headerlink" title="关于group之间是否共享卷积核？以及影响？"></a>关于group之间是否共享卷积核？以及影响？</h3><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>AlexNet中采用group conv的初衷是为了利用多GPU。为了减少GPU之间的交互带来的速度影响，只在特定的层才有共享权重</p>
<h2 id="最小-卷积核"><a href="#最小-卷积核" class="headerlink" title="最小 卷积核"></a>最小 卷积核</h2><p>最小的卷积核，在1维卷积中是kernel size为1的卷积，二维卷积中是kernel size为1*1的卷积。</p>
<p>这种卷积又被称为<a href="Mobilenets"><strong>Pointwise Convolution</strong></a>，即feature map上的<code>每个point采用相同的卷积操作</code>。</p>
<p><strong>作用</strong></p>
<p>在channel上升维、降维。</p>
<h3 id="1-times-1-卷积-二维卷积"><a href="#1-times-1-卷积-二维卷积" class="headerlink" title="$1 \times 1$ 卷积 (二维卷积)"></a>$1 \times 1$ 卷积 (二维卷积)</h3><p>针对[H,W,C]的输入，进行 1,1二维卷积</p>
<!-- i.e. a 1x1 convolution, projecting the channels output by the depthwise convolution onto a new channel space.
-->


<p>$$<br>[H,W,C] \xrightarrow[1 \times 1 \times in \times out]{conv2d}  [H’,W’,C’]<br>$$</p>
<p>1*1卷积并未对图像尺寸进行调整，仅仅是channel之间的融合。</p>
<p>当$out_channel &gt; in_channel$时，起到升维的作用；反之，则起到降维的作用。</p>
<p>1*1kernel广泛用于NIN、GoogLeNet、ResNet</p>
<p><strong>注意</strong></p>
<ul>
<li><strong>缺陷</strong>: 1*1卷积并未考虑空间邻域的信息，仅仅是channel之间的整合。所以一般会配合</li>
<li><strong>优势</strong>: 计算量小，参数少</li>
</ul>
<p><strong>实战架构</strong>:</p>
<ol>
<li><strong>构造bottleneck架构</strong>: <i class="fa fa-hourglass"></i></li>
</ol>
<ul>
<li>由于<code>1*1卷积</code>方便维度变换，很多网络构造bottleneck架构，即<em>高维的IO，低维的middle</em>，目的是在<em>低维下进行复杂运算，减少计算量</em>。</li>
<li><strong>注意</strong>: 不要为了bottleneck而bottleneck，其根本目的是为了减少计算量。要分析网络的计算瓶颈，再配已适当的策略才是正途。<!-- reducing and then increasing (restoring) dimensions, leaving the 3×3 layer a bottleneck with smaller input/output dimensions. --></li>
<li><strong>实例</strong>: NIN, GoogLeNet, <a href="">ResNet</a></li>
</ul>
<ol>
<li><strong>卷积的分解</strong></li>
</ol>
<ul>
<li>所有的depthwise seprable convolution</li>
<li>ss</li>
</ul>
<blockquote>
<p>对应一维卷积，就是kernel_size 为1卷积</p>
</blockquote>
<h2 id="最大卷积核-全卷积"><a href="#最大卷积核-全卷积" class="headerlink" title="最大卷积核 - 全卷积"></a>最大卷积核 - 全卷积</h2><p>全卷积(FCN)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意区别于FCN架构，见FCN.md</span><br></pre></td></tr></table></figure>


<h2 id="Transposed-Convolutions"><a href="#Transposed-Convolutions" class="headerlink" title="Transposed Convolutions"></a>Transposed Convolutions</h2><img title="△ 卷积核为3、步幅为2和无边界扩充的二维卷积结构" src="/images/raw/NN - CNN - 2D卷积 - 动态图.gif">

<img title="△ 卷积核为3×3、步幅为2和无边界扩充的二维转置卷积" src="/images/raw/NN - CNN - 2D卷积 - 转置卷积 - 动态图.gif">

<h1 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h1><p>Separable, Factorization</p>
<blockquote>
<p>应该是一个意思吧？</p>
</blockquote>
<ul>
<li><strong>Separable</strong><ul>
<li>即分离(split)的意思，将传统的一层conv分离为两层，一层用于filtering，一层用于combining<!-- splits this into two layers, a separate layer for filtering and a separate layer for combining. --></li>
<li>不可分离呢？</li>
</ul>
</li>
</ul>
<p>很自然我们会有两个疑问：为什么要分解？为什么能分解？</p>
<p><strong>为什么能分解？理论基础:</strong></p>
<p>实质是低秩矩阵分解，压缩参数，减少计算量。详见系列3</p>
<p><strong>为什么要分解？优势:</strong></p>
<ul>
<li>加速 <!-- fast --></li>
<li>少参 <!-- few parameter--></li>
<li>低秩约束 <!-- low rank regulation --></li>
</ul>
<!-- Depthwise separable convolutions reduce the number of parameters and computation used in convolutional operations while increasing representational efficiency. 提高表征效率？ -->

<p><strong>怎么分解？</strong></p>
<p>[n,c_in,c_out]的卷积核</p>
<ul>
<li>满秩分解</li>
<li>低秩矩阵分解<ul>
<li>rank=2: 张量乘法分解成两个矩阵乘法 <br><br>例如: 深度可分离卷积 <br><br>二维卷积(图像):$[h,w,C,C’] = [h,w,C] * [1 \times 1 \times c \times C’]$</li>
<li>Rank=1:  即tucker分解， <!-- 3D filter separation under rank-one assumption --><br>例如: inception中的某些拆分</li>
</ul>
</li>
</ul>
<h2 id="rank-2-深度可分离卷积"><a href="#rank-2-深度可分离卷积" class="headerlink" title="rank=2 深度可分离卷积"></a>rank=2 深度可分离卷积</h2><p>深度可分离卷积结构（depthwise separable convolution）</p>
<ul>
<li><strong>Depthwise</strong><ul>
<li><strong>depth</strong>: channel数<!-- depth is the number of channels or filters in a layer --></li>
<li><strong>depthwise</strong>: channel之间的操作是独立的，不交互的。<!-- -->
<!-- applies a single filter to each input channel; a spatial convolution performed independently over each channel of an input.--></li>
</ul>
</li>
</ul>
<p>DSC是分解卷积(factorized convolutions)的一种，它将常规的卷积<code>分解为一个depthwise conv与一个1*1 conv</code>。</p>
<ul>
<li>depthwise conv: 用于channel内的filtering</li>
<li>pointwise conv($1 \times 1$): 用于channel间的combining</li>
</ul>
<img title="Depthwise Separable convolution可以分解为1个depthwise conv和1个pointwise conv" src="/images/raw/NN - CNN - Depthwise Separable Convolutions - Diagonalwise Refactorization.png">

<p><a href="">图来源Diagonalwise Refactorization</a></p>
<p><strong>定义</strong>:</p>
<p>DepthSepConv defines kxk depthwise convolution followed by 1x1 convolution</p>
<ul>
<li>因为depthwise卷积是channel间独立的，所以一般会后接1*1卷积，做channel间的融合</li>
</ul>
<p>传统卷积<br>$$<br>[H,W,C] \xrightarrow[k \times k \times C \times C’]{conv2d} [H’,W’,C’]<br>$$</p>
<ul>
<li>卷积参数量: $k \times k \times C \times C’$</li>
<li>计算量:</li>
</ul>
<p><strong>参数</strong></p>
<ul>
<li>depth_multiplier:</li>
<li>ss</li>
</ul>
<p><strong>常见误区</strong></p>
<ul>
<li>depthwise = conv2d(k,w,C,1)。错误<ul>
<li>depthwise不同于常规的conv2d，是一种的卷积操作，需要经过cudnn加速才能有效果提升。cudnn7.0才开始支持该模块的加速 <!-- depthwise_conv2d applies a different filter to each input channel --></li>
<li>depthwise_conv(k,w,C)，没有那个1</li>
</ul>
</li>
<li>depthwise是对所有输入channel采用独立且相同的操作。错误<ul>
<li>只是独立操作，每个channel的操作不要求相同</li>
</ul>
</li>
<li></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2NTQzNDQ2NA==">为什么depthwise convolution 比 convolution更加耗时？ | 知乎<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>历史 &amp; 应用</strong></p>
<ul>
<li>Factorized Convolutional Neural Networks 2016 引用率很低</li>
<li>Rigid-motion scattering for image classification 2014 首次提出</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE1MDIuMDMxNjc=">Inception models<i class="fa fa-external-link-alt"></i></span>在前几层用到了，用于减小模型复杂度</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDQuMDQ4NjE=">MobileNet 2017 首次<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDMwNTk=">SliceNet 2017 | 机器翻译<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>factorized convolutions是什么鬼？</p>
<ul>
<li>Factorized Networks</li>
<li>Xception network</li>
<li>Squeezenet</li>
</ul>
<p>为什么能降低参数量，同时还能保持精度？</p>
<p>类似矩阵分解的思想。</p>
<p>Group conv是一种channel分组的方式，Depthwise +Pointwise是卷积的方式，只是ShuffleNet里面把两者应用起来了。因此Group conv和Depthwise +Pointwise并不能划等号。</p>
<p>而group卷积只是单纯的通道分组处理，降低复杂度。</p>
<h3 id="rank-1-Flatterned-Convolution"><a href="#rank-1-Flatterned-Convolution" class="headerlink" title="rank 1 - Flatterned Convolution"></a>rank 1 - Flatterned Convolution</h3><img title="Flatterned Convolution" src="/images/raw/NN - CNN - Flatterned Convolution.png">


<img title="Inception中，对n*n的卷积进行分解。该分解方式采用了rank 1分解" src="/images/raw/NN - CNN - Factorization rank1 - Inception.png">


<p><strong>一维卷积</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入特征图:</span> [<span class="string">n</span>,<span class="string">c</span>] <span class="comment"># channel即embedding</span></span><br><span class="line"><span class="string">卷积核:</span> [<span class="string">k</span>,<span class="string">c</span>,<span class="string">c</span>] <span class="comment"># rank=3. 这里简化 c_out = c_in，当然也可以不相等</span></span><br><span class="line"><span class="string">输出特征图:</span> [<span class="string">n</span>,<span class="string">c</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对卷积核进行rank 1分解</span></span><br><span class="line"><span class="string">卷积核1:</span> [<span class="string">k</span>,<span class="number">1</span>,<span class="number">1</span>]  <span class="string">-&gt;</span> [<span class="string">n</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">卷积核2:</span> [<span class="number">1</span>,<span class="string">c</span>,<span class="number">1</span>]  <span class="string">-&gt;</span></span><br><span class="line"><span class="string">卷积核3:</span> [<span class="number">1</span>,<span class="number">1</span>,<span class="string">c</span>]  <span class="string">-&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p><strong>二维卷积</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>三维卷积</strong></p>
<ul>
<li><a href="">Flattened convolution neural networks for feedforward acceleration</a></li>
</ul>
<h2 id="Dilated-Convolutions"><a href="#Dilated-Convolutions" class="headerlink" title="Dilated Convolutions"></a>Dilated Convolutions</h2><p>空洞卷积（atrous convolutions）又名扩张卷积（dilated convolutions），向卷积层引入了一个称为 “扩张率(dilation rate)”的新参数，该参数定义了卷积核处理数据时各值的间距。</p>
<img title="△ 卷积核为3、扩张率为2和无边界扩充的二维空洞卷积" src="/images/raw/NN - CNN - 空洞卷积 - 动态图.gif">

<p>一个扩张率为2的3×3卷积核，感受野与5×5的卷积核相同，而且仅需要9个参数。你可以把它想象成一个5×5的卷积核，每隔一行或一列删除一行或一列。</p>
<p>在相同的计算条件下，空洞卷积提供了更大的感受野。空洞卷积经常用在实时图像分割中。当网络层需要较大的感受野，但计算资源有限而无法提高卷积核数量或大小时，可以考虑空洞卷积。</p>
<p>应用：</p>
<ol>
<li>wavenet 音频信号太过密集，比较适合</li>
<li>SliceNet</li>
</ol>
<h2 id="Gated-Convolution"><a href="#Gated-Convolution" class="headerlink" title="Gated Convolution"></a>Gated Convolution</h2><ol>
<li>Language Modeling with Gated Convolutional Networks</li>
<li>Free-Form Image Inpainting with Gated Convolution。很牛逼的paper</li>
</ol>
<h1 id="计算量、复杂度汇总"><a href="#计算量、复杂度汇总" class="headerlink" title="计算量、复杂度汇总"></a>计算量、复杂度汇总</h1><p>时间复杂度、空间复杂度</p>
<p>计算量、复杂度的度量，通常用O()来计算。<br>神经网络也通常用FLOPS来计算。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input:</span>  [<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>]</span><br><span class="line"><span class="attr">kernel:</span> [<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">32</span>]</span><br><span class="line"><span class="attr">output:</span> [<span class="number">64</span>,<span class="number">64</span>,<span class="number">32</span>] <span class="comment"># same padding</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算量</span></span><br><span class="line"><span class="string">卷积的计算量:</span>   [<span class="number">5</span><span class="string">*5*3*64*64*32</span>]  <span class="comment"># 卷积比全连接，减少了非常多的计算量</span></span><br><span class="line"><span class="string">全连接的计算量:</span> [<span class="number">64</span><span class="string">*64*3*64*64*32</span>]</span><br><span class="line"><span class="number">3</span><span class="string">-group的计算量:</span> []</span><br><span class="line"><span class="string">DSC的计算量:</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数量</span></span><br><span class="line"><span class="string">卷积的参数量:</span>   [<span class="number">5</span><span class="string">*5*3*32</span>]    <span class="comment"># 少量的参数，通过参数共享/复用，发挥了强大的作用，能防止模型过拟合</span></span><br><span class="line"><span class="string">全连接的参数量:</span> [<span class="number">64</span><span class="string">*64*3*64*64*32</span>]   <span class="comment"># 注意，如此大的参数量</span></span><br></pre></td></tr></table></figure>

<p>参数共享是一个神奇的东西，参数量剧减，模型小了非常多。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li>Andrew Ng 的UFLDL教程</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pa2hsZXN0b3YuZ2l0aHViLmlvL3BhZ2VzL21hY2hpbmUtbGVhcm5pbmcvY29udm9sdXRpb25zLXR5cGVzLw==">各种卷积结构原理及优劣 | Medium<i class="fa fa-external-link-alt"></i></span>  比较新</li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b3dhcmRzZGF0YXNjaWVuY2UuY29tL3R5cGVzLW9mLWNvbnZvbHV0aW9ucy1pbi1kZWVwLWxlYXJuaW5nLTcxNzAxMzM5N2Y0ZA==">一文了解各种卷积结构原理及优劣 | Medium<i class="fa fa-external-link-alt"></i></span> &amp; <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODE4Njg1Nw==">中文翻译|知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3RpbWRldHRtZXJzLmNvbS8yMDE1LzAzLzI2L2NvbnZvbHV0aW9uLWRlZXAtbGVhcm5pbmcv">理解深度学习中的卷积 | Tim Dettmers<i class="fa fa-external-link-alt"></i></span> &amp; <span class="exturl" data-url="aHR0cDovL3d3dy5oYW5rY3MuY29tL21sL3VuZGVyc3RhbmRpbmctdGhlLWNvbnZvbHV0aW9uLWluLWRlZXAtbGVhcm5pbmcuaHRtbA==">中文翻译 | 码农场<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NvbGFoLmdpdGh1Yi5pby9wb3N0cy8yMDE0LTA3LVVuZGVyc3RhbmRpbmctQ29udm9sdXRpb25zLw==">Understanding Convolutions | colah<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU0Njc3MTU3">卷积为什么叫「卷」积？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMjk4MzUy">如何通俗易懂地解释卷积？ | 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="..">A guide to convolution arithmetic for deep learning</a></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>model-basic</category>
        <category>CNN</category>
        <category>卷积</category>
      </categories>
  </entry>
  <entry>
    <title>【java源码系列】 - Object</title>
    <url>/pub/1c98e0dc/</url>
    <content><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>Object.java(rt.jar) 调用 jdk的native方法(Object.c)。</li>
<li>native方法 调用hotspot jvm的方法(jvm.cpp)。</li>
</ul>
<h2 id="Object-java"><a href="#Object-java" class="headerlink" title="Object.java"></a>Object.java</h2><ul>
<li>java source版本：oracle 1.7</li>
</ul>
<p>Object 还有隐形的构造函数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Object();</span><br><span class="line">new Object[int]; // 在ArrayList的构造函数中用到了</span><br></pre></td></tr></table></figure>

<p>疑问：</p>
<h3 id="为什么Object-java中看不到构造函数"><a href="#为什么Object-java中看不到构造函数" class="headerlink" title="为什么Object.java中看不到构造函数"></a>为什么Object.java中看不到构造函数</h3><p>编译器为它生成了构造函数</p>
<h3 id="为什么在stack-trace中看不到调用Object"><a href="#为什么在stack-trace中看不到调用Object" class="headerlink" title="为什么在stack trace中看不到调用Object."></a>为什么在stack trace中看不到调用Object.<init></h3><p>有7个native方法。</p>
<ul>
<li>private static native void registerNatives();</li>
<li>protected native Object clone() throws CloneNotSupportedException;</li>
<li>public final native Class&lt;?&gt; getClass();</li>
<li>public native int hashCode();</li>
<li>public final native void notify();</li>
<li>public final native void notifyAll();</li>
<li>public final native void wait(long timeout) throws InterruptedException;</li>
</ul>
<ul>
<li>但是构造函数是怎样实现的呢？(见jvm目录的init.md)</li>
</ul>
<p>由于Object类中有JNI方法调用，按照JNI的规则，应当生成JNI 的头文件。<br>在此目录下执行javah -jni java.lang.Object 指令，将生成一个java_lang_Object.h头文件(自动生成的header，没什么意义)</p>
<h2 id="Object-c"><a href="#Object-c" class="headerlink" title="Object.c"></a>Object.c</h2><ul>
<li>source版本：openjdk-7-fcs-src-b147-27_jun_2011</li>
<li>路径: openjdk\jdk\src\share\native\java\lang\Object.c</li>
<li>没有Object.h</li>
</ul>
<p>Object.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-</span></span><br><span class="line"><span class="comment"> *      Implementation of class Object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      former threadruntime.c, Sun Sep 22 12:09:39 1991</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jni.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jni_util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jvm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;java_lang_Object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM_这些函数是在jvm.c中实现的</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hashCode&quot;</span>,    <span class="string">&quot;()I&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,  <span class="comment">//  返回int</span></span><br><span class="line">    &#123;<span class="string">&quot;wait&quot;</span>,        <span class="string">&quot;(J)V&quot;</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;, <span class="comment">// 返回void，参数是long</span></span><br><span class="line">    &#123;<span class="string">&quot;notify&quot;</span>,      <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,  <span class="comment">// 返回void</span></span><br><span class="line">    &#123;<span class="string">&quot;notifyAll&quot;</span>,   <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;, <span class="comment">// 返回void</span></span><br><span class="line">    &#123;<span class="string">&quot;clone&quot;</span>,       <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;, <span class="comment">// 返回Ojbect</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_Object_registerNatives</span><span class="params">(JNIEnv *env, jclass cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls,</span><br><span class="line">                            methods, <span class="keyword">sizeof</span>(methods)/<span class="keyword">sizeof</span>(methods[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jclass JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_Object_getClass</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        JNU_ThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*env)-&gt;GetObjectClass(env, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中JNINativeMethod的结构体如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name; <span class="comment">// Java中函数的名字</span></span><br><span class="line">    <span class="keyword">char</span> *signature; <span class="comment">// signature 方法签名，描述了函数的参数和返回值</span></span><br><span class="line">    <span class="keyword">void</span> *fnPtr;  <span class="comment">// native实现的函数指针，指向C函数</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>


<h2 id="跟踪-hashcode"><a href="#跟踪-hashcode" class="headerlink" title="跟踪 hashcode"></a>跟踪 hashcode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jvm.h 路径: openjdk\hotspot\src\share\vm\prims\jvm.h</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">JVM_IHashCode</span><span class="params">(JNIEnv *env, jobject obj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// jvm.cpp 路径: openjdk\hotspot\src\share\vm\prims\jvm.cpp</span></span><br><span class="line">JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_IHashCode&quot;</span>);</span><br><span class="line">  <span class="comment">// as implemented in the classic virtual machine; return 0 if object is NULL</span></span><br><span class="line">  <span class="keyword">return</span> handle == <span class="literal">NULL</span> ? <span class="number">0</span> : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>FastHashCode才是真正计算hashcode的代码</p>
<h3 id="FastHashCode"><a href="#FastHashCode" class="headerlink" title="FastHashCode"></a>FastHashCode</h3><p>这是hashCode()的具体实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径: openjdk\hotspot\src\share\vm\runtime\synchronizer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">ObjectSynchronizer::FastHashCode</span> <span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> many places throughout the JVM do not expect a safepoint</span></span><br><span class="line">    <span class="comment">// to be taken here, in particular most operations on perm gen</span></span><br><span class="line">    <span class="comment">// objects. However, we only ever bias Java instances and all of</span></span><br><span class="line">    <span class="comment">// the call sites of identity_hash that might revoke biases have</span></span><br><span class="line">    <span class="comment">// been checked to make sure they can handle a safepoint. The</span></span><br><span class="line">    <span class="comment">// added check of the bias pattern is to avoid useless calls to</span></span><br><span class="line">    <span class="comment">// thread-local storage.</span></span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;mark()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">      <span class="comment">// Box and unbox the raw reference just in case we cause a STW safepoint.</span></span><br><span class="line">      <span class="function">Handle <span class="title">hobj</span> <span class="params">(Self, obj)</span> </span>;</span><br><span class="line">      <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">      assert (Universe::verify_in_progress() ||</span><br><span class="line">              !SafepointSynchronize::is_at_safepoint(),</span><br><span class="line">             <span class="string">&quot;biases should not be seen by VM thread here&quot;</span>);</span><br><span class="line">      BiasedLocking::revoke_and_rebias(hobj, <span class="literal">false</span>, JavaThread::current());</span><br><span class="line">      obj = hobj() ;</span><br><span class="line">      assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hashCode() is a heap mutator ...</span></span><br><span class="line">  <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">  assert (Universe::verify_in_progress() ||</span><br><span class="line">          !SafepointSynchronize::is_at_safepoint(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  assert (Universe::verify_in_progress() ||</span><br><span class="line">          Self-&gt;is_Java_thread() , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  assert (Universe::verify_in_progress() ||</span><br><span class="line">         ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  ObjectMonitor* monitor = <span class="literal">NULL</span>;</span><br><span class="line">  markOop temp, test;</span><br><span class="line">  <span class="keyword">intptr_t</span> hash;</span><br><span class="line">  markOop mark = ReadStableMark (obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// object should remain ineligible for biased locking</span></span><br><span class="line">  assert (!mark-&gt;has_bias_pattern(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    hash = mark-&gt;hash();              <span class="comment">// this is a normal header 对象的hashcode存储在对象头里</span></span><br><span class="line">    <span class="keyword">if</span> (hash) &#123;                       <span class="comment">// if it has hash, just return it 注意这里有个cache，对于同一个Ojbect，第一次调用Object.hashCode将会执行实际的计算并记入cache，以后直接从cache中取出。</span></span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    hash = get_next_hash(Self, obj);  <span class="comment">// allocate a new hash code</span></span><br><span class="line">    temp = mark-&gt;copy_set_hash(hash); <span class="comment">// merge the hash code into header</span></span><br><span class="line">    <span class="comment">// use (machine word version) atomic operation to install the hash</span></span><br><span class="line">    test = (markOop) Atomic::cmpxchg_ptr(temp, obj-&gt;mark_addr(), mark);</span><br><span class="line">    <span class="keyword">if</span> (test == mark) &#123;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If atomic operation failed, we must inflate the header</span></span><br><span class="line">    <span class="comment">// into heavy weight monitor. We could add more code here</span></span><br><span class="line">    <span class="comment">// for fast path, but it does not worth the complexity.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;has_monitor()) &#123;</span><br><span class="line">    monitor = mark-&gt;monitor();</span><br><span class="line">    temp = monitor-&gt;header();</span><br><span class="line">    assert (temp-&gt;is_neutral(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    hash = temp-&gt;hash();</span><br><span class="line">    <span class="keyword">if</span> (hash) &#123;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Skip to the following code to reduce code size</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Self-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    temp = mark-&gt;displaced_mark_helper(); <span class="comment">// this is a lightweight monitor owned</span></span><br><span class="line">    assert (temp-&gt;is_neutral(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    hash = temp-&gt;hash();              <span class="comment">// by current thread, check if the displaced</span></span><br><span class="line">    <span class="keyword">if</span> (hash) &#123;                       <span class="comment">// header contains hash code</span></span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// WARNING:</span></span><br><span class="line">    <span class="comment">//   The displaced header is strictly immutable.</span></span><br><span class="line">    <span class="comment">// It can NOT be changed in ANY cases. So we have</span></span><br><span class="line">    <span class="comment">// to inflate the header into heavyweight monitor</span></span><br><span class="line">    <span class="comment">// even the current thread owns the lock. The reason</span></span><br><span class="line">    <span class="comment">// is the BasicLock (stack slot) will be asynchronously</span></span><br><span class="line">    <span class="comment">// read by other threads during the inflate() function.</span></span><br><span class="line">    <span class="comment">// Any change to stack may not propagate to other threads</span></span><br><span class="line">    <span class="comment">// correctly.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inflate the monitor to set hash code</span></span><br><span class="line">  monitor = ObjectSynchronizer::inflate(Self, obj);</span><br><span class="line">  <span class="comment">// Load displaced header and check it has hash code</span></span><br><span class="line">  mark = monitor-&gt;header();</span><br><span class="line">  assert (mark-&gt;is_neutral(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  hash = mark-&gt;hash();  <span class="comment">// 取出缓存</span></span><br><span class="line">  <span class="keyword">if</span> (hash == <span class="number">0</span>) &#123;</span><br><span class="line">    hash = get_next_hash(Self, obj);  <span class="comment">// 实际计算</span></span><br><span class="line">    temp = mark-&gt;copy_set_hash(hash); <span class="comment">// merge hash code into header</span></span><br><span class="line">    assert (temp-&gt;is_neutral(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    test = (markOop) Atomic::cmpxchg_ptr(temp, monitor, mark);</span><br><span class="line">    <span class="keyword">if</span> (test != mark) &#123;</span><br><span class="line">      <span class="comment">// The only update to the header in the monitor (outside GC)</span></span><br><span class="line">      <span class="comment">// is install the hash code. If someone add new usage of</span></span><br><span class="line">      <span class="comment">// displaced header, please update this code</span></span><br><span class="line">      hash = test-&gt;hash();</span><br><span class="line">      assert (test-&gt;is_neutral(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      assert (hash != <span class="number">0</span>, <span class="string">&quot;Trivial unexpected object/monitor header usage.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We finally get the hash</span></span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-next-hash"><a href="#get-next-hash" class="headerlink" title="get_next_hash"></a>get_next_hash</h3><p>这才是核心代码</p>
<p>又调用的<code>get_next_hash()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径: openjdk\hotspot\src\share\vm\runtime\synchronizer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::random() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = <span class="keyword">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="keyword">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  assert (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  TEVENT (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode()并不是简单的返回内存地址。<br>OpenJDK一共实现了5中不同的计算hash值的方法，通过<br>这段代码中hashCode进行切换。其中hashCode == 4的是直接使用地址的（前面的实验说明OpenJDK默认情况下并没有使用这种方式，或许可以通过运行/编译时参数进行选择）。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>前面通过JNI验证已经能够得到很显然的结论，hashCode返回的并不一定是对象的（虚拟）内存地址，具体取决于运行时库和JVM的具体实现。</p>
<h2 id="跟踪wait"><a href="#跟踪wait" class="headerlink" title="跟踪wait"></a>跟踪wait</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">JVM_MonitorWait</span><span class="params">(JNIEnv *env, jobject obj, jlong ms)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cpp</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_MonitorWait&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">&quot;JVM_MonitorWait must apply to an object&quot;</span>);</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_monitor_wait()) &#123;</span><br><span class="line">    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::wait(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<h2 id="跟踪notify"><a href="#跟踪notify" class="headerlink" title="跟踪notify"></a>跟踪notify</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">JVM_MonitorNotify</span><span class="params">(JNIEnv *env, jobject obj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cpp</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_MonitorNotify(JNIEnv* env, jobject handle))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_MonitorNotify&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  assert(obj-&gt;is_instance() || obj-&gt;is_array(), <span class="string">&quot;JVM_MonitorNotify must apply to an object&quot;</span>);</span><br><span class="line">  ObjectSynchronizer::notify(obj, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<h2 id="跟踪clone"><a href="#跟踪clone" class="headerlink" title="跟踪clone"></a>跟踪clone</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">JVM_Clone(JNIEnv *env, jobject obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cpp</span><br><span class="line">JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))</span><br><span class="line">  JVMWrapper(&quot;JVM_Clone&quot;);</span><br><span class="line">  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));</span><br><span class="line">  const KlassHandle klass (THREAD, obj-&gt;klass());</span><br><span class="line">  JvmtiVMObjectAllocEventCollector oam;</span><br></pre></td></tr></table></figure>

<h2 id="跟踪-getClass"><a href="#跟踪-getClass" class="headerlink" title="跟踪 getClass"></a>跟踪 getClass</h2><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVzaXdlaTEyMzYvYXJ0aWNsZS9kZXRhaWxzLzQ1MTUyMjAx">http://blog.csdn.net/xusiwei1236/article/details/45152201<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="byte-code"><a href="#byte-code" class="headerlink" title="byte code"></a>byte code</h2><ul>
<li>通过编译后的jar包(即class文件)，查看byte code.</li>
<li>运行 javap -c java.lang.Object &gt; a.txt，得到以下的byte code</li>
</ul>
<p>如果执行不成功，看看是否把jdk的lib加入到了classpath:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;Object.java&quot;</span><br><span class="line">public class java.lang.Object &#123;</span><br><span class="line">  public java.lang.Object();  // 什么都不干？不需要调用&lt;init&gt;吗？</span><br><span class="line">    Code:</span><br><span class="line">       0: return        </span><br><span class="line"></span><br><span class="line">  public final native java.lang.Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">  public native int hashCode();</span><br><span class="line"></span><br><span class="line">  public boolean equals(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: aload_1       </span><br><span class="line">       2: if_acmpne     9</span><br><span class="line">       5: iconst_1      </span><br><span class="line">       6: goto          10</span><br><span class="line">       9: iconst_0      </span><br><span class="line">      10: ireturn       </span><br><span class="line"></span><br><span class="line">  protected native java.lang.Object clone() throws java.lang.CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">  public java.lang.String toString();</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #1                  // class java/lang/StringBuilder</span><br><span class="line">       3: dup           </span><br><span class="line">       4: invokespecial #2                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V           // 注意这里，调用了&lt;init&gt;</span><br><span class="line">       7: aload_0       </span><br><span class="line">       8: invokevirtual #3                  // Method getClass:()Ljava/lang/Class;</span><br><span class="line">      11: invokevirtual #4                  // Method java/lang/Class.getName:()Ljava/lang/String;</span><br><span class="line">      14: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      17: ldc           #6                  // String @</span><br><span class="line">      19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      22: aload_0       </span><br><span class="line">      23: invokevirtual #7                  // Method hashCode:()I</span><br><span class="line">      26: invokestatic  #8                  // Method java/lang/Integer.toHexString:(I)Ljava/lang/String;</span><br><span class="line">      29: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      32: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      35: areturn       </span><br><span class="line"></span><br><span class="line">  public final native void notify();</span><br><span class="line"></span><br><span class="line">  public final native void notifyAll();</span><br><span class="line"></span><br><span class="line">  public final native void wait(long) throws java.lang.InterruptedException;</span><br><span class="line"></span><br><span class="line">  public final void wait(long, int) throws java.lang.InterruptedException;</span><br><span class="line">    Code:</span><br><span class="line">       0: lload_1       </span><br><span class="line">       1: lconst_0      </span><br><span class="line">       2: lcmp          </span><br><span class="line">       3: ifge          16</span><br><span class="line">       6: new           #10                 // class java/lang/IllegalArgumentException</span><br><span class="line">       9: dup           </span><br><span class="line">      10: ldc           #11                 // String timeout value is negative</span><br><span class="line">      12: invokespecial #12                 // Method java/lang/IllegalArgumentException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">      15: athrow        </span><br><span class="line">      16: iload_3       </span><br><span class="line">      17: iflt          26</span><br><span class="line">      20: iload_3       </span><br><span class="line">      21: ldc           #13                 // int 999999</span><br><span class="line">      23: if_icmple     36</span><br><span class="line">      26: new           #10                 // class java/lang/IllegalArgumentException</span><br><span class="line">      29: dup           </span><br><span class="line">      30: ldc           #14                 // String nanosecond timeout value out of range</span><br><span class="line">      32: invokespecial #12                 // Method java/lang/IllegalArgumentException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">      35: athrow        </span><br><span class="line">      36: iload_3       </span><br><span class="line">      37: ldc           #15                 // int 500000</span><br><span class="line">      39: if_icmpge     52</span><br><span class="line">      42: iload_3       </span><br><span class="line">      43: ifeq          56</span><br><span class="line">      46: lload_1       </span><br><span class="line">      47: lconst_0      </span><br><span class="line">      48: lcmp          </span><br><span class="line">      49: ifne          56</span><br><span class="line">      52: lload_1       </span><br><span class="line">      53: lconst_1      </span><br><span class="line">      54: ladd          </span><br><span class="line">      55: lstore_1      </span><br><span class="line">      56: aload_0       </span><br><span class="line">      57: lload_1       </span><br><span class="line">      58: invokevirtual #16                 // Method wait:(J)V</span><br><span class="line">      61: return        </span><br><span class="line"></span><br><span class="line">  public final void wait() throws java.lang.InterruptedException;</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: lconst_0      </span><br><span class="line">       2: invokevirtual #16                 // Method wait:(J)V</span><br><span class="line">       5: return        </span><br><span class="line"></span><br><span class="line">  protected void finalize() throws java.lang.Throwable;</span><br><span class="line">    Code:</span><br><span class="line">       0: return        </span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #17                 // Method registerNatives:()V</span><br><span class="line">       3: return        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C:\Program Files\java\jdk1.7.0_67\jre\lib\rt&gt;</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>object header: it’s JVM dependent， 具体参考JVM</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2Jsb2cveHVzaXdlaTEyMzYvYXJ0aWNsZS9wLTM1MjQ5Lmh0bWw=">Object.hashCode()的返回值到底是不是对象内存地址<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>java</category>
        <category>jdk</category>
        <category>rt</category>
        <category>lang</category>
      </categories>
  </entry>
  <entry>
    <title>Python Dict对象源码</title>
    <url>/pub/21b9dcd/</url>
    <content><![CDATA[<h1 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h1><p>Dictionary object implementation using a hash table ，通过描述可知，python 的字典就是实现了一个 hash 表。</p>
<h2 id="Python-字典概述"><a href="#Python-字典概述" class="headerlink" title="Python 字典概述"></a>Python 字典概述</h2><p>在 python 的字典中，一个键值对的对应保存就是 PyDictEntry 类型来保存；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdC1jb21tb24uaCNMMQ==">Include/dict-common.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dict-common.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Cached hash code of me_key. */</span></span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value; <span class="comment">/* This field is only meaningful for combined tables */</span></span><br><span class="line">&#125; PyDictKeyEntry;　</span><br></pre></td></tr></table></figure>



<p>其中，me_hash 就是哈希生成的值，me_key 就是对应的 key 值，me_value 就是对应的值。<br>在 python 中，在一个 PyDictObject 对象的变化过程中，entry 的状态会在不同的状态间转换。基本上在如下四种状态中转换：Unused、Active、Dummy 和 Pending。</p>
<ol>
<li>Unused:没有插入任何一个获取的 key 与 value，并且在此之前也没有存储任何的 key,value，每一个 entry 在初始化的时候都会处于这种状态，并且 Unused 会被里面切换到 Active 态，当有 key 插入，这就是 entry 初始化的状态。</li>
<li>Active:当 index&gt;=0 时，me_key 不为空并且 me_value 不为空，保存了一个键值对，Active 可以转变为 Dummy 或者 Pending 状态，当一个键被删除的时候，这只会在 me_value 不为空的时候出现。</li>
<li>Dummy:先前保存了一个 Active 的键值对，但是这个键值对被删除了并且一个活跃的键值对还没有填入该位置，Dummy 可以转变为 Active 当删除的时候，Dummy 的位置不能被重新使用，一旦发生碰撞，探针序列就无法知道这对键值对曾是活跃的键值对。</li>
<li>Pending:索引&gt;=0，键!=空，值=空（仅拆分），尚未插入到拆分表中。</li>
</ol>
<h2 id="字典的两种类型"><a href="#字典的两种类型" class="headerlink" title="字典的两种类型"></a>字典的两种类型</h2><p>python 的字典类型中包含了两种，分离字典（split-table dictionaries)与联合字典(combined-table dictonaries)。详细的信息可查看有关 dict 的描述<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDQxMi8=">pep-0412<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="split-table-dictionaries"><a href="#split-table-dictionaries" class="headerlink" title="split-table dictionaries"></a>split-table dictionaries</h3><p>当被创建的字典是用来保存 object 的<code>__dict__</code>属性时，该字典才会创建为一个 split-table，它们的键表都被缓存在类型属性中，并且允许所有该类型的实例都可以共享该 keys。当出现一个事件将字典的属性值进行改变的时候，个别字典将慢慢的转化成组合表的形式。这就保证了在大部分的应用场景下很高的内存利用效率，并保证了在各个场景下的正确性。当 split-dict 重新改变大小，它会立马改变为一个 combined-table，如果重置大小作为保存实例属性的结果，并且只有一个该 object 的实例，字典会立马再变为一个 split-table。如果从 split-table 中删除一个 key, value，它不会删除 keys tables 中对应的该值，而只是将 values 数值中移除了该 value。</p>
<h3 id="combined-table-dictionaries"><a href="#combined-table-dictionaries" class="headerlink" title="combined-table dictionaries"></a>combined-table dictionaries</h3><p>直接通过 dict 內建函数与{}生成的字典，模块和大部分其他字典都会创建为 combined-table 字典，一个 combined-table 不会改变为一个 split-table 字典，该字典的行为方式与最初的字典的行为方式大致相同。</p>
<h2 id="容器的相关数据结构"><a href="#容器的相关数据结构" class="headerlink" title="容器的相关数据结构"></a>容器的相关数据结构</h2><p>字典对象是通过 PyDictObject 来实现数据的，详情如下；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL0luY2x1ZGUvZGljdG9iamVjdC5oI0wxNw==">Include/dictobject.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/dictobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> <span class="title">PyDictKeysObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The ma_values pointer is NULL for a combined table</span></span><br><span class="line"><span class="comment"> * or points to an array of PyObject* for a split table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of items in the dictionary */</span></span><br><span class="line">    Py_ssize_t ma_used;　				<span class="comment">// 使用的keys个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dictionary version: globally unique, value change each time</span></span><br><span class="line"><span class="comment">       the dictionary is modified */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ma_version_tag;</span><br><span class="line"></span><br><span class="line">    PyDictKeysObject *ma_keys;　　　　　<span class="comment">// 如果有则是保存的keys数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If ma_values is NULL, the table is &quot;combined&quot;: keys and values</span></span><br><span class="line"><span class="comment">       are stored in ma_keys.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If ma_values is not NULL, the table is splitted:</span></span><br><span class="line"><span class="comment">       keys are stored in ma_keys and values are stored in ma_values */</span></span><br><span class="line">    PyObject **ma_values;　			 <span class="comment">// 如果不为空则保存的是values</span></span><br><span class="line">&#125; PyDictObject;</span><br></pre></td></tr></table></figure>

<p>其中，PyDictKeysObject 的定义如下；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdC1jb21tb24uaCNMMjA=">Include/dict-common.h<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dict-common.h</span></span><br><span class="line"><span class="comment">/* See dictobject.c for actual layout of DictKeysObject */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictkeysobject</span> &#123;</span></span><br><span class="line">    Py_ssize_t dk_refcnt;　　　　　　　　　　　　　　　　　　<span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size of the hash table (dk_indices). It must be a power of 2. */</span></span><br><span class="line">    Py_ssize_t dk_size;　　　　　　　　　　　　　　　　　　　<span class="comment">// hash table 的大小必须是２的倍数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function to lookup in the hash table (dk_indices):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict(): general-purpose, and may return DKIX_ERROR if (and</span></span><br><span class="line"><span class="comment">         only if) a comparison raises an exception.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode(): specialized to Unicode string keys, comparison of</span></span><br><span class="line"><span class="comment">         which can never raise an exception; that function can never return</span></span><br><span class="line"><span class="comment">         DKIX_ERROR.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further</span></span><br><span class="line"><span class="comment">         specialized for Unicode string keys that cannot be the &lt;dummy&gt; value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - lookdict_split(): Version of lookdict() for split tables. */</span></span><br><span class="line">    dict_lookup_func dk_lookup;                       <span class="comment">// 哈希查找函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of usable entries in dk_entries. */</span></span><br><span class="line">    Py_ssize_t dk_usable;                             <span class="comment">// 可用的entry数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of used entries in dk_entries. */</span>　</span><br><span class="line">    Py_ssize_t dk_nentries;　　　　　　　　　            <span class="comment">// 已经使用的entry数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries,</span></span><br><span class="line"><span class="comment">       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The size in bytes of an indice depends on dk_size:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       - 1 byte if dk_size &lt;= 0xff (char*)</span></span><br><span class="line"><span class="comment">       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)</span></span><br><span class="line"><span class="comment">       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)</span></span><br><span class="line"><span class="comment">       - 8 bytes otherwise (int64_t*)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span><br><span class="line">    <span class="keyword">char</span> dk_indices[];  <span class="comment">/* char is required to avoid strict aliasing. */</span>　　　<span class="comment">// 存入的entries</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;PyDictKeyEntry dk_entries[dk_usable];&quot; array follows:</span></span><br><span class="line"><span class="comment">       see the DK_ENTRIES() macro */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关数据结构的内存布局为；<br><img src="dict-mem.png" alt="python_dict_mem"></p>
<h2 id="Python-字典示例"><a href="#Python-字典示例" class="headerlink" title="Python 字典示例"></a>Python 字典示例</h2><p>本次示例脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;1&#x27;</span>]=<span class="string">&#x27;2&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;1&#x27;</span>]=<span class="string">&#x27;e&#x27;</span></span><br><span class="line">d.pop(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 Python 的反汇编工具获取字节码；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m dis dict_test.py</span><br></pre></td></tr></table></figure>

<p>输出的字节码如下；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2           0 BUILD_MAP                0</span><br><span class="line">            2 STORE_NAME               0 (d)</span><br><span class="line"></span><br><span class="line">3           4 LOAD_CONST               0 (&#x27;2&#x27;)</span><br><span class="line">            6 LOAD_NAME                0 (d)</span><br><span class="line">            8 LOAD_CONST               1 (&#x27;1&#x27;)</span><br><span class="line">           10 STORE_SUBSCR</span><br><span class="line"></span><br><span class="line">4          12 LOAD_CONST               2 (&#x27;e&#x27;)</span><br><span class="line">           14 LOAD_NAME                0 (d)</span><br><span class="line">           16 LOAD_CONST               1 (&#x27;1&#x27;)</span><br><span class="line">           18 STORE_SUBSCR</span><br><span class="line"></span><br><span class="line">5          20 LOAD_NAME                0 (d)</span><br><span class="line">           22 LOAD_METHOD              1 (pop)</span><br><span class="line">           24 LOAD_CONST               1 (&#x27;1&#x27;)</span><br><span class="line">           26 CALL_METHOD              1</span><br><span class="line">           28 POP_TOP</span><br><span class="line">           30 LOAD_CONST               3 (None)</span><br><span class="line">           32 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>通过字节码指令可知，首先调用了 BUILD_MAP 来创建一个新的字典，接着就对新建的字典 d 进行了赋值操作与更新操作，最后调用了 pop 方法删除一个 key。接下来就详细分析一下相关流程。</p>
<h2 id="字典的初始化流程"><a href="#字典的初始化流程" class="headerlink" title="字典的初始化流程"></a>字典的初始化流程</h2><p>通过查找 BUILD_MAP 的虚拟机执行函数；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL1B5dGhvbi9jZXZhbC5jI0wyMzU3">Python/ceval.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Python/ceval.c</span></span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    TARGET(BUILD_MAP) &#123;</span><br><span class="line">        Py_ssize_t i;</span><br><span class="line">        PyObject *<span class="built_in">map</span> = _PyDict_NewPresized((Py_ssize_t)oparg);    <span class="comment">// 新建并初始化一个字典</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;　                                          <span class="comment">// 如果新建失败则报错</span></span><br><span class="line">        <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;　                          　<span class="comment">// 检查在新建的过程中是否通过参数传值</span></span><br><span class="line">            <span class="keyword">int</span> err;</span><br><span class="line">            PyObject *key = PEEK(<span class="number">2</span>*i);</span><br><span class="line">            PyObject *value = PEEK(<span class="number">2</span>*i - <span class="number">1</span>);</span><br><span class="line">            err = PyDict_SetItem(<span class="built_in">map</span>, key, value);　　        　　　<span class="comment">// 找到对应的值并讲该值设置到map中</span></span><br><span class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 检查是否报错</span></span><br><span class="line">                Py_DECREF(<span class="built_in">map</span>);</span><br><span class="line">                <span class="keyword">goto</span> error;　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 如果错误就报错处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (oparg--) &#123;</span><br><span class="line">            Py_DECREF(POP());　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 弹出栈上输入参数的引用</span></span><br><span class="line">            Py_DECREF(POP());</span><br><span class="line">        &#125;</span><br><span class="line">        PUSH(<span class="built_in">map</span>);　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 讲生成的map压栈</span></span><br><span class="line">        DISPATCH();　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 检查是否需要执行下一条字节码指令</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该函数的执行可知，初始化的函数是从_PyDict_NewPresized 开始，该函数就是生成并初始化一个字典；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0wxMjQw">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyDict_NewPresized(Py_ssize_t minused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Py_ssize_t max_presize = <span class="number">128</span> * <span class="number">1024</span>;　         <span class="comment">// 字典最大的容量</span></span><br><span class="line">    Py_ssize_t newsize;</span><br><span class="line">    PyDictKeysObject *new_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There are no strict guarantee that returned dict can contain minused</span></span><br><span class="line"><span class="comment">     * items without resize.  So we create medium size dict instead of very</span></span><br><span class="line"><span class="comment">     * large dict or MemoryError.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (minused &gt; USABLE_FRACTION(max_presize)) &#123;       <span class="comment">// 检查传入的数量是否超过最大值</span></span><br><span class="line">        newsize = max_presize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_ssize_t minsize = ESTIMATE_SIZE(minused);    <span class="comment">// 获取最小的值,在新建一个空的字典的时候该值为０</span></span><br><span class="line">        newsize = PyDict_MINSIZE;                       <span class="comment">// 设置字典的最小值　为８</span></span><br><span class="line">        <span class="keyword">while</span> (newsize &lt; minsize) &#123;                     <span class="comment">// 如果传入的值大于最小值则调整newsize 大小</span></span><br><span class="line">            newsize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(IS_POWER_OF_2(newsize));</span><br><span class="line"></span><br><span class="line">    new_keys = new_keys_object(newsize);                <span class="comment">// 生成并初始化一个PyDictKeysObject对象</span></span><br><span class="line">    <span class="keyword">if</span> (new_keys == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> new_dict(new_keys, <span class="literal">NULL</span>);                    <span class="comment">// 生成一个新的对象并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，先计算出需要生成的字典的大小，然后再初始化一个 PyDictKeysObject，最后就生成一个 PyDictObject 返回。继续查看 new_keys_object 的执行流程；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0w1MDM=">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyDictKeysObject *<span class="title">new_keys_object</span><span class="params">(Py_ssize_t size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyDictKeysObject *dk;</span><br><span class="line">    Py_ssize_t es, usable;</span><br><span class="line"></span><br><span class="line">    assert(size &gt;= PyDict_MINSIZE);           <span class="comment">// 检查size是否大于最小size</span></span><br><span class="line">    assert(IS_POWER_OF_2(size));              <span class="comment">// 检查是否是２的倍数</span></span><br><span class="line"></span><br><span class="line">    usable = USABLE_FRACTION(size);           <span class="comment">// 检查是否可用　　根据经验在１/2和２/3之间效果最好</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0xff</span>) &#123;</span><br><span class="line">        es = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        es = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">0xffffffff</span>) &#123;</span><br><span class="line">        es = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        es = <span class="keyword">sizeof</span>(Py_ssize_t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; <span class="number">0</span>) &#123;　　　　　　<span class="comment">// 是否有缓存，如果有缓存就选择缓存中的dk</span></span><br><span class="line">        dk = keys_free_list[--numfreekeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dk = PyObject_MALLOC(<span class="keyword">sizeof</span>(PyDictKeysObject)</span><br><span class="line">                             + es * size</span><br><span class="line">                             + <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);    <span class="comment">// 没有缓存可使用的字典则申请内存生成一个</span></span><br><span class="line">        <span class="keyword">if</span> (dk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_NoMemory();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DK_DEBUG_INCREF dk-&gt;dk_refcnt = <span class="number">1</span>;                              <span class="comment">// 设置引用计数</span></span><br><span class="line">    dk-&gt;dk_size = size;                                             <span class="comment">// 设置大小</span></span><br><span class="line">    dk-&gt;dk_usable = usable;                                        <span class="comment">// 设置是否可用</span></span><br><span class="line">    dk-&gt;dk_lookup = lookdict_unicode_nodummy;                       <span class="comment">// 设置查找函数</span></span><br><span class="line">    dk-&gt;dk_nentries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dk-&gt;dk_indices[<span class="number">0</span>], <span class="number">0xff</span>, es * size);                    <span class="comment">// 将申请的内存置空</span></span><br><span class="line">    <span class="built_in">memset</span>(DK_ENTRIES(dk), <span class="number">0</span>, <span class="keyword">sizeof</span>(PyDictKeyEntry) * usable);</span><br><span class="line">    <span class="keyword">return</span> dk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是通过传入的 size，检查是否超过设置的大小，检查是否有缓存的字典数据可用，如果没有则申请内存重新生成一个 dk，最后进行申请到的内存讲内容清空。接着就会进行 new_dict 初始化数据；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0w1Njg=">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Consumes a reference to the keys object */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">new_dict</span><span class="params">(PyDictKeysObject *keys, PyObject **values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (numfree) &#123;　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 判断缓冲池是否有</span></span><br><span class="line">        mp = free_list[--numfree];</span><br><span class="line">        assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);　</span><br><span class="line">        _Py_NewReference((PyObject *)mp);　　　　　　　　　　　　　　<span class="comment">// 使用缓冲池对象　　　　</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);　　　　<span class="comment">// 缓冲池没有则申请新的对象并初始化</span></span><br><span class="line">        <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            DK_DECREF(keys);</span><br><span class="line">            free_values(values);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mp-&gt;ma_keys = keys;</span><br><span class="line">    mp-&gt;ma_values = values;</span><br><span class="line">    mp-&gt;ma_used = <span class="number">0</span>;　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 设置ma_used为0</span></span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new_dict 就是根据 keys，values 设置到从缓冲池或者新生成一个 dict 对象，最后返回。至此，dict 的创建工作已经完成。</p>
<h2 id="字典的插入与查找"><a href="#字典的插入与查找" class="headerlink" title="字典的插入与查找"></a>字典的插入与查找</h2><p>通过字节码的指令 STORE_SUBSCR 可知，该命令就是讲’1’作为 key, ‘2’作为 value 插入到 d 中，此时查看该执行函数；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL1B5dGhvbi9jZXZhbC5jI0wxNTYx">Python/ceval.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Python/ceval.c</span></span><br><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    TARGET(STORE_SUBSCR) &#123;</span><br><span class="line">        PyObject *sub = TOP();                 <span class="comment">// 第一个值为key</span></span><br><span class="line">        PyObject *container = SECOND();        <span class="comment">// 该为字典对象</span></span><br><span class="line">        PyObject *v = THIRD();                 <span class="comment">// 该为value</span></span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        STACKADJ(<span class="number">-3</span>);</span><br><span class="line">        <span class="comment">/* container[sub] = v */</span></span><br><span class="line">        err = PyObject_SetItem(container, sub, v);  <span class="comment">// 调用该方法设置值</span></span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        Py_DECREF(container);</span><br><span class="line">        Py_DECREF(sub);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，从栈中取出相关参数，并将这些值传入 PyObject_SetItem 函数进行处理设置值；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvYWJzdHJhY3QuYyNMMTg2">Objects/abstract.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/abstract.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">PyObject_SetItem</span><span class="params">(PyObject *o, PyObject *key, PyObject *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyMappingMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || key == <span class="literal">NULL</span> || value == <span class="literal">NULL</span>) &#123;　　　　　　　　　　　<span class="comment">// 检查是否为空如果任一为空则报错</span></span><br><span class="line">        null_error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = o-&gt;ob_type-&gt;tp_as_mapping;　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 获取类型的tp_as_mapping方法集　　　　　</span></span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;mp_ass_subscript)　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 如果有设置该类型</span></span><br><span class="line">        <span class="keyword">return</span> m-&gt;mp_ass_subscript(o, key, value);                    <span class="comment">// 调用该mp_ass_subscript方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;ob_type-&gt;tp_as_sequence) &#123;                                 <span class="comment">// 获取作为队列的操作集</span></span><br><span class="line">        <span class="keyword">if</span> (PyIndex_Check(key)) &#123;　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 检查key是否是索引</span></span><br><span class="line">            Py_ssize_t key_value;</span><br><span class="line">            key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);　</span><br><span class="line">            <span class="keyword">if</span> (key_value == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> PySequence_SetItem(o, key_value, value);　　　　　　　<span class="comment">// 调用索引插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_ass_item) &#123;</span><br><span class="line">            type_error(<span class="string">&quot;sequence index must be &quot;</span></span><br><span class="line">                       <span class="string">&quot;integer, not &#x27;%.200s&#x27;&quot;</span>, key);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type_error(<span class="string">&quot;&#x27;%.200s&#x27; object does not support item assignment&quot;</span>, o);　　　<span class="comment">// 则该类型对象不支持设置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中就调用了字典的 tp_as_mapping 的方法集，并调用了该方法集的 mp_ass_subscript 方法；此时我们分析一下，dict 的 tp_as_mapping 的方法集。此时就调用了 tp_as_mapping 的 mp_ass_subscript 方法，此时就是调用 dict 的 dict_ass_sub 方法；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0wyMDQw">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">dict_ass_sub</span><span class="params">(PyDictObject *mp, PyObject *v, PyObject *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyDict_DelItem((PyObject *)mp, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> PyDict_SetItem((PyObject *)mp, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，删除一个 key 就是 PyDict_DelItem,设置一个 key 就是 PyDict_SetItem；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0wxNDMz">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">PyDict_SetItem</span><span class="params">(PyObject *op, PyObject *key, PyObject *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;　　　　　　　　　　　 <span class="comment">// 检查是否是字典类型</span></span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>)　　<span class="comment">// 检查传入的key是否hash为-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        hash = PyObject_Hash(key);                      <span class="comment">// 生成hash调用key对应的tp_hash方法，在本例中传入的是str类型，则调用str类型的tp_hash方法</span></span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* insertdict() handles any resizing that might be necessary */</span></span><br><span class="line">    <span class="keyword">return</span> insertdict(mp, key, hash, value);          <span class="comment">// 生成hash调用key对应的tp_hash方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>insertdict 方法就是将生成的方法，插入到字典中去；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0w5ODc=">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">insertdict</span><span class="params">(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject *old_value;</span><br><span class="line">    PyDictKeyEntry *ep;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(key);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_values != <span class="literal">NULL</span> &amp;&amp; !PyUnicode_CheckExact(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)                     <span class="comment">// 重新设置mp的大小  如果ma_values有值</span></span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;old_value);　　　　 <span class="comment">// 调用查找方法</span></span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> Fail;</span><br><span class="line"></span><br><span class="line">    assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict);</span><br><span class="line">    MAINTAIN_TRACKING(mp, key, value);                                        <span class="comment">// 检查mp key values是否需要加入垃圾回收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When insertion order is different from shared key, we can&#x27;t share</span></span><br><span class="line"><span class="comment">     * the key anymore.  Convert this instance to combine table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp) &amp;&amp;</span><br><span class="line">        ((ix &gt;= <span class="number">0</span> &amp;&amp; old_value == <span class="literal">NULL</span> &amp;&amp; mp-&gt;ma_used != ix) ||</span><br><span class="line">         (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123;　　<span class="comment">// 检查是否是分离表，如果没查找到旧值并且</span></span><br><span class="line">        <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 重新设置该字典大小</span></span><br><span class="line">            <span class="keyword">goto</span> Fail;</span><br><span class="line">        ix = DKIX_EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;</span><br><span class="line">        <span class="comment">/* Insert into new slot. */</span></span><br><span class="line">        assert(old_value == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_keys-&gt;dk_usable &lt;= <span class="number">0</span>) &#123;　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 如果可用的值小于０</span></span><br><span class="line">            <span class="comment">/* Need to resize. */</span></span><br><span class="line">            <span class="keyword">if</span> (insertion_resize(mp) &lt; <span class="number">0</span>)　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 需要重新扩展字典大小</span></span><br><span class="line">                <span class="keyword">goto</span> Fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_ssize_t hashpos = find_empty_slot(mp-&gt;ma_keys, hash);　　　　　　　　　<span class="comment">// 查找一个可用的hash位置</span></span><br><span class="line">        ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[mp-&gt;ma_keys-&gt;dk_nentries];　　　　　　　　　<span class="comment">// 获取存取的地址</span></span><br><span class="line">        dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries);　　　　　　<span class="comment">// 设置该值</span></span><br><span class="line">        ep-&gt;me_key = key;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 保存key</span></span><br><span class="line">        ep-&gt;me_hash = hash;                                                   <span class="comment">// 保存计算得出的hash值</span></span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;ma_values) &#123;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 如果mp的ma_values有值</span></span><br><span class="line">            assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == <span class="literal">NULL</span>);</span><br><span class="line">            mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value;　　　　　　　　　　　<span class="comment">// 设置该key对应的value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ep-&gt;me_value = value;                                             <span class="comment">// 直接讲value设置到entry上面</span></span><br><span class="line">        &#125;</span><br><span class="line">        mp-&gt;ma_used++;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 <span class="comment">// 使用个数加１</span></span><br><span class="line">        mp-&gt;ma_version_tag = DICT_NEXT_VERSION();　　</span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_usable--;　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 可用减１</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_nentries++;</span><br><span class="line">        assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= <span class="number">0</span>);</span><br><span class="line">        assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_PyDict_HasSplitTable(mp)) &#123;                                         <span class="comment">// 如果是分离的</span></span><br><span class="line">        mp-&gt;ma_values[ix] = value;                                           <span class="comment">// 直接设置ma_values对应的ix到values中</span></span><br><span class="line">        <span class="keyword">if</span> (old_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* pending state */</span></span><br><span class="line">            assert(ix == mp-&gt;ma_used);</span><br><span class="line">            mp-&gt;ma_used++;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 使用加１</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(old_value != <span class="literal">NULL</span>);</span><br><span class="line">        DK_ENTRIES(mp-&gt;ma_keys)[ix].me_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    Py_XDECREF(old_value); <span class="comment">/* which **CAN** re-enter (see issue #22653) */</span></span><br><span class="line">    assert(_PyDict_CheckConsistency(mp));</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Fail:</span><br><span class="line">    Py_DECREF(value);</span><br><span class="line">    Py_DECREF(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用相关的查找方法，去查找待搜索的值是否已经存在字典中，如果当前字典数据已经满了则会按照增长大小的函数生成一个新的字典，并把旧数据设置到新的字典中，当找到的字典匹配时则返回。</p>
<p>其中 dk_lookup 对应的方法，在初始化之后对应的是 lookdict_unicode_nodummy；</p>
<p><code>源文件：</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuNy4wL09iamVjdHMvZGljdG9iamVjdC5jI0w4MTM=">Objects/dictobject.c<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Faster version of lookdict_unicode when it is known that no &lt;dummy&gt; keys</span></span><br><span class="line"><span class="comment"> * will be present. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Py_ssize_t _Py_HOT_FUNCTION</span></span><br><span class="line"><span class="function"><span class="title">lookdict_unicode_nodummy</span><span class="params">(PyDictObject *mp, PyObject *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Py_hash_t hash, PyObject **value_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(mp-&gt;ma_values == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Make sure this function doesn&#x27;t have to handle non-unicode keys,</span></span><br><span class="line"><span class="comment">       including subclasses of str; e.g., one reason to subclass</span></span><br><span class="line"><span class="comment">       unicodes is to override __eq__, and for speed we don&#x27;t cater to</span></span><br><span class="line"><span class="comment">       that here. */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key)) &#123;　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 检查如果不是ｕｎicode则直接调用lookdict方法查找</span></span><br><span class="line">        mp-&gt;ma_keys-&gt;dk_lookup = lookdict;</span><br><span class="line">        <span class="keyword">return</span> lookdict(mp, key, hash, value_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyDictKeyEntry *ep0 = DK_ENTRIES(mp-&gt;ma_keys);　　　　　　　　　　　　　<span class="comment">// 获取keys的首个元素地址</span></span><br><span class="line">    <span class="keyword">size_t</span> mask = DK_MASK(mp-&gt;ma_keys);　　　　　　　　　　　　　　　　　　　　<span class="comment">// 获取大小</span></span><br><span class="line">    <span class="keyword">size_t</span> perturb = (<span class="keyword">size_t</span>)hash;</span><br><span class="line">    <span class="keyword">size_t</span> i = (<span class="keyword">size_t</span>)hash &amp; mask;　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 获取生成的最终的值　　　　　　　　　　　　　　　　　</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Py_ssize_t ix = dk_get_index(mp-&gt;ma_keys, i);                <span class="comment">// 便利ma_keys　ｋey列表</span></span><br><span class="line">        assert (ix != DKIX_DUMMY);　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 判断不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (ix == DKIX_EMPTY) &#123;                                     <span class="comment">// 如果为空则证明找到一个可以使用的</span></span><br><span class="line">            *value_addr = <span class="literal">NULL</span>;　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 讲key对应的value设置为空</span></span><br><span class="line">            <span class="keyword">return</span> DKIX_EMPTY;　　　　　　　　　　　　　　　　　　　　　　　 <span class="comment">// 返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        PyDictKeyEntry *ep = &amp;ep0[ix];           　　　　　　　　　　　　<span class="comment">// 获取该位置元素值</span></span><br><span class="line">        assert(ep-&gt;me_key != <span class="literal">NULL</span>);</span><br><span class="line">        assert(PyUnicode_CheckExact(ep-&gt;me_key));</span><br><span class="line">        <span class="keyword">if</span> (ep-&gt;me_key == key ||</span><br><span class="line">            (ep-&gt;me_hash == hash &amp;&amp; unicode_eq(ep-&gt;me_key, key))) &#123;　　<span class="comment">// 如果key相同 ｈａｓｈ值也相同</span></span><br><span class="line">            *value_addr = ep-&gt;me_value;　　　　　　　　　　　　　　　　　　　 <span class="comment">// 将该值赋值</span></span><br><span class="line">            <span class="keyword">return</span> ix;</span><br><span class="line">        &#125;</span><br><span class="line">        perturb &gt;&gt;= PERTURB_SHIFT;　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// 偏移</span></span><br><span class="line">        i = mask &amp; (i*<span class="number">5</span> + perturb + <span class="number">1</span>);　　　　　　　　　　　　　　　　　　　<span class="comment">// 获取下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的主要工作就是查找，字典中是否有空余的值，或者如果找到了满足 hash 值与 key 相同的就将 value 设置为找到的值（这也是字典查找的核心逻辑）。至此，字典的插入的大致流程已经分析完毕。</p>
<h2 id="Python-字典的操作测试"><a href="#Python-字典的操作测试" class="headerlink" title="Python 字典的操作测试"></a>Python 字典的操作测试</h2><p>现在我们动手观看一下具体的操作实例，首先声明，该例子仅供调试使用，目前调试的字典的 key 与 value 都是 float 类型并且不能 del 或者 pop 其中的 key。操作字典如下所示；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ｄ = &#123;<span class="number">20000</span>:<span class="number">2</span>&#125;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="number">3</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>首先，讲如下代码插入到 dictobject.c 的 1060 行；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">PyObject* key1 = PyLong_FromLong(<span class="number">20000</span>);</span><br><span class="line">Py_hash_t hash1 = PyObject_Hash(key1);</span><br><span class="line">PyObject* old_value1;</span><br><span class="line">Py_ssize_t ix1 = mp-&gt;ma_keys-&gt;dk_lookup(mp, key1, hash1, &amp;old_value1);</span><br><span class="line"><span class="keyword">if</span> (ix1 == <span class="number">0</span>)&#123;</span><br><span class="line">    PyLongObject* give;</span><br><span class="line">    give = (PyLongObject* )key1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;found value : %ld\n&quot;</span>, give-&gt;ob_digit[<span class="number">0</span>]);</span><br><span class="line">    PyDictKeyEntry *ep01 = DK_ENTRIES(mp-&gt;ma_keys);</span><br><span class="line">    <span class="keyword">int</span> i, count;</span><br><span class="line">    count = mp-&gt;ma_used;</span><br><span class="line">    <span class="keyword">int</span> size_count, j;</span><br><span class="line">    size_count = mp-&gt;ma_keys-&gt;dk_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, mp-&gt;ma_keys-&gt;dk_indices);</span><br><span class="line">    <span class="keyword">int8_t</span> *indices = (<span class="keyword">int8_t</span>*)(mp-&gt;ma_keys-&gt;dk_indices);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;indices index values :&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;size_count;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,(<span class="keyword">char</span>) indices[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">        give = (PyLongObject* )ep01-&gt;me_key;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size : %d &quot;</span>, mp-&gt;ma_keys-&gt;dk_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;found value while 　key : %ld   &quot;</span>, give-&gt;ob_digit[<span class="number">0</span>]);</span><br><span class="line">        give = (PyLongObject* )ep01-&gt;me_value;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;value  : %ld\n&quot;</span>, give-&gt;ob_digit[<span class="number">0</span>]);</span><br><span class="line">        ep01++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译运行；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">3.7</span><span class="number">.3</span> (default, May <span class="number">22</span> <span class="number">2019</span>, <span class="number">16</span>:<span class="number">17</span>:<span class="number">57</span>)</span><br><span class="line">[GCC <span class="number">7.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">20000</span>:<span class="number">2</span>&#125;</span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>其中为什么初始化的时候输入 20000，是根据代码找到相关的 key 值，因为字典也被 python 自身实现的结构中引用了多次，所以我们就设置了一个特殊值来跟踪我们想要的字典；当 d 初始化的时候，就输出如上所示内容；我们接下来继续操作；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">20000</span>:<span class="number">2</span>&#125;</span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">3</span>   value  : <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  -<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">3</span>   value  : <span class="number">4</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">5</span>   value  : <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">7</span>] = <span class="number">8</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  -<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  <span class="number">4</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">3</span>   value  : <span class="number">4</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">5</span>   value  : <span class="number">6</span></span><br><span class="line">size : <span class="number">8</span> found value <span class="keyword">while</span> 　key : <span class="number">7</span>   value  : <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>此后我们一直添加值进 d，从输出信息可知，index 就是记录了 PyDictKeyEntry 的索引值，-1 就表示该处未使用。<br>当我们继续向 d 中添加内容时；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">9</span>] = <span class="number">10</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  -<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  <span class="number">4</span>  -<span class="number">1</span>  <span class="number">5</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">3</span>   value  : <span class="number">4</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">5</span>   value  : <span class="number">6</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">7</span>   value  : <span class="number">8</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">9</span>   value  : <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">10</span>] = <span class="number">11</span></span><br><span class="line">found value : <span class="number">20000</span></span><br><span class="line"> indices index values :<span class="number">0</span>  -<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  -<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  <span class="number">4</span>  -<span class="number">1</span>  <span class="number">5</span>  <span class="number">6</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span>  -<span class="number">1</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">20000</span>   value  : <span class="number">2</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">2</span>   value  : <span class="number">3</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">3</span>   value  : <span class="number">4</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">5</span>   value  : <span class="number">6</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">7</span>   value  : <span class="number">8</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">9</span>   value  : <span class="number">10</span></span><br><span class="line">size : <span class="number">16</span> found value <span class="keyword">while</span> 　key : <span class="number">10</span>   value  : <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>从输出内容可知，字典的大小随之改变了，这也说明了 python 字典的最佳大小容量限定在 1/2 到 2/3 之间，如果超过这个阈值则字典就会自动扩容，扩容的策略大家可详细查看源码。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>programing</category>
        <category>lan</category>
        <category>python</category>
        <category>cpython源码</category>
        <category>objects</category>
        <category>dict</category>
      </categories>
  </entry>
</search>
